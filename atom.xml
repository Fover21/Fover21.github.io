<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海燕</title>
  
  <subtitle>热爱编程，爱算法，爱生活，爱钻研</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-13T15:18:22.587Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>海燕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuex+axios</title>
    <link href="http://yoursite.com/2018/11/13/Vuex-axios/"/>
    <id>http://yoursite.com/2018/11/13/Vuex-axios/</id>
    <published>2018-11-13T13:54:25.000Z</published>
    <updated>2018-11-13T15:18:22.587Z</updated>
    
    <content type="html"><![CDATA[<p><center><h1>Vuex+axios</h1></center><br><a id="more"></a></p><h1 id="Vuex-简介"><a href="#Vuex-简介" class="headerlink" title="Vuex 简介"></a>Vuex 简介</h1><pre><code>vuex是一个专门为Vue.js设计的集中式状态管理架构。状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。Vuex和单纯的全局对象有以下不同：1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。</code></pre><h2 id="安装使用vuex"><a href="#安装使用vuex" class="headerlink" title="安装使用vuex"></a>安装使用vuex</h2><p>–  npm install vuex</p><pre><code>vuex的使用一// main.jsimport Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import vuex from &apos;vuex&apos;Vue.use(vuex)Vue.config.productionTip = falseconst store = new vuex.Store({    state: {    show: false,    }});new Vue({el: &apos;#app&apos;,router,store,components: { App },template: &apos;&lt;App/&gt;&apos;});vuex的使用二// 为了方便维护，我们通常把在src下面新建一个store文件夹，// 然后在里面新建一个index.jsimport Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    show: false,    },});// 那么main.js要改成import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import store from &quot;./store&quot;Vue.config.productionTip = false;new Vue({el: &apos;#app&apos;,router,store,components: { App },template: &apos;&lt;App/&gt;&apos;});</code></pre><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><pre><code>简而言之~~state是保存我们data中需要共享的数据。由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。this.$store.state.count</code></pre><p>组件中获取vuex中状态</p><pre><code>// 创建一个组件const Counter = {template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,computed: {    count(){    return this.$store.state.count    }}};</code></pre><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。</p><p>并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。</p><p>我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被</p><p>缓存起来，只有它的依赖发生改变时，才会重新计算。</p><p>Getter会接收state作为其第一个参数：</p><pre><code>import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 通过 this.$store.getters.my_funcgetters: {    my_func: function (state) {    return state.count * 2    }},});</code></pre><p>Getter也可以接收getters为第二个参数：</p><pre><code>import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 通过 this.$store.getters.my_funcgetters: {    my_func: function (state) {    return state.count * 2    },    // 通过 this.$store.getters.my_func_count    my_func_count: function (state, getters) {    return getters.my_func.length    }},});</code></pre><h2 id="Mutatiion"><a href="#Mutatiion" class="headerlink" title="Mutatiion"></a>Mutatiion</h2><p>更改Vuex中的store中的状态的唯一方法是提交mutation。</p><p>每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。</p><p>也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。</p><p>这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数：</p><pre><code>Mutation基本使用import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 需要通过 this.$store.commit(&apos;increment&apos;, 10)mutations: {    increment (state, n) {    // 变更状态    state.count += n    }}});</code></pre><p>Mutation需要遵守Vue的响应规则</p><p>既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。</p><p>这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项：</p><p>　　– 1，最好提前在你的store中初始化好所有的所需要的属性</p><p>　　– 2，当对象需要添加属性时，你应该使用</p><p>　　　　　　–  Vue.set(obj, ‘newProp’, 123)</p><p>　　　　　　–  以新对象代替老对象  state.obj = { …state.obj, newProp: 123}</p><h1 id="axios的简单使用"><a href="#axios的简单使用" class="headerlink" title="axios的简单使用"></a>axios的简单使用</h1><p>基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。</p><p>##　使用npm安装axios</p><p>– npm install axios -D</p><h2 id="基本的配置"><a href="#基本的配置" class="headerlink" title="基本的配置"></a>基本的配置</h2><pre><code>// main.jsimport axios from &quot;axios&quot;Vue.prototype.$axios = axios// 组件中methods: {    init () {        this.$axios({            method: &quot;get&quot;,            url: &quot;/user&quot;        })    },};</code></pre><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><p>get请求</p><pre><code>test(){      this.$axios.get(this.$store.state.apiList.course,{        params: {          id: 123,        }      }).then(function (response) {        // 请求成功回调函数      }).catch(function (response) {        // 请求失败的回调函数      })}</code></pre><p>post请求</p><pre><code>test(){      this.$axios.post(this.$store.state.apiList.course,{          course_title: &quot;Python&quot;,          course_price: &quot;19.88&quot;      }).then(function (response) {        // 请求成功回调函数      }).catch(function (response) {        // 请求失败的回调函数      })}</code></pre><p>发送多个并发请求</p><pre><code>function getCourse(){      return this.$axios.get(&apos;/course/12&apos;)    }function getCourse_all() {        return this.$axios.get(&apos;/course&apos;)        }this.$axios.all([getCourse_all(),getCourse()])        .then().catch()</code></pre><p>axios.request</p><pre><code>methods: {      init(){        var that = this        this.$axios.request({          url: that.$store.state.apiList.course,          method: &apos;get&apos;        }).then(function (data) {          if (data.status === 200){              that.courseList = data.data          }        }).catch(function (reason) {          console.log(reason)        })      }},</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;h1&gt;Vuex+axios&lt;/h1&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>npm+webpack+vue-cli快速上手</title>
    <link href="http://yoursite.com/2018/11/13/npm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://yoursite.com/2018/11/13/npm-webpack-vue-cli快速上手/</id>
    <published>2018-11-13T12:53:56.000Z</published>
    <updated>2018-11-13T13:15:51.310Z</updated>
    
    <content type="html"><![CDATA[<center><h1>npm+webpack+vue-cli快速上手</h1></center><a id="more"></a><h1 id="Node-js-npm"><a href="#Node-js-npm" class="headerlink" title="Node.js   npm"></a>Node.js   npm</h1><h2 id="什么是Node-js-以及npm"><a href="#什么是Node-js-以及npm" class="headerlink" title="什么是Node.js  以及npm"></a>什么是Node.js  以及npm</h2><pre><code>简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。npm 是Node.js 的包管理工具。</code></pre><h2 id="npm的安装和更新"><a href="#npm的安装和更新" class="headerlink" title="npm的安装和更新"></a>npm的安装和更新</h2><pre><code>Node.js下载安装   Node.js 官网下载安装。npm自带的包管理工具。查看安装版本信息：</code></pre><p>　　    –  node -v  查看Node.js 版本信息</p><p>　　    –  npm -v  查看npm版本信息</p><pre><code>更新npm到指定版本：</code></pre><p>　　    –  npm install <a href="mailto:npm@5.3.0" target="_blank" rel="noopener">npm@5.3.0</a> -g</p><p>　　    – npm install npm@latest -g 更新最新的稳定版本</p><h2 id="npm-常用操作"><a href="#npm-常用操作" class="headerlink" title="npm 常用操作"></a>npm 常用操作</h2><pre><code>之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。有了npm，我们管理自己的依赖包以及版本更加简单。到自己项目目录下，进行以下命令：</code></pre><p>　　    – npm init -y    输入-y使用默认配置项 生成package.json文件。</p><p>　　    – npm i <a href="mailto:jquery@0.0.0" target="_blank" rel="noopener">jquery@0.0.0</a>   简写install 为 i 下载依赖  不写@ 默认最新版本</p><p>　　    – npm uninstall jquery  卸载依赖包</p><p>　　    – npm update jquery   更新依赖包</p><p>　　    – npm list  列出已安装的依赖</p><p>　　    – npm install webpack –D 保存为开发环境依赖</p><p>　　    – 老版本需要 –save 参数 现在不需要了</p><pre><code>我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。如果我们删掉 node_modules目录，可以使用 npm i  来下载所有依赖。</code></pre><h2 id="npm-常用配置项"><a href="#npm-常用配置项" class="headerlink" title="npm 常用配置项"></a>npm 常用配置项</h2><pre><code>当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。在我们的package.json文件中有很多配置项</code></pre><p>　　    – name  项目名字 中间不能有空格只能用小写</p><p>　　    – version  项目版本</p><p>　　    – description   项目描述信息</p><p>　　    – main  项目的入口文件</p><p>　　    – scripts 指定命令的快捷方式 npm run test     test是scripts里的键名 值为具体命令</p><p>　　    – author 作者</p><p>　　    – license  许可证</p><p>　　    – dependencies  生成环境依赖的包以及版本信息</p><p>　　    – devDependencies  开发环境的依赖</p><h1 id="webpack3"><a href="#webpack3" class="headerlink" title="webpack3"></a>webpack3</h1><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析，</p><p>然后将这些模块按照指定的规则生成静态资源。</p><p>那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##安装和配置</span><br><span class="line">    webpack是跑在Node.js环境下的，所以确定自己有node环境。</span><br><span class="line"></span><br><span class="line">安装方式：</span><br><span class="line"></span><br><span class="line">　　-- npm install webpack -g  全局安装</span><br><span class="line"></span><br><span class="line">　　-- webpack  &lt;要打包文件&gt;  &lt;打包后文件&gt;     全局这种方式进行打包</span><br><span class="line"></span><br><span class="line">　　-- npm install webpack   在自己的项目下 npm init 后在下载webpack 这就是局部安装</span><br><span class="line"></span><br><span class="line">　　-- node_modules/.bin/webpack &lt;要打包文件&gt;  &lt;打包后文件&gt;   项目里要打包文件是入口文件</span><br><span class="line"></span><br><span class="line">　　-- 路径太长 太烦 可以自定义命令  在package.json 文件的 scripts下面自定义</span><br><span class="line"></span><br><span class="line">## entry 和 output</span><br><span class="line">    entry 入口文件  output 出口文件</span><br><span class="line"></span><br><span class="line">    上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~</span><br><span class="line"></span><br><span class="line">    我们可以把命令写在webpack.config.js文件中~~</span><br><span class="line">&gt;webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">    // 所有的入口文件</span><br><span class="line">    entry: &#123;</span><br><span class="line">         home: &apos;./main.js&apos;, </span><br><span class="line">         login: &apos;./login.js&apos;,</span><br><span class="line">    &#125;, </span><br><span class="line">    // 出口文件  </span><br><span class="line">    output: &#123;</span><br><span class="line">         filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">         path: __dirname + &apos;/dist&apos;,</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line">// backage.json  下的scripts</span><br><span class="line">scripts: &#123;</span><br><span class="line">     &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;</span><br><span class="line">&#125;</span><br><span class="line">//  运行命令</span><br><span class="line">npm  run pack</span><br><span class="line"></span><br><span class="line"># webpack4</span><br><span class="line">## webpack的新特性</span><br><span class="line">1, webpack不在单独使用，需要webpack-cli</span><br><span class="line"></span><br><span class="line">　　-- 全局安装  npm install webpack webpack-cli -g -D</span><br><span class="line"></span><br><span class="line">　　-- 局部安装  npm install webpack webpack-cli -D</span><br><span class="line"></span><br><span class="line">2, 增加了模式区分 （development, production）</span><br><span class="line"></span><br><span class="line">　　--webpack --mode development/production 进行模式切换</span><br><span class="line"></span><br><span class="line">　　-- development 开发者模式 打包默认不压缩代码</span><br><span class="line"></span><br><span class="line">　　-- production  生产者模式 上线时使用，压缩代码。 默认是这个模式</span><br><span class="line"></span><br><span class="line">3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下</span><br><span class="line"></span><br><span class="line">　　-- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js</span><br><span class="line"></span><br><span class="line">4，多入口以及多出口</span><br><span class="line">&gt;webpack.config.js　</span><br><span class="line">entry: &#123;</span><br><span class="line">    // 多入口</span><br><span class="line">    a: &quot;./src/js/index.js&quot;,</span><br><span class="line">    b: &quot;./src/js/index2.js&quot;,</span><br><span class="line">&#125;</span><br><span class="line">output: &#123;</span><br><span class="line">    // 多出口</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;./js/[name].bundle.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># vue-cli</span><br><span class="line">vue-cli是官方提供的快速构建这个单页面应用的脚手架。</span><br><span class="line"></span><br><span class="line">## 根据官方文档中的构件流程：</span><br><span class="line"></span><br><span class="line">　　-- 前提是已经安装了node.js 否则npm都用不了</span><br><span class="line"></span><br><span class="line">　　-- 1，使用npm全局安装vue-cli </span><br><span class="line"></span><br><span class="line">　　　　　　npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">　　-- 2, 安装完成后在自己的工作空间里</span><br><span class="line"></span><br><span class="line">　　　　　　vue init webpack vue-demo  </span><br><span class="line"></span><br><span class="line">　　　　输入命令后进入安装阶段，需要用户输入一些信息 这里省略了.....</span><br><span class="line"></span><br><span class="line">　　-- 3，切换到我们的项目目录下 </span><br><span class="line"></span><br><span class="line">　　　　　　cd vue-demo</span><br><span class="line"></span><br><span class="line">　　　　　　npm run dev</span><br><span class="line"></span><br><span class="line">## 目录结构：</span><br><span class="line"></span><br><span class="line">　　-- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件</span><br><span class="line"></span><br><span class="line">　　-- config 配置文件，执行文件需要的配置信息</span><br><span class="line"></span><br><span class="line">　　-- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下</span><br><span class="line"></span><br><span class="line">　　-- node_modules  项目依赖包</span><br><span class="line"></span><br><span class="line">　　-- static 静态资源</span><br><span class="line"></span><br><span class="line">　　-- package.json   依赖包的json文件</span><br><span class="line"></span><br><span class="line">其实这里面命令很多~我们在后续项目中应用到再说</span><br></pre></td></tr></table></figure></p><h1 id="vue-cli配置JQuery、bootstrap"><a href="#vue-cli配置JQuery、bootstrap" class="headerlink" title="vue-cli配置JQuery、bootstrap"></a>vue-cli配置JQuery、bootstrap</h1><h2 id="第一步-下载安装"><a href="#第一步-下载安装" class="headerlink" title="第一步  下载安装"></a>第一步  下载安装</h2><p>　　– npm install jquery </p><p>　　– npm install bootstrap </p><h2 id="第二步-修改build-webpack-base-conf-js"><a href="#第二步-修改build-webpack-base-conf-js" class="headerlink" title="第二步 修改build/webpack.base.conf.js"></a>第二步 修改build/webpack.base.conf.js</h2><blockquote><p>const webpack = require(‘webpack’)<br>// 在module.exports里添加插件<br>plugins: [<br>    new webpack.ProvidePlugin({<br>      $: “jquery”,<br>      jQuery: “jquery”,<br>      “windows.jQuery”: “jquery”,<br>      // Popper: [‘popper.js’, ‘default’]<br>    })<br>],<br>//  <strong>***</strong>下面是如果手动下载bootstrap用的<strong>***</strong><br>resolve: {<br>    extensions: [‘.js’, ‘.vue’, ‘.json’],<br>    alias: {<br>      ‘vue$’: ‘vue/dist/vue.esm.js’,<br>      ‘@’: resolve(‘src’),<br>      // 如果是手动下载的bootstrap需要添加这个配置<br>      // ‘assets’: path.resolve(__dirname, ‘../src/assets’),<br>      // ‘jquery’: ‘jquery/src/jquery’<br>    }<br>  },</p></blockquote><p>修改配置文件</p><h2 id="第三步-修改主程序的js文件-main-js"><a href="#第三步-修改主程序的js文件-main-js" class="headerlink" title="第三步 修改主程序的js文件 main.js"></a>第三步 修改主程序的js文件 main.js</h2><blockquote><p>import $ from ‘jquery’<br>import ‘bootstrap/dist/css/bootstrap.min.css’<br>import ‘bootstrap/dist/js/bootstrap.min.js’</p></blockquote><h1 id="vue-cli-3-0"><a href="#vue-cli-3-0" class="headerlink" title="vue-cli 3.0"></a>vue-cli 3.0</h1><h2 id="第一步-下载vue-cli-3-0"><a href="#第一步-下载vue-cli-3-0" class="headerlink" title="第一步 下载vue-cli 3.0"></a>第一步 下载vue-cli 3.0</h2><p>　　– npm install -g @vue/cli</p><p>　　– 报错 npm error  可以运行下面命令</p><p>　　　　– npm cache clean –force &amp;&amp; npm cache verify</p><h2 id="第二步-创建项目"><a href="#第二步-创建项目" class="headerlink" title="第二步 创建项目"></a>第二步 创建项目</h2><p>　　– vue create xxxx</p><p>　　之后会出现很多选项，我们可以根据自己的习惯去选择~~</p><h2 id="第三步-目录结构以及配置文件"><a href="#第三步-目录结构以及配置文件" class="headerlink" title="第三步 目录结构以及配置文件"></a>第三步 目录结构以及配置文件</h2><p>　　– vue-cli3 目录更加简单</p><p>　　– 我们手动在项目根目录下创建  vue.config.js 里面写vue的配置信息</p><h1 id="vue-cli3-配置jQuery、bootstrap"><a href="#vue-cli3-配置jQuery、bootstrap" class="headerlink" title="vue-cli3 配置jQuery、bootstrap"></a>vue-cli3 配置jQuery、bootstrap</h1><p>　　– 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js </p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;h1&gt;npm+webpack+vue-cli快速上手&lt;/h1&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>restful_framework(1)</title>
    <link href="http://yoursite.com/2018/11/13/restful-framework/"/>
    <id>http://yoursite.com/2018/11/13/restful-framework/</id>
    <published>2018-11-13T06:52:40.000Z</published>
    <updated>2018-11-13T06:54:36.129Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="restful framework" scheme="http://yoursite.com/categories/restful-framework/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue总结</title>
    <link href="http://yoursite.com/2018/11/13/Vue%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/13/Vue总结/</id>
    <published>2018-11-13T00:30:00.000Z</published>
    <updated>2018-11-14T01:21:20.398Z</updated>
    
    <content type="html"><![CDATA[<p><center><h1>vue总结</h1></center><br><a id="more"></a></p><h1 id="vue总结"><a href="#vue总结" class="headerlink" title="vue总结"></a>vue总结</h1><blockquote><p>MVC  Model View Controller</p></blockquote><blockquote><p>MVVM Model View ViweMode</p></blockquote><h2 id="ES6常用语法"><a href="#ES6常用语法" class="headerlink" title="ES6常用语法"></a>ES6常用语法</h2><pre><code>1.1 变量的提升1.2 模板字符串 ``${}1.3 数据的解构1.4 类 class extends constructor  super1.5 函数    1.5.1 注意this和普通函数的区别1.6 箭头函数1.7 单体模式1.8 import export   export default</code></pre><h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><pre><code>2.1 v-text  innerText2.2 v-html  innerHtml2.3 v-for  :key2.4 v-if v-else-if v-else  appendChild2.5 v-show  display2.6 v-on  @xxxx=&quot;自己处理的方法&quot;2.7 v-bind  :属性名称=“属性的值”2.8 v-model    2.8.1 input    2.8.2 textarea    2.8.3 select2.9 指令修饰符    2.9.1 .lazy    2.9.2 .number    2.9.3 .trim2.10 计算属性    2.10.1 放入缓存    2.10.2 只有数据改变的时候才会重新计算2.11 数据监听    2.11.1 注意可变类型和不可变    2.11.2 深监听  deep=true2.12 获取DOM    2.12.1 给便签绑定ref属性  ref=“属性值”    2.12.2 this.$refs.属性值2.13 自定义指令    2.13.1 vue.directive(“指令名称”, function(el, binding){        el 绑定指令的便签元素        binding 指令的所有信息    })</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>3.1 数据监听    3.1.1 改变数据        直接赋值    3.1.2 改变数组长度        能够被监听到，新值和旧值一样    3.1.3 改变数组内的值        app = new vue({})        app.$set(this.hobby, 0, &apos;抽烟&apos;)        $set()修改数组中的值可以监听        $delete()</code></pre><h2 id="Vue的组件"><a href="#Vue的组件" class="headerlink" title="Vue的组件"></a>Vue的组件</h2><h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><pre><code>Vue.compontent(“组件名称”, {})</code></pre><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><pre><code>const = app = new Vue({    el: &apos;#app&apos;,    components: {        组件的名称: 组件的配置信息    }})</code></pre><h4 id="子组件的注册"><a href="#子组件的注册" class="headerlink" title="子组件的注册"></a>子组件的注册</h4><pre><code>在父组件中注册components## 注意写组件标签## 每个组件的template只识别一个作用域块</code></pre><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h4 id="父子的通信"><a href="#父子的通信" class="headerlink" title="父子的通信"></a>父子的通信</h4><pre><code>在父组件中给子组件绑定属性子组件通过props=[&quot;属性名称&quot;]</code></pre><h4 id="子父的通信"><a href="#子父的通信" class="headerlink" title="子父的通信"></a>子父的通信</h4><pre><code>子组件先提交事件    this.$emit(&quot;事件名称&quot;, 值)在父组件中给子组件绑定事件    &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt;</code></pre><h4 id="非父子的通信"><a href="#非父子的通信" class="headerlink" title="非父子的通信"></a>非父子的通信</h4><pre><code>其中一个组件向中间调度器提交事件另一个组件监听中间调度器的事件注意this的问题中间调度器  let temp = new Vue();temp.$emit(&quot;say&quot;, value) // 事件名称和值mounted(){    that = this    // 监听中间调度器中的方法    temp.$on(&quot;say&quot;, function(data){        // 这里的this是temp的this        that.xxx = data // 这样改值    })}</code></pre><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><pre><code>&lt;slot&gt;&lt;/slot&gt;命名的插槽</code></pre><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><pre><code>代码重用的mixins = [base] </code></pre><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><h3 id="vue生命周期之beforeCreate"><a href="#vue生命周期之beforeCreate" class="headerlink" title="vue生命周期之beforeCreate"></a>vue生命周期之beforeCreate</h3><pre><code>实例创建之前除标签外，所有的vue需要的数据，事件都不存在</code></pre><h3 id="vue生命周期之created"><a href="#vue生命周期之created" class="headerlink" title="vue生命周期之created"></a>vue生命周期之created</h3><pre><code>实例创建之后，data和事件已经被解析到，el还没有找到</code></pre><h3 id="vue生命周期之beforeMount"><a href="#vue生命周期之beforeMount" class="headerlink" title="vue生命周期之beforeMount"></a>vue生命周期之beforeMount</h3><pre><code>开始找标签，数据还没有被渲染，事件也没有被监听</code></pre><h3 id="vue生命周期之mounted"><a href="#vue生命周期之mounted" class="headerlink" title="vue生命周期之mounted"></a>vue生命周期之mounted</h3><pre><code>开始渲染数据，开始监听事件</code></pre><h3 id="vue生命周期之beforeUpdata"><a href="#vue生命周期之beforeUpdata" class="headerlink" title="vue生命周期之beforeUpdata"></a>vue生命周期之beforeUpdata</h3><pre><code>数据已经被修改在虚拟DOM，但没有被渲染到页面上</code></pre><h3 id="vue生命周期之updata"><a href="#vue生命周期之updata" class="headerlink" title="vue生命周期之updata"></a>vue生命周期之updata</h3><pre><code>开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改</code></pre><h3 id="vue生命周期之beforeDestory"><a href="#vue生命周期之beforeDestory" class="headerlink" title="vue生命周期之beforeDestory"></a>vue生命周期之beforeDestory</h3><pre><code>所有的数据都存在</code></pre><h3 id="vue生命周期之destoryed"><a href="#vue生命周期之destoryed" class="headerlink" title="vue生命周期之destoryed"></a>vue生命周期之destoryed</h3><pre><code>所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了&lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签用activated和deactivated取代了beforeUpdate和destory的执行</code></pre><h3 id="最常用的钩子"><a href="#最常用的钩子" class="headerlink" title="最常用的钩子"></a>最常用的钩子</h3><pre><code>beforeMountmounted</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><pre><code>let url = [    {        path: &apos;/&apos;,        name: &quot;home&quot;,        component: {            template: ``,        }    }]let router = nwe VueRouter({    routes: url})const app = new Vue({    el: &apos;app&apos;,    router: router,})&lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt;&lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h3 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h3><pre><code>children: [    {}]append在父路由对应的组件的template里面写router-link router-view</code></pre><h3 id="路由的命名"><a href="#路由的命名" class="headerlink" title="路由的命名"></a>路由的命名</h3><pre><code>name注意to加冒号动态绑定</code></pre><h3 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h3><pre><code>{    path: &quot;/course/:id&quot;,}this.$route.params.idthis.$route.query.xxx$route 是一个对象 存放当前路由的所有信息$router VueRouter实例化对象</code></pre><h3 id="手动路由"><a href="#手动路由" class="headerlink" title="手动路由"></a>手动路由</h3><pre><code>this.$router.push(&apos;/&apos;)this.$router.push({name:&quot;home&quot;})</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>redirect: {name: &apos;xxx&apos;, params: {key: value}}</code></pre><h3 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h3><pre><code>router.beforeEach(function(to, from next){    // to 你要去哪    // from 你要从哪里来    // next() 你要去做什么 参数可以给路径  必须有，没有就不走})router.afterEach(function(to, from){    // to 你要去哪    // from 你从哪里来})to和from都是$route对象   路由的所有信息</code></pre><p></p><h2 id="node-js-npm-webpack-vue-cli-自带webpack"><a href="#node-js-npm-webpack-vue-cli-自带webpack" class="headerlink" title="node.js + npm + webpack + vue-cli(自带webpack)"></a>node.js + npm + webpack + vue-cli(自带webpack)</h2><pre><code>node.js / npm    - npm 管理工作目录        npm init -y    - 下载包        npm i xxx@0.0.0    - 卸载        npm uninstall xxx    - 更新        npm updata xxxwebpack    - 下载        npm i webpack webpack-cli    - 打包默认的入口文件        src目录下的index.js    - 出口文件        dist目录的main.jswue-cli  2    - 帮助我们快速搭建项目的脚手架工具    - 下载        npm i vue-cli    - 用vue-cli帮助我们创建项目        vue init webpack xxxx    - 启动项目        cd xxxx        npm run dev</code></pre><h2 id="Vuex和axios"><a href="#Vuex和axios" class="headerlink" title="Vuex和axios"></a>Vuex和axios</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;h1&gt;vue总结&lt;/h1&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
</feed>
