<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海燕</title>
  
  <subtitle>热爱编程，爱算法，爱生活，爱钻研</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-10T09:35:04.446Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>海燕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx_uWSGI_django_virtualenv_supervisor发布web服务器</title>
    <link href="http://yoursite.com/2018/12/10/nginx-uWSGI-django-virtualenv-supervisor%E5%8F%91%E5%B8%83web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/10/nginx-uWSGI-django-virtualenv-supervisor发布web服务器/</id>
    <published>2018-12-10T07:59:29.000Z</published>
    <updated>2018-12-10T09:35:04.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">WSGI是Web服务器网关接口。它是一个规范，描述了Web服务器如何与Web应用程序通信，以及Web应用程序如何链接在一起以处理一个请求，（接收请求，处理请求，响应请求）</span><br><span class="line">基于wsgi运行的框架有bottle,DJango,Flask,用于解析动态HTTP请求</span><br><span class="line">支持WSGI的服务器</span><br><span class="line">    wsgiref</span><br><span class="line">        python自带的web服务器</span><br><span class="line">    Gunicorn</span><br><span class="line">        用于linux的 python wsgi Http服务器，常用于各种django，flask结合部署服务器。</span><br><span class="line">    mode_wsgi</span><br><span class="line">        实现了Apache与wsgi应用程序的结合</span><br><span class="line">    uWSGI</span><br><span class="line">        C语言开发，快速，自我修复，开发人员友好的WSGI服务器，用于Python Web应用程序的专业部署和开发。</span><br><span class="line"></span><br><span class="line">在部署python程序web应用程序时，可以根据性能的需求，选择合适的wsgi server，不同的wsgi server区别在于并发支持上，有单线程，多进程，多线程，协程的区别，其功能还是近似，无非是请求路由，执行对应的函数，返回处理结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Django部署</span><br><span class="line"></span><br><span class="line">Django的主要部署平台是 WSGI，这是用于Web服务器和应用程序的Python标准。</span><br><span class="line"></span><br><span class="line">Django的 startproject管理命令设置一个简单的默认WSGI配置，可以根据需要为您的项目进行调整，并指示任何符合WSGI的应用程序服务器使用。</span><br><span class="line"></span><br><span class="line">application </span><br><span class="line">使用WSGI部署的关键概念是应用程序服务器用于与代码通信的 application 可调用。它通常在服务器可访问的Python模块中作为名为 application 的对象提供。</span><br><span class="line"></span><br><span class="line">startproject 命令创建包含这样的 application 可调用的文件 &lt;project_name&gt;/wsgi.py. ，它被Django的开发服务器和生产WSGI部署使用。</span><br><span class="line">WSGI服务器从其配置中获取 application 可调用的路径。 Django的内置服务器，即 runserver 命令，从 WSGI_APPLICATION 设置读取它。</span><br></pre></td></tr></table></figure><h2 id="为什么用nginx和uwsgi"><a href="#为什么用nginx和uwsgi" class="headerlink" title="为什么用nginx和uwsgi"></a>为什么用nginx和uwsgi</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、首先nginx 是对外的服务接口，外部浏览器通过url访问nginx,</span><br><span class="line"></span><br><span class="line">2、nginx 接收到浏览器发送过来的http请求，将包进行解析，分析url，如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件，</span><br><span class="line"></span><br><span class="line">如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi,uwsgi 接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi,wsgi 根</span><br><span class="line">据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给wsgi,wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接收wsgi 发</span><br><span class="line">送的请求，并转发给nginx,nginx最终将返回值返回给浏览器。</span><br><span class="line"></span><br><span class="line">1、要知道第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是要考虑到某些情况</span><br><span class="line">安全问题，程序不能直接被浏览器访问到，而是通过nginx,nginx只开放某个接口，uwsgi本身是内网接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。</span><br><span class="line"></span><br><span class="line">2、负载均衡问题，一个uwsgi很可能不够用，即使开了多个work也是不行，毕竟一台机器的cpu和内存都是有限的，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。</span><br><span class="line"></span><br><span class="line">3、静态文件问题，用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件</span><br><span class="line">的访问完全不去经过uwsgi以及其后面的东西。</span><br><span class="line"></span><br><span class="line">为什么要用nginx,uwsgi</span><br></pre></td></tr></table></figure><h2 id="nginx有关"><a href="#nginx有关" class="headerlink" title="nginx有关"></a>nginx有关</h2><p>nginx官网</p><pre><code>http://nginx.org/en/</code></pre><p>nginx有关uwsgi模块介绍</p><pre><code>http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html</code></pre><p>nginx、WSGI、uwsgi、uWSGI、django这几个关系</p><p>wsgi     全称web server gateway interface，wsgi不是服务器，也不是python模块，只是一种协议，<br>         描述web server如何和web application通信的规则。运行在wsgi上的web框架有bottle，flask，django<br>uwsgi    和wsgi一样是通信协议，是uWSGI服务器的单独协议，用于定义传输信息的类型<br>uWSGI    是一个web服务器，实现了WSGI协议，uwsgi协议。a<br>nginx    web服务器，更加安全，更好的处理处理静态资源，缓存功能，负载均衡，因此nginx的强劲性能，配合uWSGI服务器会更加安全，性能有保障。<br>django   高级的python web框架，用于快速开发，解决web开发的大部分麻烦，程序员可以更专注业务逻辑，无须重新造轮子</p><h1 id="Django-Nginx-uwsgi安装配置"><a href="#Django-Nginx-uwsgi安装配置" class="headerlink" title="Django Nginx+uwsgi安装配置"></a>Django Nginx+uwsgi安装配置</h1><pre><code>以前我们使用 python manage.py runserver 来运行服务器。这只适用测试环境中使用。正式发布的服务，需要一个可以稳定而持续的服务器。</code></pre><h2 id="基础开发环境配置"><a href="#基础开发环境配置" class="headerlink" title="基础开发环境配置"></a>基础开发环境配置</h2><pre><code>yum groupinstall &quot;Development tools&quot;yum install zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</code></pre><h2 id="提前安装好"><a href="#提前安装好" class="headerlink" title="提前安装好"></a>提前安装好</h2><pre><code>python3环境virtualenvdjango1.11.11</code></pre><h3 id="安装django1-11"><a href="#安装django1-11" class="headerlink" title="安装django1.11"></a>安装django1.11</h3><pre><code>pip3 install django==1.11</code></pre><h4 id="创建django项目mysite"><a href="#创建django项目mysite" class="headerlink" title="创建django项目mysite"></a>创建django项目mysite</h4><pre><code>django-admin startproject mysite</code></pre><h4 id="创建app01"><a href="#创建app01" class="headerlink" title="创建app01"></a>创建app01</h4><pre><code>python3 manage.py startapp app01mysite/settings.py</code></pre><h4 id="settings-py设置"><a href="#settings-py设置" class="headerlink" title="settings.py设置"></a>settings.py设置</h4><pre><code>ALLOWED_HOSTS = [&apos;*&apos;]install app01mysite/urls.pyfrom app01 import viewsurlpatterns = [    url(r&apos;^admin/&apos;, admin.site.urls),    url(r&apos;^hello_django/&apos;, views.hello),]</code></pre><h4 id="app01-views-py"><a href="#app01-views-py" class="headerlink" title="app01/views.py"></a>app01/views.py</h4><pre><code>from django.shortcuts import render,HttpResponse# Create your views here.def hello(request):    print(&apos;request is :&apos;,request)    return HttpResponse(&apos;django is ok &apos;)</code></pre><h2 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装uWSGI</h2><pre><code>进入虚拟环境venv，安装uwsgi(venv) [root@slave 192.168.11.64 /opt]$pip3 install uwsgi检查uwsgi版本(venv) [root@slave 192.168.11.64 /opt]$uwsgi --version2.0.17.1</code></pre><h3 id="检查uwsgi-python版本"><a href="#检查uwsgi-python版本" class="headerlink" title="检查uwsgi python版本"></a>检查uwsgi python版本</h3><pre><code>uwsgi --python-version</code></pre><p>运行简单的uWSGI</p><p>启动一个python</p><pre><code>uwsgi --http :8000 --wsgi-file test.pyhttp :8000: 使用http协议，端口8000wsgi-file test.py: 加载指定的文件，test.py#test.pydef application(env, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)])    return [b&quot;Hello World&quot;] # python3</code></pre><h3 id="uWsgi热加载python程序"><a href="#uWsgi热加载python程序" class="headerlink" title="uWsgi热加载python程序"></a>uWsgi热加载python程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在启动命令后面加上参数</span><br><span class="line">uwsgi --http :8088 --module mysite.wsgi --py-autoreload=1 </span><br><span class="line">#发布命令</span><br><span class="line">command= /home/venv/bin/uwsgi --uwsgi 0.0.0.0:8000 --chdir /opt/mysite --home=/home/venv --module mysite.wsgi</span><br><span class="line">#此时修改django代码，uWSGI会自动加载django程序，页面生效</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行django程序</p><pre><code>#mysite/wsgi.py  确保找到这个文件uwsgi --http :8000 --module mysite.wsgimodule mysite.wsgi: 加载指定的wsgi模块</code></pre><p>uwsgi配置文件</p><pre><code>uwsgi支持ini、xml等多种配置方式，本文以 ini 为例， 在/etc/目录下新建uwsgi_nginx.ini，添加如下配置：# mysite_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir           = /opt/mysite# Django&apos;s wsgi filemodule          = mysite.wsgi# the virtualenv (full path)home            = /opt/venv# process-related settings# mastermaster          = true# maximum number of worker processesprocesses       = 1# the socket (use the full path to be safesocket          = 0.0.0.0:8000# ... with appropriate permissions - may be needed# chmod-socket    = 664# clear environment on exitvacuum          = true</code></pre><h2 id="指定配置文件启动命令"><a href="#指定配置文件启动命令" class="headerlink" title="指定配置文件启动命令"></a>指定配置文件启动命令</h2><pre><code>uwsgi --ini  /etc/uwsgi_nginx.ini</code></pre><h2 id="配置nginx结合uWSGI"><a href="#配置nginx结合uWSGI" class="headerlink" title="配置nginx结合uWSGI"></a>配置nginx结合uWSGI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">　　#nginx反向代理uwsgi</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.11.64;</span><br><span class="line">        location / &#123;</span><br><span class="line">　　　　  #nginx自带ngx_http_uwsgi_module模块，起到nginx和uwsgi交互作用</span><br><span class="line">         #通过uwsgi_pass设置服务器地址和协议，讲动态请求转发给uwsgi处理</span><br><span class="line">         include  /opt/nginx1-12/conf/uwsgi_params;</span><br><span class="line">         uwsgi_pass 0.0.0.0:8000;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　  #nginx处理静态页面资源</span><br><span class="line">　　　　  location /static&#123;</span><br><span class="line">　　　　　　　　alias /opt/nginx1-12/static;　　　</span><br><span class="line">         &#125;</span><br><span class="line">　　　　　#nginx处理媒体资源</span><br><span class="line">　　　　　location /media&#123;</span><br><span class="line">　　　　　　　　alias /opt/nginx1-12/media;　　</span><br><span class="line">         &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    access_log  logs/access.log  main;    sendfile        on;    keepalive_timeout  65;    upstream crm_django {        server 192.168.12.77:8000;    }    # 虚拟主机一    server {        listen       80;        server_name  www.xx.com;        location / {            uwsgi_pass  crm_django;            include /opt/nginx1-12/conf/uwsgi_params;        }        location /static {            alias /opt/static/;        }    }</code></pre><h1 id="以上配置完启动nginx"><a href="#以上配置完启动nginx" class="headerlink" title="以上配置完启动nginx"></a>以上配置完启动nginx</h1><h1 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h1><p>supervisor 是基于 python 的任务管理工具，用来自动运行各种后台任务，当然你也能直接利用 nohup 命令使任务自动后台运行，<br>但如果要重启任务，每次都自己手动 kill 掉任务进程，这样很繁琐，而且一旦程序错误导致进程退出的话，系统也无法自动重载任务。</p><p>这里要配置基于virtualenv的supervisor</p><p>由于supervisor在python3下无法使用，因此只能用python2去下载！！！！！！</p><pre><code>#注意此时已经退出虚拟环境了！！！！！yum install python-setuptoolseasy_install supervisor通过命令生成supervisor的配支文件echo_supervisord_conf &gt; /etc/supervisord.conf然后再/etc/supervisord.conf末尾添加上如下代码！！！！！！</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">supervisord.conf配置文件参数解释</span><br><span class="line">[program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[program:my]</span><br><span class="line">#command=/opt/venv/bin/uwsgi --ini  /etc/uwsgi_nginx.ini  #这里是结合virtualenv的命令 和supervisor的精髓！！！！</span><br><span class="line">command= /home/venv/bin/uwsgi --uwsgi 0.0.0.0:8000 --chdir /opt/mysite --home=/home/venv --module mysite.wsgi</span><br><span class="line">#--home指的是虚拟环境目录  --module找到 mysite/wsgi.py</span><br></pre></td></tr></table></figure><p>最后启动supervisor，完成uWSGI启动django，nginx反向代理</p><p>supervisord -c /etc/supervisord.conf #启动supervisor<br>supervisorctl -c /etxc/supervisord.conf restart my  #重启my项目<br>supervisorctl -c /etc/supervisord.conf [start|stop|restart] [program-name|all]</p><p>重新加载supervisor</p><pre><code>一、添加好配置文件后二、更新新的配置到supervisord    supervisorctl update三、重新启动配置中的所有程序supervisorctl reload四、启动某个进程(program_name=你配置中写的程序名称)supervisorctl start program_name五、查看正在守候的进程supervisorctl六、停止某一进程 (program_name=你配置中写的程序名称)pervisorctl stop program_name七、重启某一进程 (program_name=你配置中写的程序名称)supervisorctl restart program_name八、停止全部进程supervisorctl stop all注意：显示用stop停止掉的进程，用reload或者update都不会自动重启。</code></pre><h1 id="django的静态文件与nginx配置-重点"><a href="#django的静态文件与nginx配置-重点" class="headerlink" title="django的静态文件与nginx配置  重点"></a>django的静态文件与nginx配置  重点</h1><pre><code>django的静态文件与nginx配置mysite/settings.pySTATIC_ROOT=&apos;/opt/nginx1-12/static&apos;STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS=[    os.path.join(BASE_DIR,&quot;static&quot;),]上述的参数STATIC_ROOT用在哪？通过python3 manage.py collectstatic 收集所有你使用的静态文件保存到STATIC_ROOT！STATIC_ROOT 文件夹 是用来将所有STATICFILES_DIRS中所有文件夹中的文件，以及各app中static中的文件都复制过来# 把这些文件放到一起是为了用nginx等部署的时候更方便</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="linux基本管理命令"><a href="#linux基本管理命令" class="headerlink" title="linux基本管理命令"></a>linux基本管理命令</h2><pre><code>服务器上安装服务,python3.6(宿主机上的物理解释器)1.虚拟解释器virtualenv虚拟出多个干净、隔离的python解释器环境问题：管理上较为麻烦，需要找到venv的路径，并且source activate 才能激活虚拟环境2.virtualenvwrapper工具更为方便的使用以及管理virtualenv1.配置好环境变量之后，每次开机就加载这个软件2.workon 激活并且切换多个虚拟环境mkvirtualenv  创建lsvirtualenvcdvirtualenvrmvirtualenv</code></pre><h2 id="mariadb"><a href="#mariadb" class="headerlink" title="mariadb"></a>mariadb</h2><pre><code>mariadb(mysql)，与django连接，存储数据(yum install mariadb-server mariadb-client)初始化连接数据库    __init.py__    import pymysql     pymysql.install()本地django连接linux上的数据库注意事项：1.防火墙问题，需配置规则，或者关闭防火墙    使用云服务器的同学，需要注意开通3306端口（安全组功能）2.远程连接mysql，需要授权，远程连接grant all privileges .....</code></pre><h2 id="edis"><a href="#edis" class="headerlink" title="edis"></a>edis</h2><pre><code>import redis </code></pre><h2 id="准备django项目"><a href="#准备django项目" class="headerlink" title="准备django项目"></a>准备django项目</h2><pre><code>准备django项目 &gt;  crm 在服务器上运行crm</code></pre><p>1.把本地代码，传至linux<br>        -scp(linux与linux网络传输)<br>        -xshell(yum install  lrzsz)  (windows)<br>                    lrzsz  可以通过如下俩命令管理文件，也可以直接拖拽文件<br>                    rz   接收<br>                    sz   发送<br>            lrzsz只适用于小文件，大文件，请用xftp<br>        -xftp (更为高效的企业级文件传输协议软件)</p><p>2.django项目需要配置allow_hosts=[‘*’]，允许所有主机访问<br>        debug=True  #返回给项目一个debug信息，暴露了项目配置信息，因此在线上要关闭</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>1.web服务器，用户的统一入口，<br>    我们的想法是，让用户通过nginx这个入口，就能访问到我们的应用服务器的功能<br>    <a href="http://www.pythonav.cn" target="_blank" rel="noopener">www.pythonav.cn</a>     入口   &lt;   80端口<br>    端口转发，反向代理<br>    80端口的请求  &gt;   8000的端口应用</p><pre><code>server{}虚拟主机</code></pre><p>2.反向代理服务器</p><pre><code>proxy_pass  后端应用服务器的ip:port   (转发给一个单点机器)proxy_pass  upstream负载均衡池</code></pre><p>3.负载均衡服务器</p><pre><code>nginx接收到了基于wsgi协议的动态请求，然后通过uwsgi_pass转发给uwsgi服务器uwsgi_pass  mydjango;upstream mydjango {    server 192.168.12.1:8000 weight=1;    server 192.168.12.2:8000 weight=5;    server 192.168.12.3:8000 weight=10;}</code></pre><p>4.处理静态文件，者是nginx的天然优势，处理静态文件的高并发性性能</p><pre><code>www.python.com/static/xxx.js    文件存放目录/data/static/xxx.jswww.python.com/static/xxx.css    文件存放目录/data/static/xxx.css www.python.com/static/xxx.jpg    文件存放目录/data/static/xxx.jpglocation /static  {    alias /data/static;}uwsgi     uwsgi服务器：    通过uwsgi这个软件启动crm项目，且是一个支持高并发，多进程的一个应用服务器    uwsgi --module  crm     python3 manage.py runserver 0.0.0.0:8000  ××  不再用这种单机形式启动crm    django-admin startproject   crm    django-admin startapp      app01        crm             -crm                -wsgi.py   (重点级的文件，django启动，实现wsgi协议的文件)            -manage.py</code></pre><h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><pre><code>uwsgi  启动crm的时候，非常有可能报错一个 no application(找不到应用)uwsgi找不到你的crm的wsgi.py    其实uwsgi是通过这个application对象加载crm的    application = get_wsgi_application()</code></pre><h2 id="进程管理工具："><a href="#进程管理工具：" class="headerlink" title="进程管理工具："></a>进程管理工具：</h2><pre><code>启动进程后，通过命令 手动管理 ps -ef |grep uwsgi #启停uwsgi kill -9 pid pkill uwsgi killall uwsgi #管理nginx ps -ef kill #管理mysqlps -ef kill #进程管理工具 supervisor 服务启动后supervisorctl ，可以通过这个命令，非常方便的管理进程，也可以统一启动，停止所有的进程    批量管理进程    mysql : running/stop     nginx :     running/stop    uwsgi:running/stop</code></pre><h1 id="项目发布配置手册："><a href="#项目发布配置手册：" class="headerlink" title="项目发布配置手册："></a>项目发布配置手册：</h1><p> (更换不同的服务器环境，首先就要解决环境依赖的问题)</p><pre><code>1.pip3 frezz &gt; requirements.py 2. pip3 install -r requirements.py 3.docker </code></pre><p> 1.准备python环境，准备虚拟环境，激活了虚拟环境<br>    mkvirtualenv nbcrm<br>        检测是否虚拟环境正常<br>        which pip3<br>        which python3 </p><p>2.安装django模块（此时的操作都是在nbcrm这个虚拟环境下了）<br>    pip3 install django==1.11.11</p><p>3.安装pymysql连接mysql数据库<br>    pip3 install pymysql</p><p>4.安装django的一个django-multiselectfield</p><pre><code>pip3 install django-multiselectfield</code></pre><p>5.解决项目的数据库连接问题，修改settings.py<br>    1.启动linux的数据库，创建对应的数据库，密码设置等等<br>    create database nb_crm;<br>    2.更改settings.py<br>    DATABASES = {<br>            ‘default’: {<br>                ‘ENGINE’: ‘django.db.backends.mysql’,<br>                ‘NAME’: ‘nb_crm’, #数据库名<br>                ‘HOST’: ‘127.0.0.1’,  #这里服务器的ip地址<br>                ‘PORT’: 3306,    #端口<br>                ‘USER’: ‘root’,    #用户名<br>                ‘PASSWORD’: ‘redhat123’,   #用户密码<br>            }<br>        }<br>    3.更改允许主机<br>    ALLOWED_HOSTS = [‘*’]</p><pre><code>4.线上关闭debug(肖锋的这个nb_crm先别改debug了)，默认先用Truedebug=True </code></pre><h2 id="使用uwsgi启动django"><a href="#使用uwsgi启动django" class="headerlink" title="使用uwsgi启动django"></a>使用uwsgi启动django</h2><p>1.安装uwsgi</p><pre><code>pip3 install -i https://pypi.douban.com/simple uwsgi</code></pre><p>2.通过uwsgi命令启动python应用</p><pre><code>uwsgi --http   0.0.0.0:8888  --wsgi-file test1.py      --http  指明是http协议    --socket 启动一个socket 链接    --wsgi-file  指明一个python应用文件</code></pre><p>3.通过uwsgi启动django项目(问题是，uwsgi不处理static静态文件的配置)<br>    uwsgi –http :8888  –module Nb_crm.wsgi    </p><p>4.uwsgi可以热加载项目</p><pre><code>uwsgi --http :9999  --module mycrm.wsgi --py-autoreload=1 --py-autoreload是告诉uwsgi自动重启加载django项目</code></pre><p>5.通过uwsgi的配置文件启动项目</p><pre><code>1.手动创建uwsgi.ini文件touch uwsgi.ini2.写入如下配置[uwsgi]    #项目的绝对路径，定位到项目的第一层    chdir           = /opt/NB_crm    #指明项目的wsgi文件路径    module          = NB_crm.wsgi    #指明你的虚拟解释器的第一层路径    home            = /root/Envs/nbcrm    #指明通过uwsgi，启动多少个进程    processes       = 5    #非常重要    #非常重要    #非常重要    #如果你已经配置了nginx(启动了nginx服务，配置了uwsgi_pass)，请用这个socket连接    #socket          = 0.0.0.0:8000    #如果你没用nginx，想通过uwsgi直接启动web服务，指明http协议    http = 0.0.0.0:9999    #在退出uwsgi环境后，清空环境变量    vacuum          = true</code></pre><p>6.通过配置文件启动NB_crm（注意uwsgi不会处理静态文件，如果有，也是浏览器的缓存！！！！）<br>    uwsgi –ini  uwsgi.ini </p><p>7.配置django的settings.py，收集所有NB_crm项目所需的静态文件<br>    1.#通过命令，收集整个项目所有的静态文件，放入到/opt/static/<br>        STATIC_ROOT=’/opt/static/‘<br>    2.执行命令<br>        python3 manage.py collectstatic<br>    3.此时NB_crm的所有静态文件，都跑到/opt/static/底下了<br>        (nbcrm) [root@node1 /opt/NB_crm 11:09:33]#ls /opt/static/<br>        admin  css  imgs  js  plugins</p><p>8.配置nginx<br>    1.配置一个网站入口，当用户访问192.168.12.96:80 这个web应用时，自动将请求转发给uwsgi，uwsgi处理后，返回给nginx，返回给用户<br>    当请求是192.168.12.96:80的时候，其实访问的是192.168.12.96:9999  这是动态请求，因为我是找到的uwsgi</p><pre><code>#匹配度最低的写法，因此就是任何的请求都访问到这里2.通过nginx去处理静态文件 3.nginx.conf配置如下#定义负载均衡池，里面放入uwsgi的地址upstream nbcrm {    server 127.0.0.1:8000;</code></pre><p>}</p><pre><code>server {   listen 80;   server_name  www.xx.com;   #讲nginx入口的请求，直接反向代理给uwsgi   location / {     uwsgi_pass  nbcrm;     include /opt/nginx1-12/conf/uwsgi_params;</code></pre><p>}</p><pre><code>#通过nginx处理nbcrm的静态文件location /static {    alias /opt/static/;    }}</code></pre><p>9.更改uwsgi.ini ，指明socket连接，结合uwsgi 和nginx</p><pre><code>#如果你已经配置了nginx，请用这个socket连接socket          = 0.0.0.0:8000</code></pre><p>10.启动uwsgi.ini<br>    uwsgi –ini uwsgi.ini </p><pre><code>启动nginx./nginx 并且访问nginx的域名入口，查看是否能访问到uwsgi项目，并且静态文件是否正常www.xx.com   查看浏览器状态</code></pre><p>11.配置supversior，管理uwsgi进程</p><pre><code>注意，请退出虚拟环境，在宿主机环境下，安装supvervisor</code></pre><p>1.安装easy_install ，python2的软件包管理工具 ，如果有了可以忽略<br>    yum install python-setuptools</p><pre><code>#安装软件easy_install supervisor</code></pre><p>2.使用supervisor命令,常用命令如下<br>    生成配置文件<br>    echo_supervisord_conf &gt;  /etc/supervisord.conf</p><p>3.修改配置文件，添加任务，按照自己的机器环境修改此命令<br>    [program:crm_project]</p><pre><code>#启动uwsgi的命令就是这个command=/root/Envs/nbcrm/bin/uwsgi  --ini /opt/NB_crm/uwsgi.ini#自动启动uwsgi，挂了之后自动加载autorestart=true</code></pre><p>4.启动supvervisord服务，启动uwsgi    </p><pre><code>#服务端命令，用于启动这个服务supervisord -c  /etc/supervisord.conf</code></pre><p>5.通过命令管理uwsgi<br>    supervisorctl 直接回车，进入交互式管理状态</p><pre><code>[root@node1 ~ 11:53:32]#supervisorctl crm_project                         RUNNING   pid 2008, uptime 0:01:56</code></pre><p>也可以通过命令交互式的管理uwsgi</p><pre><code>#服务端启动后，通过命令管理软件supervisorctl  start crm_projectsupervisorctl  stop  crm_project supervisorctl status crm_project</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx入门与实践</title>
    <link href="http://yoursite.com/2018/12/06/nginx%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/12/06/nginx入门与实践/</id>
    <published>2018-12-06T13:16:31.000Z</published>
    <updated>2018-12-08T08:52:18.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><img src="/2018/12/06/nginx入门与实践/1.png"><pre><code>想必我们大多数人都是通过访问网站而开始接触互联网的吧。我们平时访问的网站服务 就是 Web 网络服务，一般是指允许用户通过浏览器访问到互联网中各种资源的服务。Web 网络服务是一种被动访问的服务程序，即只有接收到互联网中其他主机发出的 请求后才会响应，最终用于提供服务程序的 Web 服务器会通过 HTTP(超文本传输协议)或 HTTPS(安全超文本传输协议)把请求的内容传送给用户。目前能够提供 Web 网络服务的程序有 IIS、Nginx 和 Apache 等。其中，IIS(Internet Information Services，互联网信息服务)是 Windows 系统中默认的 Web 服务程序2004 年 10 月 4 日，为俄罗斯知名门户站点而开发的 Web 服务程序Nginx 横空出世。 Nginx 程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市 场，但 Nginx 最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、 网易、腾讯等门户站的青睐。</code></pre><h1 id="web服务器和web框架的关系"><a href="#web服务器和web框架的关系" class="headerlink" title="web服务器和web框架的关系"></a>web服务器和web框架的关系</h1><pre><code>web服务器（nginx）：接收HTTP请求（www.xiaoxuedi.top）并返回数据web框架（django，flask）：开发web应用程序，处理接收到的数据</code></pre><h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1><h2 id="nginx是什么"><a href="#nginx是什么" class="headerlink" title="nginx是什么"></a>nginx是什么</h2><pre><code>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。安装更为简单，方便，灵活。支持高并发，能支持几万并发连接资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M可以做http反向代理和负载均衡支持异步网络i/o事件模型epoll</code></pre><img src="/2018/12/06/nginx入门与实践/2.png"><pre><code>Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</code></pre><h2 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h2><pre><code>一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</code></pre><h2 id="安装，启动nginx"><a href="#安装，启动nginx" class="headerlink" title="安装，启动nginx"></a>安装，启动nginx</h2><pre><code>1.下载源码包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz2.解压缩源码tar -zxvf nginx-1.12.0.tar.gz3.配置，编译安装  开启nginx状态监测功能./configure --prefix=/opt/nginx1-12/ --with-http_ssl_module --with-http_stub_status_module make &amp;&amp; make install 4.启动nginx，进入sbin目录,找到nginx启动命令cd sbin./nginx #启动./nginx -s stop #关闭./nginx -s reload #重新加载</code></pre><h2 id="安装完成后检查服务"><a href="#安装完成后检查服务" class="headerlink" title="安装完成后检查服务"></a>安装完成后检查服务</h2><pre><code>netstat -tunlp |grep 80curl -I 127.0.0.1#如果访问不了，检查selinux，iptables</code></pre><h2 id="部署一个web站点"><a href="#部署一个web站点" class="headerlink" title="部署一个web站点"></a>部署一个web站点</h2><pre><code>nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到location /{            root   html;  #这里是默认的站点html文件夹，也就是 /opt/nginx1-12/html/文件夹下的内容            index  index.html index.htm; #站点首页文件名是index.html        }如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可[root@python /tmp 11:34:52]#ls /opt/nginx1-12/html/index.html  jssts.jpeg  lhy.mp4  man.jpg  wget-log因此只需要通过域名/资源，即可访问</code></pre><h2 id="Nginx的目录结构"><a href="#Nginx的目录结构" class="headerlink" title="Nginx的目录结构"></a>Nginx的目录结构</h2><pre><code>client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp</code></pre><ul><li>conf 存放nginx所有配置文件的目录,主要nginx.conf</li><li>html 存放nginx默认站点的目录，如index.html、error.html等</li><li>logs 存放nginx默认日志的目录，如error.log access.log</li><li>sbin 存放nginx主命令的目录,sbin/nginx</li></ul><h2 id="Nginx主配置文件解析"><a href="#Nginx主配置文件解析" class="headerlink" title="Nginx主配置文件解析"></a>Nginx主配置文件解析</h2><pre><code>Nginx主配置文件/etc/nginx/nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号{}来表示开始与结束。</code></pre><h2 id="nginx-conf详解"><a href="#nginx-conf详解" class="headerlink" title="nginx.conf详解"></a>nginx.conf详解</h2><pre><code>######Nginx配置文件nginx.conf中文详解######定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events{    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。    #补充说明：    #与apache相类，nginx针对不同的操作系统，有不同的事件模型    #A）标准事件模型    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll    #B）高效事件模型    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。    #Epoll：使用于Linux内核2.6版本及以后的系统。    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。    use epoll;    #单个进程最大连接数（最大连接数=连接数*进程数）    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。    worker_connections 65535;    #keepalive超时时间。    keepalive_timeout 60;    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。    #分页大小可以用命令getconf PAGESIZE 取得。    #[root@web001 ~]# getconf PAGESIZE    #4096    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。    client_header_buffer_size 4k;    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。    open_file_cache max=65535 inactive=60s;    #这个是指多长时间检查一次缓存的有效信息。    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.    open_file_cache_valid 80s;    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.    open_file_cache_min_uses 1;    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.    open_file_cache_errors on;}#设定http服务器，利用它的反向代理功能提供负载均衡支持http{    #文件扩展名与文件类型映射表    include mime.types;    #默认文件类型    default_type application/octet-stream;    #默认编码    #charset utf-8;    #服务器名字的hash表大小    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.    server_names_hash_bucket_size 128;    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。    client_header_buffer_size 32k;    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。    large_client_header_buffers 4 64k;    #设定通过nginx上传文件的大小    client_max_body_size 8m;    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。    sendfile on;    #开启目录列表访问，合适下载服务器，默认关闭。    autoindex on;    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用    tcp_nopush on;    tcp_nodelay on;    #长连接超时时间，单位是秒    keepalive_timeout 120;    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k;    #最小压缩文件大小    gzip_buffers 4 16k;    #压缩缓冲区    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2;    #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #开启限制IP连接数的时候需要使用    #limit_zone crawler $binary_remote_addr 10m;    #负载均衡配置    upstream jh.w3cschool.cn {        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;        #nginx的upstream目前支持4种方式的分配        #1、轮询（默认）        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。        #2、weight        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。        #例如：        #upstream bakend {        #    server 192.168.0.14 weight=10;        #    server 192.168.0.15 weight=10;        #}        #2、ip_hash        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。        #例如：        #upstream bakend {        #    ip_hash;        #    server 192.168.0.14:88;        #    server 192.168.0.15:80;        #}        #3、fair（第三方）        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。        #upstream backend {        #    server server1;        #    server server2;        #    fair;        #}        #4、url_hash（第三方）        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法        #upstream backend {        #    server squid1:3128;        #    server squid2:3128;        #    hash $request_uri;        #    hash_method crc32;        #}        #tips:        #upstream bakend        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;        #每个设备的状态设置为:        #1.down表示单前的server暂时不参与负载        #2.weight为weight越大，负载的权重就越大。        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误        #4.fail_timeout:max_fails次失败后，暂停的时间。        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡    }    #虚拟主机的配置    server    {        #监听端口        listen 80;        #域名可以有多个，用空格隔开        server_name www.w3cschool.cn w3cschool.cn;        index index.html index.htm index.php;        root /data/www/w3cschool;        #对******进行负载均衡        location ~ .*.(php|php5)?$        {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$        {            expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$        {            expires 1h;        }        #日志格式设定        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；        #$remote_user：用来记录客户端用户名称；        #$time_local： 用来记录访问时间与时区；        #$request： 用来记录请求的url与http协议；        #$status： 用来记录请求状态；成功是200，        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；        #$http_referer：用来记录从那个页面链接访问过来的；        #$http_user_agent：记录客户浏览器的相关信息；        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;        #定义本虚拟主机的访问日志        access_log  /usr/local/nginx/logs/host.access.log  main;        access_log  /usr/local/nginx/logs/host.access.404.log  log404;        #对 &quot;/&quot; 启用反向代理        location / {            proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置，可选。            proxy_set_header Host $host;            #允许客户端请求的最大单文件字节数            client_max_body_size 10m;            #缓冲区代理缓冲用户端请求的最大字节数，            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误            client_body_buffer_size 128k;            #表示使nginx阻止HTTP应答代码为400或者更高的应答。            proxy_intercept_errors on;            #后端服务器连接的超时时间_发起握手等候响应超时时间            #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_connect_timeout 90;            #后端服务器数据回传时间(代理发送超时)            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据            proxy_send_timeout 90;            #连接成功后，后端服务器响应时间(代理接收超时)            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）            proxy_read_timeout 90;            #设置代理服务器（nginx）保存用户头信息的缓冲区大小            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小            proxy_buffer_size 4k;            #proxy_buffers缓冲区，网页平均在32k以下的设置            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k            proxy_buffers 4 32k;            #高负荷下缓冲大小（proxy_buffers*2）            proxy_busy_buffers_size 64k;            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长            #设定缓存文件夹大小，大于这个值，将从upstream服务器传            proxy_temp_file_write_size 64k;        }        #设定查看Nginx状态的地址        location /NginxStatus {            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file confpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。        }        #本地动静分离反向代理配置        #所有jsp的页面均交由tomcat或resin处理        location ~ .(jsp|jspx|do)?$ {            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://127.0.0.1:8080;        }        #所有静态文件由nginx直接读取不经过tomcat或resin        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|        pdf|xls|mp3|wma)$        {            expires 15d;         }        location ~ .*.(js|css)?$        {            expires 1h;        }    }}######Nginx配置文件nginx.conf中文详解#####nginx.conf详解</code></pre><h3 id="CoreModule核心模块"><a href="#CoreModule核心模块" class="headerlink" title="CoreModule核心模块"></a>CoreModule核心模块</h3><pre><code>user www;                       #Nginx进程所使用的用户worker_processes 1;             #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log /log/nginx/error.log  #Nginx错误日志存放路径pid /var/run/nginx.pid          #Nginx服务运行后产生的pid进程号</code></pre><h3 id="events事件模块"><a href="#events事件模块" class="headerlink" title="events事件模块"></a>events事件模块</h3><pre><code>events {                worker_connections  //每个worker进程支持的最大连接数    use epool;          //事件驱动模型, epoll默认}</code></pre><h3 id="http内核模块"><a href="#http内核模块" class="headerlink" title="http内核模块"></a>http内核模块</h3><pre><code>//公共的配置定义在http{}http {  //http层开始...        //使用Server配置网站, 每个Server{}代表一个网站(简称虚拟主机)    &apos;server&apos; {        listen       80;        //监听端口, 默认80        server_name  localhost; //提供服务的域名或主机名        access_log host.access.log  //访问日志        //控制网站访问路径        &apos;location&apos; / {            root   /usr/share/nginx/html;   //存放网站代码路径            index  index.html index.htm;    //服务器返回的默认页面文件        }        //指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton        error_page   500 502 503 504  /50x.html;    }    ...    //第二个虚拟主机配置    &apos;server&apos; {    ...    }    include /etc/nginx/conf.d/*.conf;  //包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件}   //http层结束</code></pre><h2 id="Nginx虚拟主机"><a href="#Nginx虚拟主机" class="headerlink" title="Nginx虚拟主机"></a>Nginx虚拟主机</h2><img src="/2018/12/06/nginx入门与实践/3.png"><pre><code>如果每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。虚拟主机就是将一台服务器分割成多个“虚拟服务器”，每个站点使用各自的硬盘空间，由于省资源，省钱，众多网站都使用虚拟主机来部署网站。虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。</code></pre><h3 id="虚拟主机类型"><a href="#虚拟主机类型" class="headerlink" title="虚拟主机类型"></a>虚拟主机类型</h3><pre><code>基于域名的虚拟主机通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。基于端口的虚拟主机通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000基于IP的虚拟主机通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP</code></pre><h2 id="Nginx状态信息（status）配置"><a href="#Nginx状态信息（status）配置" class="headerlink" title="Nginx状态信息（status）配置"></a>Nginx状态信息（status）配置</h2><pre><code>Nginx状态信息（status）配置及信息详解nginx与php-fpm一样内建了一个状态页，对于想了解nginx的状态以及监控nginx非常有帮助。为了后续的zabbix监控，我们需要先了解一下nginx的状态页。Nginx状态信息（status）介绍    Nginx软件在编译时又一个with-http_stub_status_module模    块，这个模块功能是记录Nginx的基本访问状态信息，让使用者了解    Nginx的工作状态。要想使用状态模块，在编译时必须增加--with-http_stub_status_module参数。</code></pre><p>监测你的nginx是否安装了status模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master conf]# /opt/nginx/sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.12.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)</span><br><span class="line">configure arguments: --prefix=/opt/nginx/ --with-http_stub_status_module</span><br></pre></td></tr></table></figure><p>启动status状态功能，修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /status &#123;</span><br><span class="line">　　　　　　　　#开启nginx状态功能</span><br><span class="line">            stub_status on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平滑重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>访问status页面</p><pre><code>http://192.168.119.10/status通过ab压测命令检测-n requests #执行的请求数，即一共发起多少请求。-c concurrency #请求并发数。-k #启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。ab -kc 1000 -n 100000 http://192.168.119.10/</code></pre><h2 id="status页面解析"><a href="#status页面解析" class="headerlink" title="status页面解析"></a>status页面解析</h2><img src="/2018/12/06/nginx入门与实践/4.png"><h2 id="基于域名的多虚拟主机实战"><a href="#基于域名的多虚拟主机实战" class="headerlink" title="基于域名的多虚拟主机实战"></a>基于域名的多虚拟主机实战</h2><p>nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内<br>容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。</p><p>/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果</p><p>修改nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ 14:33:16]#egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pyyuc.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虚拟主机的部分就是server{}里的内容</p><h2 id="创建pyyuc-cn的站点目录和文件"><a href="#创建pyyuc-cn的站点目录和文件" class="headerlink" title="创建pyyuc.cn的站点目录和文件"></a>创建pyyuc.cn的站点目录和文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@python /opt/nginx1-12/html 14:36:08]#mkdir pyyuc</span><br><span class="line">[root@python /opt/nginx1-12/html 14:36:18]#echo &quot;&lt;meta charset=utf8&gt;我是pyyuc站点&quot; &gt; pyyuc/index.html</span><br><span class="line">[root@python /opt/nginx1-12/html 14:37:21]#cat pyyuc/index.html</span><br><span class="line">&lt;meta charset=utf8&gt;我是pyyuc站点</span><br></pre></td></tr></table></figure><p>上述作用创建了一个html/pyyuc站点目录，对应于虚拟主机配置文件里的root根目录的设置html/pyyuc</p><p>然后生成一个首页文件index.html，内容是“我是pyyuc站点”</p><h2 id="检查nginx语法重新加载nginx"><a href="#检查nginx语法重新加载nginx" class="headerlink" title="检查nginx语法重新加载nginx"></a>检查nginx语法重新加载nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@python /opt/nginx1-12/html 14:37:28]#../sbin/nginx -t</span><br><span class="line">nginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</span><br><span class="line"></span><br><span class="line">#平滑重启nginx</span><br><span class="line"></span><br><span class="line">[root@python /opt/nginx1-12/html 14:39:18]#../sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>检查nginx端口，进程，访问pyyuc虚拟站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@python /opt/nginx1-12/html 14:40:02]#netstat -tunlp|grep nginx</span><br><span class="line">[root@python /opt/nginx1-12/html 14:40:29]#ps -ef|grep nginx</span><br><span class="line"></span><br><span class="line">#我这里是有dns解析，没有的话则需要/etc/hosts解析</span><br><span class="line">#成功配置了pyyuc虚拟主机站点</span><br><span class="line">[root@oldboy_python /opt/nginx1-12/html 14:41:37]#curl www.pyyuc.cn</span><br><span class="line">&lt;meta charset=utf8&gt;我是pyyuc站点</span><br></pre></td></tr></table></figure><h2 id="配置多个域名的虚拟主机"><a href="#配置多个域名的虚拟主机" class="headerlink" title="配置多个域名的虚拟主机"></a>配置多个域名的虚拟主机</h2><p>其实就是新增一个server{}虚拟主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pyyuc.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pythonav;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建pythonav虚拟主机站点的目录和文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@python /opt/nginx1-12 14:47:21]#mkdir -p /opt/nginx1-12/html/pythonav</span><br><span class="line">[root@python /opt/nginx1-12 14:49:33]#echo &quot;&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内&quot;&gt; /opt/nginx1-12/html/pythonav/index.html</span><br><span class="line">[root@python /opt/nginx1-12 14:50:44]#./sbin/nginx -t</span><br><span class="line">nginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</span><br><span class="line">[root@python /opt/nginx1-12 14:51:32]#./sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="大功告成，基于域名的虚拟主机实战搞定"><a href="#大功告成，基于域名的虚拟主机实战搞定" class="headerlink" title="大功告成，基于域名的虚拟主机实战搞定"></a>大功告成，基于域名的虚拟主机实战搞定</h2><pre><code>[root@python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内[root@python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点</code></pre><h2 id="nginx访问日志（access-log）"><a href="#nginx访问日志（access-log）" class="headerlink" title="nginx访问日志（access_log）"></a>nginx访问日志（access_log）</h2><pre><code>日志功能对每个用户访问网站的日志信息记录到指定的日志文件里，开发运维人员可以分析用户的浏览器行为，此功能由ngx_http_log_module模块负责，官网地址是：http://nginx.org/en/docs/http/ngx_http_log_module.html</code></pre><p>控制日志的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log_format    记录日志的格式，可定义多种格式</span><br><span class="line">accsss_log    指定日志文件的路径以及格式</span><br><span class="line"></span><br><span class="line">　　log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">　　&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">　　&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br></pre></td></tr></table></figure><p>对应参数解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$remote_addr    记录客户端ip</span><br><span class="line">$remote_user    远程用户，没有就是 “-”</span><br><span class="line">$time_local 　　 对应[14/Aug/2018:18:46:52 +0800]</span><br><span class="line">$request　　　 　对应请求信息&quot;GET /favicon.ico HTTP/1.1&quot;</span><br><span class="line">$status　　　  　状态码</span><br><span class="line">$body_bytes_sent　　571字节 请求体的大小</span><br><span class="line">$http_referer　　对应“-”　　由于是直接输入浏览器就是 -</span><br><span class="line">$http_user_agent　　客户端身份信息</span><br><span class="line">$http_x_forwarded_for　　记录客户端的来源真实ip 97.64.34.118</span><br></pre></td></tr></table></figure><p>日志效果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">66.102.6.6 - - [14/Aug/2018:18:46:52 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;-&quot;</span><br><span class="line"></span><br><span class="line"> &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36 Google Favicon&quot; &quot;97.64.34.118&quot;</span><br></pre></td></tr></table></figure></p><p> nginx.conf默认配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">access_log  logs/access.log  main;</span><br></pre></td></tr></table></figure></p><p>日志格式配置定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_format是日志关键字参数，不能变</span><br><span class="line">main是日志格式指定的标签，记录日志时通过main标签选择指定的格式。</span><br></pre></td></tr></table></figure></p><h2 id="nginx限制网站来源IP访问"><a href="#nginx限制网站来源IP访问" class="headerlink" title="nginx限制网站来源IP访问"></a>nginx限制网站来源IP访问</h2><p>如果哪天发现你的nginx很慢，或者检查access.log时候，有一个some body疯狂请求你的nginx server，那么可以禁止这个IP访问</p><pre><code>限制ip或ip段访问禁止访问/av/底下的资源location /av {deny 122.71.240.254;#alias /opt/nginx1-12/html/av;allow 10.1.1.0/16;  }</code></pre><h2 id="Nginx错误页面优化"><a href="#Nginx错误页面优化" class="headerlink" title="Nginx错误页面优化"></a>Nginx错误页面优化</h2><p>在网站运行过程中，可能因为页面不存在等原因，导致网站无法正常响应请求，<br>此时web服务会返回系统的错误码，但是默认的错误页面很不友好。</p><img src="/2018/12/06/nginx入门与实践/5.png"><p>因此我们可以将404，403等页面的错误信息重定向到网站首页或者其他指定的页面，提升用户访问体验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        root html/pythonav;</span><br><span class="line">        location /&#123;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　　　#在pythonav路径下的40x.html错误页面</span><br><span class="line">        error_page 400 403 404 405 /40x.html;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>40x.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img style=&apos;width:100%;height:100%;&apos; src=https://pic1.zhimg.com/80/v2-77a9281a2bebc7a2ea5e02577af266a8_hd.png&gt;</span><br></pre></td></tr></table></figure></p><p>此时访问<a href="http://www.pythonav.cn/asdasd错误页面已经优化了" target="_blank" rel="noopener">www.pythonav.cn/asdasd错误页面已经优化了</a></p><img src="/2018/12/06/nginx入门与实践/6.png"><h2 id="nginx与location"><a href="#nginx与location" class="headerlink" title="nginx与location"></a>nginx与location</h2><p>location指令的作用是根据用户请求的URL来执行不同的应用。</p><p>location语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location    [ = | ~ | ~* | ^~ | @ ] url     &#123;&#125;</span><br><span class="line">指令　　　　　　匹配标识　　　　匹配网站路径　　匹配url后的配置</span><br><span class="line">= 开头表示精确匹配</span><br><span class="line">^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。</span><br><span class="line">~ 开头表示区分大小写的正则匹配</span><br><span class="line">~*  开头表示不区分大小写的正则匹配</span><br><span class="line">!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则</span><br><span class="line">/ 通用匹配，任何请求都会匹配到。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location匹配顺序</span><br><span class="line">1.location = /&#123;&#125; 精确匹配</span><br><span class="line">2.location ^~ /images/  匹配常规串，不做正则检查</span><br><span class="line">3.location ~* \.(gif|jpg|jpeg)  正则匹配</span><br><span class="line">4. location /av/   匹配常规字符，有正则优先正则</span><br><span class="line">5.location / &#123;&#125;  所有的location都不匹配后，默认匹配</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">　　　　location / &#123;</span><br><span class="line">return 401;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">　　　　 location =/ &#123;</span><br><span class="line">return 402;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /documents/ &#123;</span><br><span class="line">return 403;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ^~ /images/ &#123;</span><br><span class="line">return 404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">return 500;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx代理"><a href="#Nginx代理" class="headerlink" title="Nginx代理"></a>Nginx代理</h1><img src="/2018/12/06/nginx入门与实践/7.png"><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><pre><code>正向代理，也就是传说中的代理,他的工作原理就像一个跳板（VPN），简单的说：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。</code></pre><img src="/2018/12/06/nginx入门与实践/8.png"><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>对于客户端而言，代理服务器就像是原始服务器。</p><img src="/2018/12/06/nginx入门与实践/9.png"><h1 id="nginx实现负载均衡的组件"><a href="#nginx实现负载均衡的组件" class="headerlink" title="nginx实现负载均衡的组件"></a>nginx实现负载均衡的组件</h1><pre><code>ngx_http_proxy_module    proxy代理模块，用于把请求抛给服务器节点或者upstream服务器池</code></pre><h1 id="实现一个简单的反反向代理"><a href="#实现一个简单的反反向代理" class="headerlink" title="实现一个简单的反反向代理"></a>实现一个简单的反反向代理</h1><p>机器准备，两台服务器</p><pre><code>master  192.168.11.63　　主负载slave   192.168.11.64　　web1</code></pre><p>主负载均衡节点的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">        upstream slave_pools&#123;</span><br><span class="line">    server 192.168.11.64:80 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass  http://slave_pools;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查语法并启动nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx -t</span><br><span class="line">nginx: the configuration file /opt/nginx1-12/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/nginx1-12/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#启动nginx</span><br><span class="line">[root@master 192.168.11.63 /opt/nginx1-12]$/opt/nginx1-12/sbin/nginx</span><br><span class="line">#检查端口</span><br><span class="line">[root@master 192.168.11.63 /opt/nginx1-12]$netstat -tunlp|grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8921/nginx: master</span><br></pre></td></tr></table></figure><p>此时访问master的服务器192.168.11.63:80地址，已经会将请求转发给slave的80端口</p><p>除了页面效果的展示以外，还可以通过log(access.log)查看代理效果</p><p>master端日志</p><img src="/2018/12/06/nginx入门与实践/10.png"><p>slave端日志</p><img src="/2018/12/06/nginx入门与实践/11.png"><h1 id="Keepalived高可用软件"><a href="#Keepalived高可用软件" class="headerlink" title="Keepalived高可用软件"></a>Keepalived高可用软件</h1><p>什么是keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Keepalived是一个用C语言编写的路由软件。该项目的主要目标是为Linux系</span><br><span class="line">统和基于Linux的基础架构提供简单而强大的负载均衡和高可用性设施。 </span><br><span class="line">还可以作为其他服务（nginx，mysql）的高可用软件</span><br><span class="line"></span><br><span class="line">keepalived主要通过vrrp协议实现高可用功能。vrrp叫（virtual </span><br><span class="line">router redundancy protocol）虚拟路由器冗余协议，</span><br><span class="line">目的为了解决单点故障问题，他可以保证个别节点宕机时。整个网络可以不间断</span><br><span class="line">的运行。</span><br></pre></td></tr></table></figure><p>高可用故障切换原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在keepalived工作时，主master节点会不断的向备节点发送心跳消息，告诉备节点自己还活着，</span><br><span class="line">当master节点故障时，就无法发送心跳消息，备节点就无法检测到来自master的心跳了，于是调用自身的接管程序，接管master节点的ip资源以及服务，</span><br><span class="line">当master主节点恢复时，备backup节点又会释放接管的ip资源和服务，回复到原本的备节点角色。</span><br><span class="line">1.硬件环境准备</span><br><span class="line"></span><br><span class="line">实验环境应该最好是4台虚拟机，环境有限因此用2台机器</span><br><span class="line">master</span><br><span class="line">slave</span><br><span class="line">2.centos系统和nginx代理环境</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网站服务&quot;&gt;&lt;a href=&quot;#网站服务&quot; class=&quot;headerlink&quot; title=&quot;网站服务&quot;&gt;&lt;/a&gt;网站服务&lt;/h1&gt;&lt;img src=&quot;/2018/12/06/nginx入门与实践/1.png&quot;&gt;
&lt;pre&gt;&lt;code&gt;想必我们大多数人都是通过访
      
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Python3.x标准模块库目录</title>
    <link href="http://yoursite.com/2018/11/23/python%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2018/11/23/python资源/</id>
    <published>2018-11-23T07:28:16.000Z</published>
    <updated>2018-11-23T08:05:32.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-资源大全中文版"><a href="#Python-资源大全中文版" class="headerlink" title="Python 资源大全中文版"></a>Python 资源大全中文版</h1><h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li>基于 awesome-python 列表整理。此外还将从其他来源补充好资源。</li><li>可参考已整理的内容：<ul><li>《<a href="http://hao.jobbole.com/python-scrapy/" target="_blank" rel="noopener">Scrapy：Python 的爬虫框架</a>》</li><li>《<a href="http://hao.jobbole.com/flask/" target="_blank" rel="noopener">Flask：一个使用 Python 编写的轻量级 Web 应用框架</a>》</li></ul></li></ul><h2 id="资源列表"><a href="#资源列表" class="headerlink" title="资源列表"></a>资源列表</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>管理 Python 版本和环境的工具</p><ul><li>p：非常简单的交互式 python 版本管理工具。<a href="https://github.com/qw3rtman/p" target="_blank" rel="noopener">官网</a></li><li>pyenv：简单的 Python 版本管理工具。<a href="https://github.com/yyuu/pyenv" target="_blank" rel="noopener">官网</a></li><li>Vex：可以在虚拟环境中执行命令。<a href="https://github.com/sashahart/vex" target="_blank" rel="noopener">官网</a></li><li>virtualenv：创建独立 Python 环境的工具。<a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="noopener">官网</a></li><li>virtualenvwrapper：virtualenv 的一组扩展。<a href="https://pypi.python.org/pypi/virtualenvwrapper" target="_blank" rel="noopener">官网</a></li></ul><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>管理包和依赖的工具。</p><ul><li>pip：Python 包和依赖关系管理工具。<a href="https://pip.pypa.io/" target="_blank" rel="noopener">官网</a></li><li>pip-tools：保证 Python 包依赖关系更新的一组工具。<a href="https://github.com/nvie/pip-tools" target="_blank" rel="noopener">官网</a></li><li>pipenv：Pyhton 官方推荐的新一代包管理工具。<a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">官网</a></li><li>conda：跨平台，Python 二进制包管理工具。<a href="https://github.com/conda/conda/" target="_blank" rel="noopener">官网</a></li><li>Curdling：管理 Python 包的命令行工具。<a href="http://clarete.li/curdling/" target="_blank" rel="noopener">官网</a></li><li>wheel：Python 分发的新标准，意在取代 eggs。<a href="http://pythonwheels.com/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="包仓库"><a href="#包仓库" class="headerlink" title="包仓库"></a>包仓库</h3><p>本地 PyPI 仓库服务和代理。</p><ul><li><a href="https://pypi.org/" target="_blank" rel="noopener">warehouse</a>：下一代 PyPI。<a href="https://github.com/pypa/warehouse" target="_blank" rel="noopener">官网</a></li><li>bandersnatch：PyPA 提供的 PyPI 镜像工具。<a href="https://bitbucket.org/pypa/bandersnatch" target="_blank" rel="noopener">官网</a></li><li>devpi：PyPI 服务和打包/测试/分发工具。<a href="http://doc.devpi.net/" target="_blank" rel="noopener">官网</a></li><li>localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。<a href="https://github.com/mvantellingen/localshop" target="_blank" rel="noopener">官网</a></li></ul><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><p>打包为可执行文件以便分发。</p><ul><li>PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。<a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="noopener">官网</a></li><li>dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。<a href="http://dh-virtualenv.readthedocs.org/" target="_blank" rel="noopener">官网</a></li><li>Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。<a href="http://nuitka.net/" target="_blank" rel="noopener">官网</a></li><li>py2app：将 Python 脚本变为独立软件包（Mac OS X）。<a href="http://pythonhosted.org/py2app/" target="_blank" rel="noopener">官网</a></li><li>py2exe：将 Python 脚本变为独立软件包（Windows）。<a href="http://www.py2exe.org/" target="_blank" rel="noopener">官网</a></li><li>pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python 本身。<a href="http://pynsist.readthedocs.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>将源码编译成软件。</p><ul><li>buildout：一个构建系统，从多个组件来创建，组装和部署应用。<a href="http://www.buildout.org/" target="_blank" rel="noopener">官网</a></li><li>BitBake：针对嵌入式 Linux 的类似 make 的构建工具。<a href="http://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html" target="_blank" rel="noopener">官网</a></li><li>fabricate：对任何语言自动找到依赖关系的构建工具。<a href="https://code.google.com/archive/p/fabricate" target="_blank" rel="noopener">官网</a></li><li>PlatformIO：多平台命令行构建工具。<a href="https://github.com/platformio/platformio" target="_blank" rel="noopener">官网</a></li><li>PyBuilder：纯 Python 实现的持续化构建工具。<a href="https://github.com/pybuilder/pybuilder" target="_blank" rel="noopener">官网</a></li><li>SCons：软件构建工具。<a href="http://www.scons.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="交互式解析器"><a href="#交互式解析器" class="headerlink" title="交互式解析器"></a>交互式解析器</h3><p>交互式 Python 解析器。</p><ul><li>IPython：功能丰富的工具，非常有效的使用交互式 Python。<a href="https://github.com/ipython/ipython" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/bpython/" target="_blank" rel="noopener">bpython</a>：界面丰富的 Python 解析器。<a href="http://bpython-interpreter.org/" target="_blank" rel="noopener">官网</a></li><li>ptpython：高级交互式 Python 解析器， 构建于 <a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="noopener">python-prompt-toolkit</a> 之上。<a href="https://github.com/jonathanslenders/ptpython" target="_blank" rel="noopener">官网</a></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。</p><ul><li>aiofiles：基于 asyncio，提供文件异步操作。<a href="https://github.com/Tinche/aiofiles" target="_blank" rel="noopener">官网</a></li><li>imghdr：（Python 标准库）检测图片类型。<a href="https://docs.python.org/2/library/imghdr.html" target="_blank" rel="noopener">官网</a></li><li>mimetypes：（Python 标准库）将文件名映射为 MIME 类型。<a href="https://docs.python.org/2/library/mimetypes.html" target="_blank" rel="noopener">官网</a></li><li>path.py：对 os.path 进行封装的模块。<a href="https://github.com/jaraco/path.py" target="_blank" rel="noopener">官网</a></li><li>pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。<a href="https://pathlib.readthedocs.org/en/pep428/" target="_blank" rel="noopener">官网</a></li><li>python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。<a href="https://github.com/ahupp/python-magic" target="_blank" rel="noopener">官网</a></li><li>Unipath：用面向对象的方式操作文件和目录。<a href="https://github.com/mikeorr/Unipath" target="_blank" rel="noopener">官网</a></li><li>watchdog：管理文件系统事件的 API 和 shell 工具。<a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="noopener">官网</a></li></ul><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>操作日期和时间的类库。</p><ul><li>arrow：更好的 Python 日期时间操作类库。<a href="https://github.com/crsmithdev/arrow" target="_blank" rel="noopener">官网</a></li><li>Chronyk：Python 3 的类库，用于解析手写格式的时间和日期。<a href="https://github.com/KoffeinFlummi/Chronyk" target="_blank" rel="noopener">官网</a></li><li>dateutil：Python datetime 模块的扩展。<a href="https://pypi.python.org/pypi/python-dateutil" target="_blank" rel="noopener">官网</a></li><li>delorean：解决 Python 中有关日期处理的棘手问题的库。<a href="https://github.com/myusuf3/delorean/" target="_blank" rel="noopener">官网</a></li><li>maya：人性化的时间处理库。<a href="https://github.com/kennethreitz/maya" target="_blank" rel="noopener">官网</a></li><li>moment：一个用来处理时间和日期的 Python 库。灵感来自于 Moment.js。<a href="https://github.com/zachwill/moment" target="_blank" rel="noopener">官网</a></li><li>pendulum：一个比 arrow 更具有明确的，可预测的行为的时间操作库。<a href="https://github.com/sdispater/pendulum" target="_blank" rel="noopener">官网</a></li><li>PyTime：一个简单易用的 Python 模块，用于通过字符串来操作日期/时间。<a href="https://github.com/shinux/PyTime" target="_blank" rel="noopener">官网</a></li><li>pytz：现代以及历史版本的世界时区定义。将时区数据库引入 Python。<a href="https://launchpad.net/pytz" target="_blank" rel="noopener">官网</a></li><li>when.py：提供用户友好的函数来帮助用户进行常用的日期和时间操作。<a href="https://github.com/dirn/When.py" target="_blank" rel="noopener">官网</a></li></ul><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>用于解析和操作文本的库。</p><ul><li>通用<ul><li><a href="http://hao.jobbole.com/chardet/" target="_blank" rel="noopener">chardet</a>：字符编码检测器，兼容 Python2 和 Python3。<a href="https://github.com/chardet/chardet" target="_blank" rel="noopener">官网</a></li><li>difflib：(Python 标准库)帮助我们进行差异化比较。<a href="https://docs.python.org/2/library/difflib.html" target="_blank" rel="noopener">官网</a></li><li>ftfy：让 Unicode 文本更完整更连贯。<a href="https://github.com/LuminosoInsight/python-ftfy" target="_blank" rel="noopener">官网</a></li><li>fuzzywuzzy：模糊字符串匹配。<a href="https://github.com/seatgeek/fuzzywuzzy" target="_blank" rel="noopener">官网</a></li><li>Levenshtein：快速计算编辑距离以及字符串的相似度。<a href="https://github.com/ztane/python-Levenshtein/" target="_blank" rel="noopener">官网</a></li><li>pangu.py：在中日韩语字符和数字字母之间添加空格。<a href="https://github.com/vinta/pangu.py" target="_blank" rel="noopener">官网</a></li><li>pypinyin：汉字拼音转换工具 Python 版。<a href="https://github.com/mozillazg/python-pinyin" target="_blank" rel="noopener">官网</a></li><li>shortuuid：一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。<a href="https://github.com/stochastic-technologies/shortuuid" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/simplejson/simplejson" target="_blank" rel="noopener">simplejson</a>：Python 的 JSON 编码、解码器。<a href="https://simplejson.readthedocs.io/en/latest/" target="_blank" rel="noopener">官网</a></li><li>unidecode：Unicode 文本的 ASCII 转换形式 。<a href="https://pypi.python.org/pypi/Unidecode" target="_blank" rel="noopener">官网</a></li><li>uniout：打印可读的字符，而不是转义的字符串。<a href="https://github.com/moskytw/uniout" target="_blank" rel="noopener">官网</a></li><li>xpinyin：一个用于把汉字转换为拼音的库。<a href="https://github.com/lxneng/xpinyin" target="_blank" rel="noopener">官网</a></li><li>yfiglet-figlet：<a href="https://github.com/pwaller/pyfiglet" target="_blank" rel="noopener">pyfiglet -figlet</a> 的 Python 实现。</li><li>flashtext: 一个高效的文本查找替换库。<a href="https://github.com/vi3k6i5/flashtext" target="_blank" rel="noopener">官网</a></li></ul></li><li>Slug 化<ul><li>awesome-slugify：一个 Python slug 化库，可以保持 Unicode。<a href="https://github.com/dimka665/awesome-slugify" target="_blank" rel="noopener">官网</a></li><li>python-slugify：Python slug 化库，可以把 unicode 转化为 ASCII。<a href="https://github.com/un33k/python-slugify" target="_blank" rel="noopener">官网</a></li><li>unicode-slugify：一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。<a href="https://github.com/mozilla/unicode-slugify" target="_blank" rel="noopener">官网</a></li></ul></li><li>解析器<ul><li>phonenumbers：解析，格式化，储存，验证电话号码。<a href="https://github.com/daviddrysdale/python-phonenumbers" target="_blank" rel="noopener">官网</a></li><li>PLY：lex 和 yacc 解析工具的 Python 实现。<a href="http://www.dabeaz.com/ply/" target="_blank" rel="noopener">官网</a></li><li>Pygments：通用语法高亮工具。<a href="http://pygments.org/" target="_blank" rel="noopener">官网</a></li><li>pyparsing：生成通用解析器的框架。<a href="http://pyparsing.wikispaces.com/" target="_blank" rel="noopener">官网</a></li><li>python-nameparser：把一个人名分解为几个独立的部分。<a href="https://github.com/derek73/python-nameparser" target="_blank" rel="noopener">官网</a></li><li>python-user-agents：浏览器 user agent 解析器。<a href="https://github.com/selwin/python-user-agents" target="_blank" rel="noopener">官网</a></li><li>sqlparse：一个无验证的 SQL 解析器。<a href="https://sqlparse.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="特殊文本格式处理"><a href="#特殊文本格式处理" class="headerlink" title="特殊文本格式处理"></a>特殊文本格式处理</h3><p>一些用来解析和操作特殊文本格式的库。</p><ul><li>通用<ul><li>tablib：一个用来处理中表格数据的模块。<a href="https://github.com/kennethreitz/tablib" target="_blank" rel="noopener">官网</a></li></ul></li><li>Office<ul><li>Marmir：把输入的 Python 数据结构转换为电子表单。<a href="https://github.com/brianray/mm" target="_blank" rel="noopener">官网</a></li><li>openpyxl：一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。<a href="https://openpyxl.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>pyexcel：一个提供统一 API，用来读写，操作 Excel 文件的库。<a href="https://github.com/pyexcel/pyexcel" target="_blank" rel="noopener">官网</a></li><li>python-docx：读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。<a href="https://github.com/python-openxml/python-docx" target="_blank" rel="noopener">官网</a></li><li>relatorio：模板化 OpenDocument 文件。<a href="http://relatorio.tryton.org/" target="_blank" rel="noopener">官网</a></li><li>unoconv：在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。<a href="https://github.com/dagwieers/unoconv" target="_blank" rel="noopener">官网</a></li><li>XlsxWriter：一个用于创建 Excel .xlsx 文件的 Python 模块。<a href="https://xlsxwriter.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>xlwings：一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。<a href="http://xlwings.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/xlwt/" target="_blank" rel="noopener">xlwt</a>：读写 Excel 文件的数据和格式信息。<a href="https://github.com/python-excel/xlwt" target="_blank" rel="noopener">官网</a> / <a href="https://github.com/python-excel/xlrd" target="_blank" rel="noopener">xlrd</a></li></ul></li><li>PDF<ul><li>PDFMiner：一个用于从 PDF 文档中抽取信息的工具。<a href="https://github.com/euske/pdfminer" target="_blank" rel="noopener">官网</a></li><li>PyPDF2：一个可以分割，合并和转换 PDF 页面的库。<a href="https://github.com/mstamy2/PyPDF2" target="_blank" rel="noopener">官网</a></li><li>ReportLab：快速创建富文本 PDF 文档。<a href="http://www.reportlab.com/opensource/" target="_blank" rel="noopener">官网</a></li></ul></li><li>Markdown<ul><li>Mistune：快速并且功能齐全的纯 Python 实现的 Markdown 解析器。<a href="https://github.com/lepture/mistune" target="_blank" rel="noopener">官网</a></li><li>Python-Markdown：John Gruber’s Markdown 的 Python 版实现。<a href="https://github.com/waylan/Python-Markdown" target="_blank" rel="noopener">官网</a></li><li>Python-Markdown2：纯 Python 实现的 Markdown 解析器，比 Python-Markdown 更快，更准确，可扩展。<a href="https://github.com/trentm/python-markdown2" target="_blank" rel="noopener">官网</a></li></ul></li><li>YAML<ul><li>PyYAML：Python 版本的 YAML 解析器。<a href="http://pyyaml.org/" target="_blank" rel="noopener">官网</a></li></ul></li><li>CSV<ul><li>csvkit：用于转换和操作 CSV 的工具。<a href="https://github.com/wireservice/csvkit" target="_blank" rel="noopener">官网</a></li></ul></li><li>Archive<ul><li>unp：一个用来方便解包归档文件的命令行工具。<a href="https://github.com/mitsuhiko/unp" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>用来处理人类语言的库。</p><ul><li><a href="http://hao.jobbole.com/nltk/" target="_blank" rel="noopener">NLTK</a>：一个先进的平台，用以构建处理人类语言数据的 Python 程序。<a href="http://www.nltk.org/" target="_blank" rel="noopener">官网</a></li><li>jieba：中文分词工具。<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">官网</a></li><li>langid.py：独立的语言识别系统。<a href="https://github.com/saffsd/langid.py" target="_blank" rel="noopener">官网</a></li><li>Pattern：Python 网络信息挖掘模块。<a href="http://www.clips.ua.ac.be/pattern" target="_blank" rel="noopener">官网</a></li><li>SnowNLP：一个用来处理中文文本的库。<a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">官网</a></li><li>TextBlob：为进行普通自然语言处理任务提供一致的 API。<a href="http://textblob.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>TextGrocery：一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。<a href="https://github.com/2shou/TextGrocery" target="_blank" rel="noopener">官网</a></li><li>thulac:清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包<a href="https://github.com/thunlp/THULAC-Python" target="_blank" rel="noopener">官网</a></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>用以生成项目文档的库。</p><ul><li><a href="http://hao.jobbole.com/sphinx/" target="_blank" rel="noopener">Sphinx</a>：Python 文档生成器。<a href="http://www.sphinx-doc.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>awesome-sphinxdoc：<a href="https://github.com/yoloseem/awesome-sphinxdoc" target="_blank" rel="noopener">官网</a></li><li>MkDocs：对 Markdown 友好的文档生成器。<a href="http://www.mkdocs.org/" target="_blank" rel="noopener">官网</a></li><li>pdoc：一个可以替换 Epydoc 的库，可以自动生成 Python 库的 API 文档。<a href="https://github.com/BurntSushi/pdoc" target="_blank" rel="noopener">官网</a></li><li>Pycco：文学编程（literate-programming）风格的文档生成器。<a href="https://github.com/pycco-docs/pycco" target="_blank" rel="noopener">官网</a></li><li>readthedocs：一个基于 Sphinx/MkDocs 的在线文档托管系统，对开源项目免费开放使用。<a href="https://github.com/rtfd/readthedocs.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用来保存和解析配置的库。</p><ul><li>config：<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">logging</a> 模块作者写的分级配置模块。<a href="https://www.red-dove.com/config-doc/" target="_blank" rel="noopener">官网</a></li><li>ConfigObj：INI 文件解析器，带验证功能。<a href="http://www.voidspace.org.uk/python/configobj.html" target="_blank" rel="noopener">官网</a></li><li>ConfigParser：(Python 标准库) INI 文件解析器。<a href="https://docs.python.org/2/library/configparser.html" target="_blank" rel="noopener">官网</a></li><li>profig：通过多种格式进行配置，具有数值转换功能。<a href="http://profig.readthedocs.org/en/default/" target="_blank" rel="noopener">官网</a></li><li>python-decouple：将设置和代码完全隔离。<a href="https://github.com/henriquebastos/python-decouple" target="_blank" rel="noopener">官网</a></li></ul><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>用于创建命令行程序的库。</p><ul><li>命令行程序开发<ul><li>asciimatics：跨平台，全屏终端包（即鼠标/键盘输入和彩色，定位文本输出），完整的复杂动画和特殊效果的高级 API。<a href="https://github.com/peterbrittain/asciimatics" target="_blank" rel="noopener">官网</a></li><li>cement：Python 的命令行程序框架。<a href="http://builtoncement.com/" target="_blank" rel="noopener">官网</a></li><li>click：一个通过组合的方式来创建精美命令行界面的包。<a href="http://click.pocoo.org/dev/" target="_blank" rel="noopener">官网</a></li><li>cliff：一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。<a href="http://docs.openstack.org/developer/cliff/" target="_blank" rel="noopener">官网</a></li><li>clint：Python 命令行程序工具。<a href="https://github.com/kennethreitz/clint" target="_blank" rel="noopener">官网</a></li><li>colorama：跨平台彩色终端文本。<a href="https://pypi.python.org/pypi/colorama" target="_blank" rel="noopener">官网</a></li><li>docopt：Python 风格的命令行参数解析器。<a href="http://docopt.org/" target="_blank" rel="noopener">官网</a></li><li>Gooey：一条命令，将命令行程序变成一个 GUI 程序。<a href="https://github.com/chriskiehl/Gooey" target="_blank" rel="noopener">官网</a></li><li>python-prompt-toolkit：一个用于构建强大的交互式命令行程序的库。<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="noopener">官网</a></li><li>python-fire：Google 出品的一个基于 Python 类的构建命令行界面的库。<a href="https://github.com/google/python-fire" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pythonpy/" target="_blank" rel="noopener">Pythonpy</a>：在命令行中直接执行任何 Python 指令。<a href="https://github.com/Russell91/pythonpy/wiki" target="_blank" rel="noopener">官网</a></li></ul></li><li>生产力工具<ul><li>aws-cli：Amazon Web Services 的通用命令行界面。<a href="https://github.com/aws/aws-cli" target="_blank" rel="noopener">官网</a></li><li>bashplotlib：在终端中进行基本绘图。<a href="https://github.com/glamp/bashplotlib" target="_blank" rel="noopener">官网</a></li><li>caniusepython3：判断是哪个项目妨碍你你移植到 Python3。<a href="https://github.com/brettcannon/caniusepython3" target="_blank" rel="noopener">官网</a></li><li>cookiecutter：从 cookiecutters（项目模板）创建项目的一个命令行工具。<a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="noopener">官网</a></li><li>doitlive：一个用来在终端中进行现场演示的工具。<a href="https://github.com/sloria/doitlive" target="_blank" rel="noopener">官网</a></li><li>pyftpdlib：一个速度极快和可扩展的 Python FTP 服务库。<a href="https://github.com/giampaolo/pyftpdlib" target="_blank" rel="noopener">官网</a></li><li>howdoi：通过命令行获取即时的编程问题解答。<a href="https://github.com/gleitz/howdoi" target="_blank" rel="noopener">官网</a></li><li>httpie：一个命令行 HTTP 客户端，cURL 的替代品，易用性更好。<a href="https://github.com/jkbrzt/httpie" target="_blank" rel="noopener">官网</a></li><li>PathPicker：从 bash 输出中选出文件。<a href="https://github.com/facebook/PathPicker" target="_blank" rel="noopener">官网</a></li><li>percol：向 UNIX shell 传统管道概念中加入交互式选择功能。<a href="https://github.com/mooz/percol" target="_blank" rel="noopener">官网</a></li><li>SAWS：一个加强版的 AWS 命令行。<a href="https://github.com/donnemartin/saws" target="_blank" rel="noopener">官网</a></li><li>thefuck：修正你之前的命令行指令。<a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">官网</a></li><li>mycli：一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/mycli" target="_blank" rel="noopener">官网</a></li><li>pgcli：Postgres 命令行工具，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/pgcli" target="_blank" rel="noopener">官网</a></li><li>try：一个从来没有更简单的命令行工具，用来试用 python 库。<a href="https://github.com/timofurrer/try" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h3><p>用来进行下载的库.</p><ul><li>s3cmd：一个用来管理 Amazon S3 和 CloudFront 的命令行工具。<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="noopener">官网</a></li><li>s4cmd：超级 S3 命令行工具，性能更加强劲。<a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="noopener">官网</a></li><li>you-get：一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。<a href="https://www.soimort.org/you-get/" target="_blank" rel="noopener">官网</a></li><li>youtube-dl：一个小巧的命令行程序，用来下载 YouTube 视频。<a href="http://rg3.github.io/youtube-dl/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>用来操作图像的库.</p><ul><li><a href="http://hao.jobbole.com/pillow/" target="_blank" rel="noopener">pillow</a>：Pillow 是一个更加易用版的 <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL</a>。<a href="http://pillow.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>hmap：图像直方图映射。<a href="https://github.com/rossgoodwin/hmap" target="_blank" rel="noopener">官网</a></li><li>imgSeek：一个使用视觉相似性搜索一组图片集合的项目。<a href="https://sourceforge.net/projects/imgseek/" target="_blank" rel="noopener">官网</a></li><li>nude.py：裸体检测。<a href="https://github.com/hhatto/nude.py" target="_blank" rel="noopener">官网</a></li><li>pyBarcode：不借助 PIL 库在 Python 程序中生成条形码。<a href="https://pythonhosted.org/pyBarcode/" target="_blank" rel="noopener">官网</a></li><li>pygram：类似 Instagram 的图像滤镜。<a href="https://github.com/ajkumar25/pygram" target="_blank" rel="noopener">官网</a></li><li>python-qrcode：一个纯 Python 实现的二维码生成器。<a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="noopener">官网</a></li><li>Quads：基于四叉树的计算机艺术。<a href="https://github.com/fogleman/Quads" target="_blank" rel="noopener">官网</a></li><li>scikit-image：一个用于（科学）图像处理的 Python 库。<a href="http://scikit-image.org/" target="_blank" rel="noopener">官网</a></li><li>thumbor：一个小型图像服务，具有剪裁，尺寸重设和翻转功能。<a href="https://github.com/thumbor/thumbor" target="_blank" rel="noopener">官网</a></li><li>wand：<a href="http://www.imagemagick.org/script/magick-wand.php" target="_blank" rel="noopener">MagickWand</a>的 Python 绑定。MagickWand 是 ImageMagick 的 C API 。<a href="https://github.com/dahlia/wand" target="_blank" rel="noopener">官网</a></li><li>face_recognition：简单易用的 python 人脸识别库。<a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">官网</a></li></ul><h3 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h3><p>光学字符识别库。</p><ul><li>pyocr：Tesseract 和 Cuneiform 的一个封装(wrapper)。<a href="https://github.com/jflesch/pyocr" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pytesseract/" target="_blank" rel="noopener">pytesseract</a>：<a href="https://github.com/tesseract-ocr" target="_blank" rel="noopener">Google Tesseract OCR</a> 的另一个封装(wrapper)。<a href="https://github.com/madmaze/pytesseract" target="_blank" rel="noopener">官网</a></li><li>python-tesseract：<a href="https://github.com/tesseract-ocr" target="_blank" rel="noopener">Google Tesseract OCR</a> 的一个包装类。</li></ul><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>用来操作音频的库</p><ul><li>audiolazy：Python 的数字信号处理包。<a href="https://github.com/danilobellini/audiolazy" target="_blank" rel="noopener">官网</a> </li><li>audioread：交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。<a href="https://github.com/beetbox/audioread" target="_blank" rel="noopener">官网</a></li><li>beets：一个音乐库管理工具及 <a href="https://musicbrainz.org/" target="_blank" rel="noopener">MusicBrainz</a> 标签添加工具。<a href="http://beets.io/" target="_blank" rel="noopener">官网</a></li><li>dejavu：音频指纹提取和识别。<a href="https://github.com/worldveil/dejavu" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/django-elastic-transcoder/" target="_blank" rel="noopener">django-elastic-transcoder</a>：Django + <a href="http://aws.amazon.com/elastictranscoder/" target="_blank" rel="noopener">Amazon Elastic Transcoder</a>。<a href="https://github.com/StreetVoice/django-elastic-transcoder" target="_blank" rel="noopener">官网</a></li><li>eyeD3：一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。<a href="http://eyed3.nicfit.net/" target="_blank" rel="noopener">官网</a></li><li>id3reader：一个用来读取 MP3 元数据的 Python 模块。<a href="http://nedbatchelder.com/code/modules/id3reader.py" target="_blank" rel="noopener">官网</a></li><li>m3u8：一个用来解析 m3u8 文件的模块。<a href="https://github.com/globocom/m3u8" target="_blank" rel="noopener">官网</a></li><li>mutagen：一个用来处理音频元数据的 Python 模块。<a href="https://bitbucket.org/lazka/mutagen" target="_blank" rel="noopener">官网</a></li><li>pydub：通过简单、简洁的高层接口来操作音频文件。<a href="https://github.com/jiaaro/pydub" target="_blank" rel="noopener">官网</a></li><li>pyechonest：<a href="http://developer.echonest.com/" target="_blank" rel="noopener">Echo Nest</a> API 的 Python 客户端。<a href="https://github.com/echonest/pyechonest" target="_blank" rel="noopener">官网</a></li><li>talkbox：一个用来处理演讲/信号的 Python 库。<a href="http://scikits.appspot.com/talkbox" target="_blank" rel="noopener">官网</a></li><li>TimeSide：开源 web 音频处理框架。<a href="https://github.com/Parisson/TimeSide" target="_blank" rel="noopener">官网</a></li><li>tinytag：一个用来读取 MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。<a href="https://github.com/devsnd/tinytag" target="_blank" rel="noopener">官网</a></li><li>mingus：一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。<a href="http://bspaans.github.io/python-mingus/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>用来操作视频和 GIF 的库。</p><ul><li>moviepy：一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。<a href="http://zulko.github.io/moviepy/" target="_blank" rel="noopener">官网</a></li><li>scikit-video：SciPy 视频处理常用程序。<a href="https://github.com/aizvorski/scikit-video" target="_blank" rel="noopener">官网</a></li></ul><h3 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h3><p>地理编码地址以及用来处理经纬度的库。</p><ul><li>GeoDjango：世界级地理图形 web 框架。<a href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/" target="_blank" rel="noopener">官网</a></li><li>GeoIP：MaxMind GeoIP Legacy 数据库的 Python API。<a href="https://github.com/maxmind/geoip-api-python" target="_blank" rel="noopener">官网</a></li><li>geojson：GeoJSON 的 Python 绑定及工具。<a href="https://github.com/frewsxcv/python-geojson" target="_blank" rel="noopener">官网</a></li><li>geopy：Python 地址编码工具箱。<a href="https://github.com/geopy/geopy" target="_blank" rel="noopener">官网</a></li><li>pygeoip：纯 Python GeoIP API。<a href="https://github.com/appliedsec/pygeoip" target="_blank" rel="noopener">官网</a></li><li>django-countries：一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。<a href="https://github.com/SmileyChris/django-countries" target="_blank" rel="noopener">官网</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>使用 HTTP 的库。</p><ul><li>aiohttp：基于 asyncio 的异步 HTTP 网络库。<a href="https://github.com/aio-libs/aiohttp" target="_blank" rel="noopener">官网</a></li><li>requests：人性化的 HTTP 请求库。<a href="http://docs.python-requests.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>grequests：requests 库 + gevent ，用于异步 HTTP 请求.<a href="https://github.com/kennethreitz/grequests" target="_blank" rel="noopener">官网</a></li><li>httplib2：全面的 HTTP 客户端库。<a href="https://github.com/jcgregorio/httplib2" target="_blank" rel="noopener">官网</a></li><li>treq：类似 requests 的 Python API 构建于 Twisted HTTP 客户端之上。<a href="https://github.com/twisted/treq" target="_blank" rel="noopener">官网</a></li><li>urllib3：一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。<a href="https://github.com/shazow/urllib3" target="_blank" rel="noopener">官网</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Python 实现的数据库。</p><ul><li>pickleDB：一个简单，轻量级键值储存数据库。<a href="https://pythonhosted.org/pickleDB/" target="_blank" rel="noopener">官网</a></li><li>PipelineDB：流式 SQL 数据库。<a href="https://www.pipelinedb.com/" target="_blank" rel="noopener">官网</a></li><li>TinyDB：一个微型的，面向文档型数据库。<a href="https://github.com/msiemens/tinydb" target="_blank" rel="noopener">官网</a></li><li>ZODB：一个 Python 原生对象数据库。一个键值和对象图数据库。<a href="http://www.zodb.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>用来连接和操作数据库的库。</p><ul><li>MySQL：<a href="http://shlomi-noach.github.io/awesome-mysql/" target="_blank" rel="noopener">awesome-mysql</a> 系列<ul><li>aiomysql：基于 asyncio 的异步 MySQL 数据库操作库。<a href="https://github.com/aio-libs/aiomysql" target="_blank" rel="noopener">官网</a></li><li>mysql-python：Python 的 MySQL 数据库连接器。<a href="https://sourceforge.net/projects/mysql-python/" target="_blank" rel="noopener">官网</a></li><li>ysqlclient：<a href="https://github.com/PyMySQL/mysqlclient-python" target="_blank" rel="noopener">mysql-python</a> 分支，支持 Python 3。</li><li>oursql：一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs。<a href="https://pythonhosted.org/oursql/" target="_blank" rel="noopener">官网</a></li><li>PyMySQL：纯 Python MySQL 驱动，兼容 mysql-python。<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="noopener">官网</a></li></ul></li><li>PostgreSQL<ul><li>psycopg2：Python 中最流行的 PostgreSQL 适配器。<a href="http://initd.org/psycopg/" target="_blank" rel="noopener">官网</a></li><li>queries：psycopg2 库的封装，用来和 PostgreSQL 进行交互。<a href="https://github.com/gmr/queries" target="_blank" rel="noopener">官网</a></li><li>txpostgres：基于 Twisted 的异步 PostgreSQL 驱动。<a href="http://txpostgres.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li><li>其他关系型数据库<ul><li>apsw：另一个 Python SQLite 封装。<a href="http://rogerbinns.github.io/apsw/" target="_blank" rel="noopener">官网</a></li><li>dataset：在数据库中存储 Python 字典</li><li>pymssql：一个简单的 Microsoft SQL Server 数据库接口。<a href="http://www.pymssql.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li><li>NoSQL 数据库<ul><li>asyncio-redis：基于 asyncio 的 redis 客户端 (PEP 3156)。<a href="https://github.com/jonathanslenders/asyncio-redis" target="_blank" rel="noopener">官网</a></li><li>cassandra-python-driver：Cassandra 的 Python 驱动。<a href="https://github.com/datastax/python-driver" target="_blank" rel="noopener">官网</a></li><li>HappyBase：一个为 Apache HBase 设计的，对开发者友好的库。<a href="http://happybase.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Plyvel：一个快速且功能丰富的 LevelDB 的 Python 接口。<a href="https://plyvel.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>py2neo：Neo4j restful 接口的 Python 封装客户端。<a href="http://py2neo.org/2.0/" target="_blank" rel="noopener">官网</a></li><li>pycassa：Cassandra 的 Python Thrift 驱动。<a href="https://github.com/pycassa/pycassa" target="_blank" rel="noopener">官网</a></li><li>PyMongo：MongoDB 的官方 Python 客户端。<a href="https://docs.mongodb.org/ecosystem/drivers/python/" target="_blank" rel="noopener">官网</a></li><li>redis-py：Redis 的 Python 客户端。<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">官网</a></li><li>telephus：基于 Twisted 的 Cassandra 客户端。<a href="https://github.com/driftx/Telephus" target="_blank" rel="noopener">官网</a></li><li>txRedis：基于 Twisted 的 Redis 客户端。<a href="https://github.com/deldotdr/txRedis" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>实现对象关系映射或数据映射技术的库。</p><ul><li>关系型数据库<ul><li>Django Models：Django 的一部分。<a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="noopener">官网</a></li><li>SQLAlchemy：Python SQL 工具以及对象关系映射工具。<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">官网</a><ul><li><a href="https://github.com/dahlia/awesome-sqlalchemy" target="_blank" rel="noopener">awesome-sqlalchemy</a> 系列</li></ul></li><li><a href="http://hao.jobbole.com/peewee/" target="_blank" rel="noopener">Peewee</a>：一个小巧，富有表达力的 ORM。<a href="https://github.com/coleifer/peewee" target="_blank" rel="noopener">官网</a></li><li>PonyORM：提供面向生成器的 SQL 接口的 ORM。<a href="https://ponyorm.com/" target="_blank" rel="noopener">官网</a></li><li>python-sql：编写 Python 风格的 SQL 查询。<a href="https://pypi.python.org/pypi/python-sql" target="_blank" rel="noopener">官网</a></li></ul></li><li>NoSQL 数据库<ul><li>django-mongodb-engine：Django MongoDB 后端。<a href="https://github.com/django-nonrel/mongodb-engine" target="_blank" rel="noopener">官网</a></li><li>PynamoDB：<a href="https://aws.amazon.com/dynamodb/" target="_blank" rel="noopener">Amazon DynamoDB</a> 的一个 Python 风格接口。<a href="https://github.com/jlafon/PynamoDB" target="_blank" rel="noopener">官网</a></li><li>flywheel：Amazon DynamoDB 的对象映射工具。<a href="https://github.com/mathcamp/flywheel" target="_blank" rel="noopener">官网</a></li><li>MongoEngine：一个 Python 对象文档映射工具，用于 MongoDB。<a href="http://mongoengine.org/" target="_blank" rel="noopener">官网</a></li><li>hot-redis：为 Redis 提供 Python 丰富的数据类型。<a href="https://github.com/stephenmcd/hot-redis" target="_blank" rel="noopener">官网</a></li><li>redisco：一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。<a href="https://github.com/kiddouk/redisco" target="_blank" rel="noopener">官网</a></li></ul></li><li>其他<ul><li>butterdb：Google Drive 电子表格的 Python ORM。<a href="https://github.com/Widdershin/butterdb" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><p>全栈 Web 框架。</p><ul><li><a href="http://hao.jobbole.com/django/" target="_blank" rel="noopener">Django</a>：Python 界最流行的 web 框架。<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">官网</a><ul><li><a href="https://gitlab.com/rosarior/awesome-django" target="_blank" rel="noopener">awesome-django</a> 系列</li></ul></li><li><a href="http://hao.jobbole.com/flask/" target="_blank" rel="noopener">Flask</a>：一个 Python 微型框架。<a href="http://flask.pocoo.org/" target="_blank" rel="noopener">官网</a><ul><li><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="noopener">awesome-flask</a> 系列</li></ul></li><li>pyramid：一个小巧，快速，接地气的开源 Python web 框架。<ul><li><a href="https://github.com/uralbash/awesome-pyramid" target="_blank" rel="noopener">awesome-pyramid</a> 系列</li></ul></li><li><a href="http://hao.jobbole.com/bottle/" target="_blank" rel="noopener">Bottle</a>：一个快速小巧，轻量级的 WSGI 微型 web 框架。<a href="http://bottlepy.org/docs/dev/index.html" target="_blank" rel="noopener">官网</a></li><li>CherryPy：一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有 WSGI 线程池。<a href="http://www.cherrypy.org/" target="_blank" rel="noopener">官网</a></li><li>TurboGears：一个可以扩展为全栈解决方案的微型框架。<a href="http://www.turbogears.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-webpy/" target="_blank" rel="noopener">web.py</a>：一个 Python 的 web 框架，既简单，又强大。<a href="http://webpy.org/" target="_blank" rel="noopener">官网</a></li><li>web2py：一个全栈 web 框架和平台，专注于简单易用。<a href="http://www.web2py.com/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/tornado/" target="_blank" rel="noopener">Tornado</a>：一个 web 框架和异步网络库。<a href="http://www.tornadoweb.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>sanic：基于 Python3.5+ 的异步网络框架。<a href="https://github.com/channelcat/sanic/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>允许或拒绝用户访问数据或功能的库。</p><ul><li>Carteblanche：站在用户和设计者角度开发的一个代码对齐模块，很好地处理了代码导航及权限。<a href="https://github.com/neuman/python-carteblanche/" target="_blank" rel="noopener">官网</a></li><li>django-guardian：Django 1.2+ 实现了单个对象权限。<a href="https://github.com/django-guardian/django-guardian" target="_blank" rel="noopener">官网</a></li><li>django-rules：一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。<a href="https://github.com/dfunckt/django-rules" target="_blank" rel="noopener">官网</a></li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>内容管理系统</p><ul><li>odoo-cms: 一个开源的，企业级 CMS，基于 odoo。<a href="http://www.odoo.com" target="_blank" rel="noopener">官网</a></li><li>django-cms：一个开源的，企业级 CMS，基于 Django。<a href="http://www.django-cms.org/en/" target="_blank" rel="noopener">官网</a></li><li>djedi-cms：一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。<a href="http://djedi-cms.org/" target="_blank" rel="noopener">官网</a></li><li>FeinCMS：基于 Django 构建的最先进的内容管理系统之一。<a href="http://www.feincms.org/" target="_blank" rel="noopener">官网</a></li><li>Kotti：一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。<a href="http://kotti.pylonsproject.org/" target="_blank" rel="noopener">官网</a></li><li>Mezzanine：一个强大的，持续的，灵活的内容管理平台。<a href="http://mezzanine.jupo.org/" target="_blank" rel="noopener">官网</a></li><li>Opps：一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。<a href="http://opps.github.io/opps/" target="_blank" rel="noopener">官网</a></li><li>Plone：一个构建于开源应用服务器 Zope 之上的 CMS。<a href="https://plone.org/" target="_blank" rel="noopener">官网</a></li><li>Quokka：灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。<a href="http://quokkaproject.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/wagtail/" target="_blank" rel="noopener">Wagtail</a>：一个 Django 内容管理系统。<a href="https://wagtail.io/" target="_blank" rel="noopener">官网</a></li><li>Widgy：最新的 CMS 框架，基于 Django。<a href="https://wid.gy/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h3><p>用于电子商务以及支付的框架和库。</p><ul><li>django-oscar：一个用于 Django 的开源的电子商务框架。<a href="http://oscarcommerce.com/" target="_blank" rel="noopener">官网</a></li><li>django-shop：一个基于 Django 的店铺系统。<a href="https://github.com/awesto/django-shop" target="_blank" rel="noopener">官网</a></li><li>Cartridge：一个基于 Mezzanine 构建的购物车应用。<a href="https://github.com/stephenmcd/cartridge" target="_blank" rel="noopener">官网</a></li><li>shoop：一个基于 Django 的开源电子商务平台。<a href="https://www.shoop.io/en/" target="_blank" rel="noopener">官网</a></li><li>alipay：非官方的 Python 支付宝 API。<a href="https://github.com/lxneng/alipay" target="_blank" rel="noopener">官网</a></li><li>merchant：一个可以接收来自多种支付平台支付的 Django 应用。<a href="https://github.com/agiliq/merchant" target="_blank" rel="noopener">官网</a></li><li>money：一个货币类库。带有可选的 CLDR 后端本地化格式，提供可扩展的货币兑换解决方案。<a href="https://github.com/carlospalol/money" target="_blank" rel="noopener">官网</a></li><li>python-currencies：显示货币格式以及它的数值。<a href="https://github.com/Alir3z4/python-currencies" target="_blank" rel="noopener">官网</a></li></ul><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>用来开发 RESTful APIs 的库</p><ul><li>Django<ul><li><a href="http://hao.jobbole.com/django-rest-framework/" target="_blank" rel="noopener">django-rest-framework</a>：一个强大灵活的工具，用来构建 web API。<a href="http://www.django-rest-framework.org/" target="_blank" rel="noopener">官网</a></li><li>django-tastypie：为 Django 应用开发 API。<a href="http://tastypieapi.org/" target="_blank" rel="noopener">官网</a></li><li>django-formapi：为 Django 的表单验证，创建 JSON APIs 。<a href="https://github.com/5monkeys/django-formapi" target="_blank" rel="noopener">官网</a></li></ul></li><li>Flask<ul><li>flask-api：为 flask 开发的，可浏览 Web APIs 。<a href="http://www.flaskapi.org/" target="_blank" rel="noopener">官网</a></li><li>flask-restful：为 flask 快速创建 REST APIs 。<a href="http://flask-restful.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>flask-restless：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。<a href="https://flask-restless.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>flask-api-utils：为 Flask 处理 API 表示和验证。<a href="https://github.com/marselester/flask-api-utils" target="_blank" rel="noopener">官网</a></li><li>eve：REST API 框架，由 Flask, MongoDB 等驱动。<a href="https://github.com/nicolaiarocci/eve" target="_blank" rel="noopener">官网</a></li></ul></li><li>Pyramid<ul><li>cornice：一个 Pyramid 的 REST 框架 。<a href="https://cornice.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li><li>与框架无关的<ul><li>falcon：一个用来建立云 API 和 web app 后端的高性能框架。<a href="http://falconframework.org/" target="_blank" rel="noopener">官网</a></li><li>sandman：为现存的数据库驱动系统自动创建 REST APIs 。<a href="https://github.com/jeffknupp/sandman" target="_blank" rel="noopener">官网</a></li><li>restless：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。<a href="http://restless.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>ripozo：快速创建 REST/HATEOAS/Hypermedia APIs。<a href="https://github.com/vertical-knowledge/ripozo" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>实现验证方案的库。</p><ul><li>OAuth<ul><li>Authomatic：简单但是强大的框架，身份验证/授权客户端。<a href="http://peterhudec.github.io/authomatic/" target="_blank" rel="noopener">官网</a></li><li>django-allauth：Django 的验证应用。<a href="https://github.com/pennersr/django-allauth" target="_blank" rel="noopener">官网</a></li><li>django-oauth-toolkit：为 Django 用户准备的 OAuth2。<a href="https://github.com/evonove/django-oauth-toolkit" target="_blank" rel="noopener">官网</a></li><li>django-oauth2-provider：为 Django 应用提供 OAuth2 接入。<a href="https://github.com/caffeinehit/django-oauth2-provider" target="_blank" rel="noopener">官网</a></li><li>Flask-OAuthlib：OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。<a href="https://github.com/lepture/flask-oauthlib" target="_blank" rel="noopener">官网</a></li><li>OAuthLib：一个 OAuth 请求-签名逻辑通用、 完整的实现。<a href="https://github.com/idan/oauthlib" target="_blank" rel="noopener">官网</a></li><li>python-oauth2：一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。<a href="https://github.com/joestump/python-oauth2" target="_blank" rel="noopener">官网</a></li><li>python-social-auth：一个设置简单的社会化验证方式。<a href="https://github.com/omab/python-social-auth" target="_blank" rel="noopener">官网</a></li><li>rauth：OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。<a href="https://github.com/litl/rauth" target="_blank" rel="noopener">官网</a></li><li>sanction：一个超级简单的 OAuth2 客户端实现。<a href="https://github.com/demianbrecht/sanction" target="_blank" rel="noopener">官网</a></li></ul></li><li>其他<ul><li>jose：JavaScript 对象签名和加密草案的实现。<a href="https://github.com/demonware/jose" target="_blank" rel="noopener">官网</a></li><li>PyJWT：JSON Web 令牌草案 01。<a href="https://github.com/jpadilla/pyjwt" target="_blank" rel="noopener">官网</a></li><li>python-jws：JSON Web 签名草案 02 的实现。<a href="https://github.com/brianloveswords/python-jws" target="_blank" rel="noopener">官网</a></li><li>python-jwt：一个用来生成和验证 JSON Web 令牌的模块。<a href="https://github.com/davedoesdev/python-jwt" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>模板生成和词法解析的库和工具。</p><ul><li><a href="http://hao.jobbole.com/jinja2/" target="_blank" rel="noopener">Jinja2</a>：一个现代的，对设计师友好的模板引擎。<a href="https://github.com/pallets/jinja" target="_blank" rel="noopener">官网</a></li><li>Chameleon：一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。<a href="https://chameleon.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Genshi：Python 模板工具，用以生成 web 感知的结果。<a href="https://genshi.edgewall.org/" target="_blank" rel="noopener">官网</a></li><li>Mako：Python 平台的超高速轻量级模板。<a href="http://www.makotemplates.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>处理事件以及任务队列的库。</p><ul><li>celery：一个异步任务队列/作业队列，基于分布式消息传递。<a href="http://www.celeryproject.org/" target="_blank" rel="noopener">官网</a></li><li>huey：小型多线程任务队列。<a href="https://github.com/coleifer/huey" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/mrq/" target="_blank" rel="noopener">mrq</a>：Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。<a href="https://github.com/pricingassistant/mrq" target="_blank" rel="noopener">官网</a></li><li>rq：简单的 Python 作业队列。<a href="http://python-rq.org/" target="_blank" rel="noopener">官网</a></li><li>simpleq：一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。<a href="https://github.com/rdegges/simpleq" target="_blank" rel="noopener">官网</a></li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>对数据进行索引和执行搜索查询的库和软件。</p><ul><li>django-haystack：Django 模块化搜索。<a href="https://github.com/django-haystack/django-haystack" target="_blank" rel="noopener">官网</a></li><li>elasticsearch-py：Elasticsearch 的官方底层 Python 客户端。<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.html" target="_blank" rel="noopener">官网</a></li><li>elasticsearch-dsl-py：Elasticsearch 的官方高级 Python 客户端。<a href="https://github.com/elastic/elasticsearch-dsl-py" target="_blank" rel="noopener">官网</a> </li><li>solrpy：<a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">solr</a> 的 Python 客户端。<a href="https://github.com/edsu/solrpy" target="_blank" rel="noopener">官网</a></li><li>Whoosh：一个快速的纯 Python 搜索引擎库。<a href="http://whoosh.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="动态消息"><a href="#动态消息" class="headerlink" title="动态消息"></a>动态消息</h3><p>用来创建用户活动的库。</p><ul><li>django-activity-stream：从你的站点行为中生成通用活动信息流。<a href="https://github.com/justquick/django-activity-stream" target="_blank" rel="noopener">官网</a></li><li>Stream-Framework：使用 Cassandra 和 Redis 创建动态消息和通知系统。<a href="https://github.com/tschellenbach/Stream-Framework" target="_blank" rel="noopener">官网</a></li></ul><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>管理、压缩、缩小网站资源的工具。</p><ul><li>django-compressor：将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。<a href="https://github.com/django-compressor/django-compressor" target="_blank" rel="noopener">官网</a></li><li>django-storages：一个针对 Django 的自定义存储后端的工具集合。<a href="http://django-storages.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>fanstatic：打包、优化，并且把静态文件依赖作为 Python 的包来提供。<a href="http://www.fanstatic.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>File Conveyor：一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。<a href="http://fileconveyor.org/" target="_blank" rel="noopener">官网</a></li><li>Flask-Assets：帮你将 web 资源整合到你的 Flask app 中。<a href="http://flask-assets.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>jinja-assets-compressor：一个 Jinja 扩展，用来编译和压缩你的资源。<a href="https://github.com/jaysonsantos/jinja-assets-compressor" target="_blank" rel="noopener">官网</a></li><li>webassets：为你的静态资源打包、优化和管理生成独一无二的缓存 URL。<a href="http://webassets.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存数据的库。</p><ul><li>Beaker：一个缓存和会话库，可以用在 web 应用和独立 Python 脚本和应用上。<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>django-cache-machine：Django 模型的自动缓存和失效。<a href="https://github.com/django-cache-machine/django-cache-machine" target="_blank" rel="noopener">官网</a></li><li>django-cacheops：具有自动颗粒化事件驱动失效功能的 ORM。<a href="https://github.com/Suor/django-cacheops" target="_blank" rel="noopener">官网</a></li><li>django-viewlet：渲染模板，同时具有额外的缓存控制功能。<a href="https://github.com/5monkeys/django-viewlet" target="_blank" rel="noopener">官网</a></li><li>dogpile.cache：dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。<a href="http://dogpilecache.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>HermesCache：Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。<a href="https://pypi.python.org/pypi/HermesCache" target="_blank" rel="noopener">官网</a></li><li>johnny-cache：django 应用缓存框架。<a href="https://github.com/jmoiron/johnny-cache" target="_blank" rel="noopener">官网</a></li><li>pylibmc：<a href="http://libmemcached.org/libMemcached.html" target="_blank" rel="noopener">libmemcached</a> 接口的 Python 封装。<a href="https://github.com/lericson/pylibmc" target="_blank" rel="noopener">官网</a></li></ul><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>用来发送和解析电子邮件的库。</p><ul><li>django-celery-ses：带有 AWS SES 和 Celery 的 Django email 后端。<a href="https://github.com/StreetVoice/django-celery-ses" target="_blank" rel="noopener">官网</a></li><li>envelopes：供人类使用的电子邮件库。<a href="http://tomekwojcik.github.io/envelopes/" target="_blank" rel="noopener">官网</a></li><li>flanker：一个 email 地址和 Mime 解析库。<a href="https://github.com/mailgun/flanker" target="_blank" rel="noopener">官网</a></li><li>imbox：Python IMAP 库。<a href="https://github.com/martinrusev/imbox" target="_blank" rel="noopener">官网</a></li><li>inbox.py：Python SMTP 服务器。<a href="https://github.com/kennethreitz/inbox.py" target="_blank" rel="noopener">官网</a></li><li>inbox：一个开源电子邮件工具箱。<a href="https://github.com/nylas/sync-engine" target="_blank" rel="noopener">官网</a></li><li>lamson：Python 风格的 SMTP 应用服务器。<a href="https://github.com/zedshaw/lamson" target="_blank" rel="noopener">官网</a></li><li>mailjet：Mailjet API 实现，用来提供批量发送邮件，统计等功能。<a href="https://github.com/WoLpH/mailjet" target="_blank" rel="noopener">官网</a></li><li>marrow.mailer：高性能可扩展邮件分发框架。<a href="https://github.com/marrow/mailer" target="_blank" rel="noopener">官网</a></li><li>modoboa：一个邮件托管和管理平台，具有现代的、简约的 Web UI。<a href="https://github.com/tonioo/modoboa" target="_blank" rel="noopener">官网</a></li><li>pyzmail：创建，发送和解析电子邮件。<a href="http://www.magiksys.net/pyzmail/" target="_blank" rel="noopener">官网</a></li><li>Talon：Mailgun 库，用来抽取信息和签名。<a href="https://github.com/mailgun/talon" target="_blank" rel="noopener">官网</a></li><li>yagmail：yagmail是一个GMAIL / SMTP客户端，旨在使其尽可能简单地发送电子邮件。<a href="https://pypi.org/project/yagmail/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>用来进行国际化的库。</p><ul><li>Babel：一个 Python 的国际化库。<a href="http://babel.pocoo.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Korean：一个韩语词态库。<a href="https://korean.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="URL-处理"><a href="#URL-处理" class="headerlink" title="URL 处理"></a>URL 处理</h3><p>解析 URLs 的库</p><ul><li>furl：一个让处理 URL 更简单小型 Python 库。<a href="https://github.com/gruns/furl" target="_blank" rel="noopener">官网</a></li><li>purl：一个简单的，不可变的 URL 类，具有简洁的 API 来进行询问和处理。<a href="https://github.com/codeinthehole/purl" target="_blank" rel="noopener">官网</a></li><li>pyshorteners：一个纯 Python URL 缩短库。<a href="https://github.com/ellisonleao/pyshorteners" target="_blank" rel="noopener">官网</a></li><li>shorturl：生成短小 URL 和类似 bit.ly 短链的 Python 实现。<a href="https://github.com/Alir3z4/python-shorturl" target="_blank" rel="noopener">官网</a></li><li>webargs：一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado 和 Pyramid。<a href="https://github.com/sloria/webargs" target="_blank" rel="noopener">官网</a></li></ul><h3 id="HTML-处理"><a href="#HTML-处理" class="headerlink" title="HTML 处理"></a>HTML 处理</h3><p>处理 HTML 和 XML 的库。</p><ul><li>BeautifulSoup：以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">官网</a></li><li>bleach：一个基于白名单的 HTML 清理和文本链接库。<a href="http://bleach.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>cssutils：一个 Python 的 CSS 库。<a href="https://pypi.python.org/pypi/cssutils/" target="_blank" rel="noopener">官网</a></li><li>html5lib：一个兼容标准的 HTML 文档和片段解析及序列化库。<a href="https://github.com/html5lib/html5lib-python" target="_blank" rel="noopener">官网</a></li><li>lxml：一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。<a href="http://lxml.de/" target="_blank" rel="noopener">官网</a></li><li>MarkupSafe：为 Python 实现 XML/HTML/XHTML 标记安全字符串。<a href="https://github.com/pallets/markupsafe" target="_blank" rel="noopener">官网</a></li><li>pyquery：一个解析 HTML 的库，类似 jQuery。<a href="https://github.com/gawel/pyquery" target="_blank" rel="noopener">官网</a></li><li>requests-html：人性化的，Pythonic 的 HTML 解析库。<a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">官网</a></li><li>untangle：将 XML 文档转换为 Python 对象，使其可以方便的访问。<a href="https://github.com/stchris/untangle" target="_blank" rel="noopener">官网</a></li><li>xhtml2pdf：HTML/CSS 转 PDF 工具。<a href="https://github.com/xhtml2pdf/xhtml2pdf" target="_blank" rel="noopener">官网</a></li><li>xmltodict：像处理 JSON 一样处理 XML。<a href="https://github.com/martinblech/xmltodict" target="_blank" rel="noopener">官网</a></li></ul><p>爬取网络站点的库</p><ul><li>Scrapy：一个快速高级的屏幕爬取及网页采集框架。<a href="http://scrapy.org/" target="_blank" rel="noopener">官网</a></li><li>cola：一个分布式爬虫框架。<a href="https://github.com/chineking/cola" target="_blank" rel="noopener">官网</a></li><li>Demiurge：基于 PyQuery 的爬虫微型框架。<a href="https://github.com/matiasb/demiurge" target="_blank" rel="noopener">官网</a></li><li>feedparser：通用 feed 解析器。<a href="http://pythonhosted.org/feedparser/" target="_blank" rel="noopener">官网</a></li><li>Grab：站点爬取框架。<a href="http://grablib.org/" target="_blank" rel="noopener">官网</a></li><li>MechanicalSoup：用于自动和网络站点交互的 Python 库。<a href="https://github.com/hickford/MechanicalSoup" target="_blank" rel="noopener">官网</a></li><li>portia：Scrapy 可视化爬取。<a href="https://github.com/scrapinghub/portia" target="_blank" rel="noopener">官网</a></li><li>pyspider：一个强大的爬虫系统。<a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">官网</a></li><li>RoboBrowser：一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。<a href="https://github.com/jmcarp/robobrowser" target="_blank" rel="noopener">官网</a></li></ul><h3 id="网页内容提取"><a href="#网页内容提取" class="headerlink" title="网页内容提取"></a>网页内容提取</h3><p>用于进行网页内容提取的库。</p><ul><li>Haul：一个可以扩展的图像爬取工具。<a href="https://github.com/vinta/Haul" target="_blank" rel="noopener">官网</a></li><li>html2text：将 HTML 转换为 Markdown 格式文本。<a href="https://github.com/Alir3z4/html2text" target="_blank" rel="noopener">官网</a></li><li>lassie：人性化的网页内容检索库。<a href="https://github.com/michaelhelmick/lassie" target="_blank" rel="noopener">官网</a></li><li>micawber：一个小型网页内容提取库，用来从 URLs 提取富内容。<a href="https://github.com/coleifer/micawber" target="_blank" rel="noopener">官网</a> </li><li><a href="http://hao.jobbole.com/python-newspaper/" target="_blank" rel="noopener">newspaper</a>：使用 Python 进行新闻提取，文章提取以及内容策展。<a href="https://github.com/codelucas/newspaper" target="_blank" rel="noopener">官网</a></li><li>opengraph：一个用来解析开放内容协议(Open Graph Protocol)的 Python 模块。<a href="https://github.com/erikriver/opengraph" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-goose/" target="_blank" rel="noopener">python-goose</a>：HTML 内容/文章提取器。<a href="https://github.com/grangier/python-goose" target="_blank" rel="noopener">官网</a></li><li>python-readability：arc90 公司 readability 工具的 Python 高速端口。<a href="https://github.com/buriy/python-readability" target="_blank" rel="noopener">官网</a></li><li>sanitize：为杂乱的数据世界带来调理性。<a href="https://github.com/Alir3z4/python-sanitize" target="_blank" rel="noopener">官网</a></li><li>sumy：一个为文本文件和 HTML 页面进行自动摘要的模块。<a href="https://github.com/miso-belica/sumy" target="_blank" rel="noopener">官网</a></li><li>textract：从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。<a href="https://github.com/deanmalmgren/textract" target="_blank" rel="noopener">官网</a></li></ul><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>进行表单操作的库。</p><ul><li>Deform：Python HTML 表单生成库，受到了 formish 表单生成库的启发。<a href="http://deform.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>django-bootstrap3：集成了 Bootstrap 3 的 Django。<a href="https://github.com/dyve/django-bootstrap3" target="_blank" rel="noopener">官网</a></li><li>django-crispy-forms：一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。<a href="http://django-crispy-forms.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>django-remote-forms：一个平台独立的 Django 表单序列化工具。<a href="https://github.com/WiserTogether/django-remote-forms" target="_blank" rel="noopener">官网</a></li><li>WTForms：一个灵活的表单验证和呈现库。<a href="http://wtforms.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>WTForms-JSON：一个 WTForms 扩展，用来处理 JSON 数据。<a href="http://wtforms-json.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证库。多用于表单验证。</p><ul><li>Cerberus：一个映射验证器（mappings-validator）。支持多种规则，提供归一化功能，可以方便地定制为 Python 风格的 schema 定义。<a href="http://docs.python-cerberus.org/en/stable/" target="_blank" rel="noopener">官网</a></li><li>colander：一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。<a href="http://docs.pylonsproject.org/projects/colander/en/latest/" target="_blank" rel="noopener">官网</a></li><li>kmatch：一种用于匹配/验证/筛选 Python 字典的语言。<a href="https://github.com/ambitioninc/kmatch" target="_blank" rel="noopener">官网</a></li><li>schema：一个用于对 Python 数据结构进行验证的库。<a href="https://github.com/keleshev/schema" target="_blank" rel="noopener">官网</a> </li><li>Schematics：数据结构验证。<a href="https://github.com/schematics/schematics" target="_blank" rel="noopener">官网</a></li><li>valideer：轻量级可扩展的数据验证和适配库。<a href="https://github.com/podio/valideer" target="_blank" rel="noopener">官网</a></li><li>voluptuous：一个 Python 数据验证库。主要是为了验证传入 Python 的 JSON，YAML 等数据。<a href="https://github.com/alecthomas/voluptuous" target="_blank" rel="noopener">官网</a></li><li>jsonschema：<a href="http://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a>的 python 实现，用于 JSON 数据的验证。<a href="https://github.com/Julian/jsonschema" target="_blank" rel="noopener">官网</a></li></ul><h3 id="反垃圾技术"><a href="#反垃圾技术" class="headerlink" title="反垃圾技术"></a>反垃圾技术</h3><p>帮助你和电子垃圾进行战斗的库。</p><ul><li>django-simple-captcha：一个简单、高度可定制的 Django 应用，可以为任何 Django 表单添加验证码。<a href="https://github.com/mbi/django-simple-captcha" target="_blank" rel="noopener">官网</a></li><li>django-simple-spam-blocker：一个用于 Django 的简单的电子垃圾屏蔽工具。<a href="https://github.com/moqada/django-simple-spam-blocker" target="_blank" rel="noopener">官网</a></li></ul><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>用来进行标记的库。</p><ul><li>django-taggit：简单的 Django 标记工具。<a href="https://github.com/alex/django-taggit" target="_blank" rel="noopener">官网</a></li></ul><h3 id="管理面板"><a href="#管理面板" class="headerlink" title="管理面板"></a>管理面板</h3><p>管理界面库。</p><ul><li>Ajenti：一个你的服务器值得拥有的管理面板。<a href="https://github.com/ajenti/ajenti" target="_blank" rel="noopener">官网</a></li><li>django-suit：Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。<a href="http://djangosuit.com/" target="_blank" rel="noopener">官网</a></li><li>django-xadmin：Django admin 的一个替代品，具有很多不错的功能。<a href="https://github.com/sshwsfc/django-xadmin" target="_blank" rel="noopener">官网</a></li><li>flask-admin：一个用于 Flask 的简单可扩展的管理界面框架。<a href="https://github.com/flask-admin/flask-admin" target="_blank" rel="noopener">官网</a></li><li>flower：一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。<a href="https://github.com/mher/flower" target="_blank" rel="noopener">官网</a></li><li>Grappelli：Django 管理界面的一个漂亮的皮肤。<a href="http://grappelliproject.com/" target="_blank" rel="noopener">官网</a> </li><li>Wooey：一个 Django 应用，可以为 Python 脚本创建 web 用户界面。<a href="https://github.com/wooey/wooey" target="_blank" rel="noopener">官网</a></li></ul><h3 id="静态站点生成器"><a href="#静态站点生成器" class="headerlink" title="静态站点生成器"></a>静态站点生成器</h3><p>静态站点生成器是一个软件，它把文本和模板作为输入，然后输出 HTML 文件。</p><ul><li>Pelican：使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。<a href="http://blog.getpelican.com/" target="_blank" rel="noopener">官网</a></li><li>Cactus：为设计师设计的静态站点生成器。<a href="https://github.com/koenbok/Cactus/" target="_blank" rel="noopener">官网</a> </li><li>Hyde：基于 Jinja2 的静态站点生成器。<a href="http://hyde.github.io/" target="_blank" rel="noopener">官网</a></li><li>Nikola：一个静态网站和博客生成器。<a href="https://www.getnikola.com/" target="_blank" rel="noopener">官网</a></li><li>Tinkerer：Tinkerer 是一个博客引擎/静态站点生成器，由 Sphinx 驱动。<a href="http://tinkerer.me/" target="_blank" rel="noopener">官网</a></li><li>Lektor：一个简单易用的静态 CMS 和博客引擎。<a href="https://www.getlektor.com/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进程启动及通信库。</p><ul><li>envoy：比 Python <a href="https://docs.python.org/2/library/subprocess.html" target="_blank" rel="noopener">subprocess</a> 模块更人性化。<a href="https://github.com/kennethreitz/envoy" target="_blank" rel="noopener">官网</a></li><li>sarge：另一 种 subprocess 模块的封装。<a href="http://sarge.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>sh：一个完备的 subprocess 替代库。<a href="https://github.com/amoffat/sh" target="_blank" rel="noopener">官网</a></li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>用以进行并发和并行操作的库。</p><ul><li>multiprocessing：(Python 标准库) 基于进程的“线程”接口。<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="noopener">官网</a></li><li>threading：(Python 标准库)更高层的线程接口。<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="noopener">官网</a></li><li>eventlet：支持 WSGI 的异步框架。<a href="http://eventlet.net/" target="_blank" rel="noopener">官网</a></li><li>gevent：一个基于协程的 Python 网络库，使用 <a href="https://github.com/python-greenlet/greenlet" target="_blank" rel="noopener">greenlet</a>。<a href="http://www.gevent.org/" target="_blank" rel="noopener">官网</a></li><li>Tomorrow：用于产生异步代码的神奇的装饰器语法实现。<a href="https://github.com/madisonmay/Tomorrow" target="_blank" rel="noopener">官网</a></li><li>uvloop：在 libuv 之上超快速实现 asyncio 事件循环。<a href="https://github.com/MagicStack/uvloop" target="_blank" rel="noopener">官网</a></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>用于网络编程的库。</p><ul><li>asyncio：(Python 标准库) 异步 I/O, 事件循环, 协程以及任务。<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/twisted/" target="_blank" rel="noopener">Twisted</a>：一个事件驱动的网络引擎。<a href="https://twistedmatrix.com/trac/" target="_blank" rel="noopener">官网</a></li><li>pulsar：事件驱动的并发框架。<a href="https://github.com/quantmind/pulsar" target="_blank" rel="noopener">官网</a></li><li>diesel：基于 Greenlet 的事件 I/O 框架。<a href="https://github.com/dieseldev/diesel" target="_blank" rel="noopener">官网</a></li><li>pyzmq：一个 ZeroMQ 消息库的 Python 封装。<a href="http://zeromq.github.io/pyzmq/" target="_blank" rel="noopener">官网</a></li><li>Toapi：一个轻巧，简单，快速的 Flask 库，致力于为所有网站提供 API 服务。<a href="https://github.com/gaojiuli/toapi" target="_blank" rel="noopener">官网</a></li><li>txZMQ：基于 Twisted 的 ZeroMQ 消息库的 Python 封装。<a href="https://github.com/smira/txZMQ" target="_blank" rel="noopener">官网</a></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>帮助使用 WebSocket 的库。</p><ul><li>AutobahnPython：给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">asyncio</a>。<a href="https://github.com/crossbario/autobahn-python" target="_blank" rel="noopener">官网</a></li><li>Crossbar：开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn)。<a href="https://github.com/crossbario/crossbar/" target="_blank" rel="noopener">官网</a></li><li>django-socketio：给 Django 用的 WebSockets。<a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="noopener">官网</a></li><li>WebSocket-for-Python：为 Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。<a href="https://github.com/Lawouach/WebSocket-for-Python" target="_blank" rel="noopener">官网</a></li></ul><h3 id="WSGI-服务器"><a href="#WSGI-服务器" class="headerlink" title="WSGI 服务器"></a>WSGI 服务器</h3><p>兼容 WSGI 的 web 服务器</p><ul><li>gunicorn：Pre-forked, 部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/gunicorn" target="_blank" rel="noopener">官网</a></li><li>uwsgi：uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。<a href="https://uwsgi-docs.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/bjoern/" target="_blank" rel="noopener">bjoern</a>：异步，非常快速，由 C 语言编写。<a href="https://pypi.python.org/pypi/bjoern" target="_blank" rel="noopener">官网</a></li><li>fapws3：异步 (仅对于网络端)，由 C 语言编写。<a href="http://www.fapws.org/" target="_blank" rel="noopener">官网</a></li><li>meinheld：异步，部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/meinheld" target="_blank" rel="noopener">官网</a></li><li>netius：异步，非常快速。<a href="https://github.com/hivesolutions/netius" target="_blank" rel="noopener">官网</a></li><li>paste：多线程，稳定，久经考验。<a href="http://pythonpaste.org/" target="_blank" rel="noopener">官网</a></li><li>rocket：多线程。<a href="https://pypi.python.org/pypi/rocket" target="_blank" rel="noopener">官网</a></li><li>waitress：多线程, 是它驱动着 Pyramid 框架。<a href="https://waitress.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Werkzeug：一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。<a href="http://werkzeug.pocoo.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="RPC-服务器"><a href="#RPC-服务器" class="headerlink" title="RPC 服务器"></a>RPC 服务器</h3><p>兼容 RPC 的服务器。</p><ul><li>SimpleJSONRPCServer：这个库是 JSON-RPC 规范的一个实现。<a href="https://github.com/joshmarshall/jsonrpclib/" target="_blank" rel="noopener">官网</a></li><li>SimpleXMLRPCServer：(Python 标准库) 简单的 XML-RPC 服务器实现，单线程。<a href="https://docs.python.org/2/library/simplexmlrpcserver.html" target="_blank" rel="noopener">官网</a></li><li>zeroRPC：zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。<a href="https://github.com/0rpc/zerorpc-python" target="_blank" rel="noopener">官网</a></li></ul><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul><li>cryptography：这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。<a href="https://cryptography.io/en/latest/" target="_blank" rel="noopener">官网</a></li><li>hashids：在 Python 中实现 <a href="http://hashids.org/" target="_blank" rel="noopener">hashids</a> 。<a href="https://github.com/davidaurelio/hashids-python" target="_blank" rel="noopener">官网</a></li><li>Paramiko：SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。<a href="http://www.paramiko.org/" target="_blank" rel="noopener">官网</a></li><li>Passlib：安全密码存储／哈希库，<a href="https://pythonhosted.org/passlib/" target="_blank" rel="noopener">官网</a></li><li>PyCrypto：Python 密码学工具箱。<a href="https://www.dlitz.net/software/pycrypto/" target="_blank" rel="noopener">官网</a></li><li>PyNacl：网络和密码学(NaCl) 库的 Python 绑定。<a href="https://github.com/pyca/pynacl" target="_blank" rel="noopener">官网</a></li></ul><h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><p>用来创建图形用户界面程序的库。</p><ul><li>curses：内建的 <a href="http://www.gnu.org/software/ncurses/" target="_blank" rel="noopener">ncurses</a> 封装，用来创建终端图形用户界面。<a href="https://docs.python.org/2/library/curses.html#module-curses" target="_blank" rel="noopener">官网</a></li><li>enaml：使用类似 QML 的 Declaratic 语法来创建美观的用户界面。<a href="https://github.com/nucleic/enaml" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/kivy/" target="_blank" rel="noopener">kivy</a>：一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS 平台上。<a href="https://kivy.org/" target="_blank" rel="noopener">官网</a></li><li>pyglet：一个 Python 的跨平台窗口及多媒体库。<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home" target="_blank" rel="noopener">官网</a></li><li>PyQt：跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="noopener">Qt</a> 的 Python 绑定 ，支持 Qt v4 和 Qt v5。<a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="noopener">官网</a></li><li>PySide：跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="noopener">Qt</a> 的 Python 绑定 ，支持 Qt v4。<a href="https://wiki.qt.io/PySide" target="_blank" rel="noopener">官网</a></li><li>Tkinter：Tkinter 是 Python GUI 的一个事实标准库。<a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="noopener">官网</a></li><li>Toga：一个 Python 原生的, 操作系统原生的 GUI 工具包。<a href="https://github.com/pybee/toga" target="_blank" rel="noopener">官网</a></li><li>urwid：一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。<a href="http://urwid.org/" target="_blank" rel="noopener">官网</a></li><li>wxPython：wxPython 是 wxWidgets C++ 类库和 Python 语言混合的产物。<a href="http://wxpython.org/" target="_blank" rel="noopener">官网</a></li><li>PyGObject：GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定。<a href="https://wiki.gnome.org/Projects/PyGObject" target="_blank" rel="noopener">官网</a></li><li>Flexx：Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。<a href="https://github.com/zoofIO/flexx" target="_blank" rel="noopener">官网</a></li></ul><h3 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h3><p>超赞的游戏开发库。</p><ul><li>Cocos2d：cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。<a href="http://cocos2d.org/" target="_blank" rel="noopener">官网</a></li><li>Panda3D：由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用 C++ 编写, 针对 Python 进行了完全的封装。<a href="https://www.panda3d.org/" target="_blank" rel="noopener">官网</a></li><li>Pygame：Pygame 是一组 Python 模块，用来编写游戏。<a href="http://www.pygame.org/news.html" target="_blank" rel="noopener">官网</a></li><li>PyOgre：Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。<a href="http://www.ogre3d.org/tikiwiki/PyOgre" target="_blank" rel="noopener">官网</a></li><li>PyOpenGL：OpenGL 的 Python 绑定及其相关 APIs。<a href="http://pyopengl.sourceforge.net/" target="_blank" rel="noopener">官网</a></li><li>PySDL2：SDL2 库的封装，基于 ctypes。<a href="http://pysdl2.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>RenPy：一个视觉小说（visual novel）引擎。<a href="https://www.renpy.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>用来生成和操作日志的库。</p><ul><li>logging：(Python 标准库) 为 Python 提供日志功能。<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">官网</a></li><li>logbook：Logging 库的替代品。<a href="http://pythonhosted.org/Logbook/" target="_blank" rel="noopener">官网</a></li><li>Eliot：为复杂的和分布式系统创建日志。<a href="https://eliot.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Raven：Sentry 的 Python 客户端。<a href="http://raven.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Sentry：实时记录和收集日志的服务器。<a href="https://pypi.python.org/pypi/sentry" target="_blank" rel="noopener">官网</a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>进行代码库测试和生成测试数据的库。</p><ul><li>测试框架<ul><li>unittest：(Python 标准库) 单元测试框架。<a href="https://docs.python.org/2/library/unittest.html" target="_blank" rel="noopener">官网</a></li><li>nose：nose 扩展了 unittest 的功能。<a href="https://nose.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>contexts：一个 Python 3.3+ 的 BDD 框架。受到 C# – Machine.Specifications 的启发。<a href="https://github.com/benjamin-hodgson/Contexts" target="_blank" rel="noopener">官网</a></li><li>hypothesis：Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。<a href="https://github.com/DRMacIver/hypothesis" target="_blank" rel="noopener">官网</a></li><li>mamba：Python 的终极测试工具， 拥护 BDD。<a href="http://nestorsalceda.github.io/mamba/" target="_blank" rel="noopener">官网</a></li><li>PyAutoGUI：PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。<a href="https://github.com/asweigart/pyautogui" target="_blank" rel="noopener">官网</a></li><li>pyshould：Should 风格的断言，基于 <a href="https://github.com/hamcrest/PyHamcrest" target="_blank" rel="noopener">PyHamcrest</a>。<a href="https://github.com/drslump/pyshould" target="_blank" rel="noopener">官网</a></li><li>pytest：一个成熟的全功能 Python 测试工具。<a href="http://pytest.org/latest/" target="_blank" rel="noopener">官网</a></li><li>green：干净，多彩的测试工具。<a href="https://github.com/CleanCut/green" target="_blank" rel="noopener">官网</a></li><li>pyvows：BDD 风格的测试工具，受 Vows.js 的启发。<a href="http://heynemann.github.io/pyvows/" target="_blank" rel="noopener">官网</a></li><li>Robot Framework：一个通用的自动化测试框架。<a href="https://github.com/robotframework/robotframework" target="_blank" rel="noopener">官网</a></li></ul></li><li>Web 测试<ul><li>Selenium：<a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a> WebDriver 的 Python 绑定。<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">官网</a></li><li>locust：使用 Python 编写的，可扩展的用户加载测试工具。<a href="https://github.com/locustio/locust" target="_blank" rel="noopener">官网</a></li><li>sixpack：一个和语言无关的 A/B 测试框架。<a href="https://github.com/seatgeek/sixpack" target="_blank" rel="noopener">官网</a></li><li>splinter：开源的 web 应用测试工具。<a href="https://splinter.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li><li>Mock 测试<ul><li>mock：(Python 标准库) 一个用于伪造测试的库。<a href="https://docs.python.org/3/library/unittest.mock.html" target="_blank" rel="noopener">官网</a></li><li>doublex：Python 的一个功能强大的 doubles  测试框架。<a href="https://pypi.python.org/pypi/doublex" target="_blank" rel="noopener">官网</a></li><li>freezegun：通过伪造日期模块来生成不同的时间。<a href="https://github.com/spulec/freezegun" target="_blank" rel="noopener">官网</a></li><li>httmock：针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。<a href="https://github.com/patrys/httmock" target="_blank" rel="noopener">官网</a></li><li>httpretty：Python 的 HTTP 请求 mock 工具。<a href="http://falcao.it/HTTPretty/" target="_blank" rel="noopener">官网</a></li><li>responses：伪造 Python 中的 requests 库的一个通用库。<a href="https://github.com/getsentry/responses" target="_blank" rel="noopener">官网</a></li><li>VCR.py：在你的测试中记录和重放 HTTP 交互。<a href="https://github.com/kevin1024/vcrpy" target="_blank" rel="noopener">官网</a></li></ul></li><li>对象工厂<ul><li>factoryboy：一个 Python 用的测试固件 (test fixtures) 替代库。<a href="https://github.com/rbarrois/factoryboy" target="_blank" rel="noopener">官网</a></li><li>mixer：另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。<a href="https://github.com/klen/mixer" target="_blank" rel="noopener">官网</a></li><li>modelmommy：为 Django 测试创建随机固件。<a href="https://github.com/vandersonmota/modelmommy" target="_blank" rel="noopener">官网</a></li></ul></li><li>代码覆盖率<ul><li>coverage：代码覆盖率测量。<a href="https://pypi.python.org/pypi/coverage" target="_blank" rel="noopener">官网</a></li><li>Codecov：一个代码覆盖率测试工具，为开源项目提供免费代码覆盖率测试服务。<a href="https://codecov.io/" target="_blank" rel="noopener">官网</a></li></ul></li><li>伪数据<ul><li>faker：一个 Python 库，用来生成伪数据。<a href="http://www.joke2k.net/faker/" target="_blank" rel="noopener">官网</a></li><li>fake2db：伪数据库生成器。<a href="https://github.com/emirozer/fake2db" target="_blank" rel="noopener">官网</a></li><li>radar：生成随机的日期/时间。<a href="https://pypi.python.org/pypi/radar" target="_blank" rel="noopener">官网</a></li></ul></li><li>错误处理<ul><li>FuckIt.py：FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。<a href="https://github.com/ajalt/fuckitpy" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="代码分析和-Lint-工具"><a href="#代码分析和-Lint-工具" class="headerlink" title="代码分析和 Lint 工具"></a>代码分析和 Lint 工具</h3><p>进行代码分析，解析和操作代码库的库和工具。</p><ul><li>代码分析<ul><li>coala：语言独立和易于扩展的代码分析应用程序。<a href="http://coala-analyzer.org/" target="_blank" rel="noopener">官网</a></li><li>code2flow：把你的 Python 和 JavaScript 代码转换为流程图。<a href="https://github.com/scottrogowski/code2flow" target="_blank" rel="noopener">官网</a></li><li>pycallgraph：这个库可以把你的 Python 应用的流程(调用图)进行可视化。<a href="https://github.com/gak/pycallgraph" target="_blank" rel="noopener">官网</a></li><li>pysonar2：Python 类型推断和检索工具。<a href="https://github.com/yinwang0/pysonar2" target="_blank" rel="noopener">官网</a></li></ul></li><li>Lint 工具<ul><li>Flake8：模块化源码检查工具: pep8, pyflakes 以及 co。<a href="https://pypi.python.org/pypi/flake8" target="_blank" rel="noopener">官网</a></li><li>Pylint：一个完全可定制的源码分析器。<a href="https://www.pylint.org/" target="_blank" rel="noopener">官网</a></li><li>YAPF: Google 的 Python 代码格式化工具。<a href="https://github.com/google/yapf" target="_blank" rel="noopener">官网</a></li><li>pylama：Python 和 JavaScript 的代码审查工具。<a href="https://pylama.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li></ul></li><li>代码格式化<ul><li>autopep8：自动格式化 Python 代码，以使其符合 PEP8 规范。<a href="https://github.com/hhatto/autopep8" target="_blank" rel="noopener">官网</a></li><li>black：一个坚定的 Python 代码格式化工具。<a href="https://github.com/ambv/black" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>用来进行代码调试的库。</p><ul><li>调试器<ul><li>ipdb：IPython 启用的 <a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="noopener">pdb</a>。<a href="https://pypi.python.org/pypi/ipdb" target="_blank" rel="noopener">官网</a></li><li>pudb：全屏，基于控制台的 Python 调试器。<a href="https://pypi.python.org/pypi/pudb" target="_blank" rel="noopener">官网</a></li><li>pyringe：可以在 Python 进程中附加和注入代码的调试器。<a href="https://github.com/google/pyringe" target="_blank" rel="noopener">官网</a></li><li>wdb：一个奇异的 web 调试器，通过 WebSockets 工作。<a href="https://github.com/Kozea/wdb" target="_blank" rel="noopener">官网</a></li><li>winpdb：一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。<a href="http://winpdb.org/" target="_blank" rel="noopener">官网</a></li><li>django-debug-toolbar：为 Django 显示各种调试信息。<a href="https://github.com/django-debug-toolbar/django-debug-toolbar" target="_blank" rel="noopener">官网</a></li><li>django-devserver：一个 Django 运行服务器的替代品。<a href="https://github.com/dcramer/django-devserver" target="_blank" rel="noopener">官网</a></li><li>flask-debugtoolbar：django-debug-toolbar 的 flask 版。<a href="https://github.com/mgood/flask-debugtoolbar" target="_blank" rel="noopener">官网</a></li></ul></li><li>性能分析器<ul><li>lineprofiler：逐行性能分析。<a href="https://github.com/rkern/lineprofiler" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/memory_profiler/" target="_blank" rel="noopener">Memory Profiler</a>：监控 Python 代码的内存使用。<a href="http://pypi.python.org/pypi/memory_profiler" target="_blank" rel="noopener">官网</a>、<a href="https://github.com/fabianp/memoryprofiler" target="_blank" rel="noopener">内存</a></li><li>profiling：一个交互式 Python 性能分析工具。<a href="https://github.com/what-studio/profiling" target="_blank" rel="noopener">官网</a></li></ul></li><li>其他<ul><li>pyelftools：解析和分析 ELF 文件以及 DWARF 调试信息。<a href="https://github.com/eliben/pyelftools" target="_blank" rel="noopener">官网</a></li><li>python-statsd：<a href="https://github.com/etsy/statsd/" target="_blank" rel="noopener">statsd</a> 服务器的 Python 客户端。<a href="https://github.com/WoLpH/python-statsd" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="科学计算和数据分析"><a href="#科学计算和数据分析" class="headerlink" title="科学计算和数据分析"></a>科学计算和数据分析</h3><p>用来进行科学计算和数据分析的库。</p><ul><li>astropy：一个天文学 Python 库。<a href="http://www.astropy.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/bcbio-nextgen/" target="_blank" rel="noopener">bcbio-nextgen</a>：这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。<a href="https://github.com/chapmanb/bcbio-nextgen" target="_blank" rel="noopener">官网</a></li><li>bccb：生物分析相关代码集合。<a href="https://github.com/chapmanb/bcbb" target="_blank" rel="noopener">官网</a></li><li>Biopython：Biopython 是一组可以免费使用的用来进行生物计算的工具。<a href="http://biopython.org/wiki/MainPage" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/blaze/" target="_blank" rel="noopener">blaze</a>：NumPy 和 Pandas 的大数据接口。<a href="http://blaze.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/cclib/" target="_blank" rel="noopener">cclib</a>：一个用来解析和解释计算化学软件包输出结果的库。<a href="http://cclib.github.io/" target="_blank" rel="noopener">官网</a></li><li>NetworkX：一个为复杂网络设计的高性能软件。<a href="https://networkx.github.io/" target="_blank" rel="noopener">官网</a></li><li>Neupy：执行和测试各种不同的人工神经网络算法。<a href="http://neupy.com/pages/home.html" target="_blank" rel="noopener">官网</a></li><li>Numba：Python JIT (just in time) 编译器，针对科学用的 Python ，由 Cython 和 NumPy 的开发者开发。<a href="http://numba.pydata.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/numpy/" target="_blank" rel="noopener">NumPy</a>：使用 Python 进行科学计算的基础包。<a href="http://www.numpy.org/" target="_blank" rel="noopener">官网</a></li><li>Open Babel：一个化学工具箱，用来描述多种化学数据。<a href="http://openbabel.org/wiki/MainPage" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/open-mining/" target="_blank" rel="noopener">Open Mining</a>：使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。<a href="https://github.com/mining/mining" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/orange/" target="_blank" rel="noopener">orange</a>：通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。<a href="http://orange.biolab.si/" target="_blank" rel="noopener">官网</a></li><li>Pandas：提供高性能，易用的数据结构和数据分析工具。<a href="http://pandas.pydata.org/" target="_blank" rel="noopener">官网</a></li><li>PyDy：PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。<a href="http://www.pydy.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pymc/" target="_blank" rel="noopener">PyMC</a>：马尔科夫链蒙特卡洛采样工具。<a href="https://github.com/pymc-devs/pymc3" target="_blank" rel="noopener">官网</a></li><li>RDKit：化学信息学和机器学习软件。<a href="http://www.rdkit.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/scipy/" target="_blank" rel="noopener">SciPy</a>：由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。<a href="http://www.scipy.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/statsmodels/" target="_blank" rel="noopener">statsmodels</a>：统计建模和计量经济学。<a href="https://github.com/statsmodels/statsmodels" target="_blank" rel="noopener">官网</a></li><li>SymPy：一个用于符号数学的 Python 库。<a href="https://github.com/sympy/sympy" target="_blank" rel="noopener">官网</a></li><li>zipline：一个 Python 算法交易库。<a href="https://github.com/quantopian/zipline" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/bayesian-belief-networks/" target="_blank" rel="noopener">Bayesian-belief-networks</a>：优雅的贝叶斯信念网络框架。<a href="https://github.com/eBay/bayesian-belief-networks" target="_blank" rel="noopener">官网</a></li></ul><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>进行数据可视化的库。 参见: <a href="https://github.com/sorrycc/awesome-javascript#data-visualization" target="_blank" rel="noopener">awesome-javascript</a>。</p><ul><li>matplotlib：一个 Python 2D 绘图库。<a href="http://matplotlib.org/" target="_blank" rel="noopener">官网</a></li><li>bokeh：用 Python 进行交互式 web 绘图。<a href="https://github.com/bokeh/bokeh" target="_blank" rel="noopener">官网</a></li><li>ggplot：ggplot2 给 R 提供的 API 的 Python 版本。<a href="https://github.com/yhat/ggplot" target="_blank" rel="noopener">官网</a></li><li>plotly：协同 Python 和 matplotlib 工作的 web 绘图库。<a href="https://plot.ly/python/" target="_blank" rel="noopener">官网</a></li><li>pyecharts：基于百度 Echarts 的数据可视化库。<a href="https://github.com/chenjiandongx/pyecharts" target="_blank" rel="noopener">官网</a></li><li>pygal：一个 Python SVG 图表创建工具。<a href="http://www.pygal.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>pygraphviz：Graphviz 的 Python 接口。<a href="https://pypi.python.org/pypi/pygraphviz" target="_blank" rel="noopener">官网</a></li><li>PyQtGraph：交互式实时 2D/3D/ 图像绘制及科学/工程学组件。<a href="http://www.pyqtgraph.org/" target="_blank" rel="noopener">官网</a></li><li>SnakeViz：一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。<a href="http://jiffyclub.github.io/snakeviz/" target="_blank" rel="noopener">官网</a></li><li>vincent：把 Python 转换为 Vega 语法的转换工具。<a href="https://github.com/wrobstory/vincent" target="_blank" rel="noopener">官网</a></li><li>VisPy：基于 OpenGL 的高性能科学可视化工具。<a href="http://vispy.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>计算机视觉库。</p><ul><li>OpenCV：开源计算机视觉库。<a href="http://opencv.org/" target="_blank" rel="noopener">官网</a></li><li>pyocr：Tesseract 和 Cuneiform 的包装库。<a href="https://github.com/jflesch/pyocr" target="_blank" rel="noopener">官网</a></li><li>pytesseract：<a href="https://github.com/tesseract-ocr" target="_blank" rel="noopener">Google Tesseract OCR</a> 的另一包装库。<a href="https://github.com/madmaze/pytesseract" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/simplecv/" target="_blank" rel="noopener">SimpleCV</a>：一个用来创建计算机视觉应用的开源框架。<a href="http://simplecv.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习库。 参见: <a href="https://github.com/josephmisiti/awesome-machine-learning#python" target="_blank" rel="noopener">awesome-machine-learning</a>.</p><ul><li>Caffe: 一个 <a href="https://github.com/BVLC/caffe" target="_blank" rel="noopener">Caffe</a> 的 python 接口。<a href="http://caffe.berkeleyvision.org" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/caffe2/caffe2/" target="_blank" rel="noopener">Caffe2</a>：一个轻量级的，模块化的，可扩展的深度学习框架。<a href="https://caffe2.ai/" target="_blank" rel="noopener">官网</a></li><li>Crab：灵活、快速的推荐引擎。<a href="https://github.com/muricoca/crab" target="_blank" rel="noopener">官网</a></li><li>gensim：人性化的话题建模库。<a href="https://github.com/piskvorky/gensim" target="_blank" rel="noopener">官网</a></li><li>hebel：GPU 加速的深度学习库。<a href="https://github.com/hannes-brt/hebel" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/keras-team/keras" target="_blank" rel="noopener">keras</a>: 以 tensorflow/theano/CNTK 为后端的深度学习封装库，快速上手神经网络。<a href="https://keras.io/" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="noopener">MXNet</a>：一个高效和灵活的深度学习框架。<a href="http://mxnet.incubator.apache.org/" target="_blank" rel="noopener">官网</a></li><li>NuPIC：智能计算 Numenta 平台。<a href="https://github.com/numenta/nupic" target="_blank" rel="noopener">官网</a></li><li>pattern：Python 网络挖掘模块。<a href="https://github.com/clips/pattern" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pybrain/" target="_blank" rel="noopener">PyBrain</a>：另一个 Python 机器学习库。<a href="https://github.com/pybrain/pybrain" target="_blank" rel="noopener">官网</a></li><li>pydeep：Python 深度学习库。<a href="https://github.com/andersbll/deeppy" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pylearn2/" target="_blank" rel="noopener">Pylearn2</a>：一个基于 <a href="https://github.com/Theano/Theano" target="_blank" rel="noopener">Theano</a> 的机器学习库。<a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-recsys/" target="_blank" rel="noopener">python-recsys</a>：一个用来实现推荐系统的 Python 库。<a href="https://github.com/ocelma/python-recsys" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/pytorch/pytorch" target="_blank" rel="noopener">Pytorch</a>：一个具有张量和动态神经网络，并有强大 GPU 加速能力的深度学习框架。<a href="http://pytorch.org/" target="_blank" rel="noopener">官网</a></li><li>scikit-learn：基于 SciPy 构建的机器学习 Python 模块。<a href="http://scikit-learn.org/" target="_blank" rel="noopener">官网</a></li><li>skflow：一个 <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow</a> 的简化接口(模仿 scikit-learn)。<a href="https://github.com/tensorflow/skflow" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow</a>：谷歌开源的最受欢迎的深度学习框架。<a href="http://tensorflow.org/" target="_blank" rel="noopener">官网</a></li><li>Theano：一个快速数值计算库。<a href="https://github.com/Theano/Theano" target="_blank" rel="noopener">官网</a></li><li>vowpalporpoise：轻量级 <a href="https://github.com/JohnLangford/vowpalwabbit/" target="_blank" rel="noopener">Vowpal Wabbit</a> 的 Python 封装。<a href="https://github.com/josephreisinger/vowpalporpoise" target="_blank" rel="noopener">官网</a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce 框架和库。</p><ul><li><a href="http://hao.jobbole.com/dpark/" target="_blank" rel="noopener">dpark</a>：Spark 的 Python 克隆版，一个类似 MapReduce 的框架。<a href="https://github.com/douban/dpark" target="_blank" rel="noopener">官网</a></li><li>dumbo：这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。<a href="https://github.com/klbostee/dumbo" target="_blank" rel="noopener">官网</a></li><li>luigi：这个模块帮你构建批处理作业的复杂流水线。<a href="https://github.com/spotify/luigi" target="_blank" rel="noopener">官网</a></li><li>mrjob：在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。<a href="https://github.com/Yelp/mrjob" target="_blank" rel="noopener">官网</a></li><li>PySpark：Spark 的 Python API 。<a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="noopener">官网</a></li><li>streamparse：运行针对事实数据流的 Python 代码。集成了 <a href="http://storm.apache.org/" target="_blank" rel="noopener">Apache Storm</a>。<a href="https://github.com/Parsely/streamparse" target="_blank" rel="noopener">官网</a></li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>使用 Python 进行函数式编程。</p><ul><li>CyToolz：Toolz 的 Cython 实现 : 高性能函数式工具。<a href="https://github.com/pytoolz/cytoolz/" target="_blank" rel="noopener">官网</a></li><li>fn.py：在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。<a href="https://github.com/kachayev/fn.py" target="_blank" rel="noopener">官网</a></li><li>funcy：炫酷又实用的函数式工具。<a href="https://github.com/Suor/funcy" target="_blank" rel="noopener">官网</a></li><li>Toolz：一组用于迭代器，函数和字典的函数式编程工具。<a href="https://github.com/pytoolz/toolz" target="_blank" rel="noopener">官网</a></li></ul><h3 id="第三方-API"><a href="#第三方-API" class="headerlink" title="第三方 API"></a>第三方 API</h3><p>用来访问第三方 API 的库。 参见： <a href="https://github.com/realpython/list-of-python-api-wrappers" target="_blank" rel="noopener">List of Python API Wrappers and Libraries</a>。</p><ul><li>apache-libcloud：一个为各种云设计的 Python 库。<a href="https://libcloud.apache.org/" target="_blank" rel="noopener">官网</a></li><li>boto：Amazon Web Services 的 Python 接口。<a href="https://github.com/boto/boto" target="_blank" rel="noopener">官网</a></li><li>django-wordpress：WordPress models and views for Django.<a href="https://github.com/sunlightlabs/django-wordpress/" target="_blank" rel="noopener">官网</a></li><li>facebook-sdk：Facebook 平台的 Python SDK.<a href="https://github.com/mobolic/facebook-sdk" target="_blank" rel="noopener">官网</a></li><li>facepy：Facepy 让和 Facebook’s Graph API 的交互变得更容易。<a href="https://github.com/jgorset/facepy" target="_blank" rel="noopener">官网</a></li><li>gmail：Gmail 的 Python 接口。<a href="https://github.com/charlierguo/gmail" target="_blank" rel="noopener">官网</a></li><li>google-api-python-client：Python 用的 Google APIs 客户端库。<a href="https://github.com/google/google-api-python-client" target="_blank" rel="noopener">官网</a></li><li>gspread：Google 电子表格的 Python API.<a href="https://github.com/burnash/gspread" target="_blank" rel="noopener">官网</a></li><li>twython：Twitter API 的封装。<a href="https://github.com/ryanmcgrath/twython" target="_blank" rel="noopener">官网</a></li></ul><h3 id="DevOps-工具"><a href="#DevOps-工具" class="headerlink" title="DevOps 工具"></a>DevOps 工具</h3><p>用于 DevOps 的软件和库。</p><ul><li>Ansible：一个非常简单的 IT 自动化平台。<a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">官网</a></li><li>SaltStack：基础设施自动化和管理系统。<a href="https://github.com/saltstack/salt" target="_blank" rel="noopener">官网</a></li><li>OpenStack：用于构建私有和公有云的开源软件。<a href="http://www.openstack.org/" target="_blank" rel="noopener">官网</a></li><li>Docker Compose：快速，分离的开发环境，使用 Docker。<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">官网</a></li><li>Fabric：一个简单的，Python 风格的工具，用来进行远程执行和部署。<a href="http://www.fabfile.org/" target="_blank" rel="noopener">官网</a></li><li>cuisine：为 Fabric 提供一系列高级函数。<a href="https://github.com/sebastien/cuisine" target="_blank" rel="noopener">官网</a></li><li>Fabtools：一个用来编写超赞的 Fabric 文件的工具。<a href="https://github.com/ronnix/fabtools" target="_blank" rel="noopener">官网</a></li><li>gitapi：Git 的纯 Python API。<a href="https://bitbucket.org/haard/gitapi" target="_blank" rel="noopener">官网</a></li><li>hgapi：Mercurial 的纯 Python API。<a href="https://bitbucket.org/haard/hgapi" target="_blank" rel="noopener">官网</a></li><li>honcho：<a href="https://github.com/ddollar/foreman" target="_blank" rel="noopener">Foreman</a> 的 Python 克隆版，用来管理基于 <a href="https://devcenter.heroku.com/articles/procfile" target="_blank" rel="noopener">Procfile</a> 的应用。<a href="https://github.com/nickstenning/honcho" target="_blank" rel="noopener">官网</a></li><li>pexpect：Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。<a href="https://github.com/pexpect/pexpect" target="_blank" rel="noopener">官网</a></li><li>psutil：一个跨平台进程和系统工具模块。<a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">官网</a></li><li>supervisor：UNIX 的进程控制系统。<a href="https://github.com/Supervisor/supervisor" target="_blank" rel="noopener">官网</a></li></ul><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度库。</p><ul><li>APScheduler：轻巧但强大的进程内任务调度，使你可以调度函数。<a href="http://apscheduler.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>django-schedule：一个 Django 排程应用。<a href="https://github.com/thauber/django-schedule" target="_blank" rel="noopener">官网</a></li><li>doit：一个任务执行和构建工具。<a href="http://pydoit.org/" target="_blank" rel="noopener">官网</a></li><li>gunnery：分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。<a href="https://github.com/gunnery/gunnery" target="_blank" rel="noopener">官网</a></li><li>Joblib：一组为 Python 提供轻量级作业流水线的工具。<a href="http://pythonhosted.org/joblib/index.html" target="_blank" rel="noopener">官网</a></li><li>Plan：如有神助地编写 crontab 文件。<a href="https://github.com/fengsp/plan" target="_blank" rel="noopener">官网</a></li><li>schedule：人性化的 Python 任务调度库。<a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">官网</a></li><li>Spiff：使用纯 Python 实现的强大的工作流引擎。<a href="https://github.com/knipknap/SpiffWorkflow" target="_blank" rel="noopener">官网</a></li><li>TaskFlow：一个可以让你方便执行任务的 Python 库，一致并且可靠。<a href="http://docs.openstack.org/developer/taskflow/" target="_blank" rel="noopener">官网</a></li><li>AirFlow：Airflow 是Airbnb公司开源的，是一个工作流分配管理系统，通过有向非循环图的方式管理任务流程，设置任务依赖关系和时间调度。<a href="https://airflow.incubator.apache.org/" target="_blank" rel="noopener">官方</a></li></ul><h3 id="外来函数接口"><a href="#外来函数接口" class="headerlink" title="外来函数接口"></a>外来函数接口</h3><p>使用外来函数接口的库。</p><ul><li>cffi：用来调用 C 代码的外来函数接口。<a href="https://pypi.python.org/pypi/cffi" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/ctypes/" target="_blank" rel="noopener">ctypes</a>：(Python 标准库) 用来调用 C 代码的外来函数接口。<a href="https://docs.python.org/2/library/ctypes.html" target="_blank" rel="noopener">官网</a></li><li>PyCUDA：Nvidia CUDA API 的封装。<a href="https://mathema.tician.de/software/pycuda/" target="_blank" rel="noopener">官网</a></li><li>SWIG：简化的封装和接口生成器。<a href="http://www.swig.org/Doc1.3/Python.html" target="_blank" rel="noopener">官网</a></li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>让 Python 更快的库。</p><ul><li>Cython：优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。<a href="http://cython.org/" target="_blank" rel="noopener">官网</a></li><li>PeachPy：嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。<a href="https://github.com/Maratyszcza/PeachPy" target="_blank" rel="noopener">官网</a></li><li>PyPy：使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。<a href="http://pypy.org/" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/pyston-llvm-jit/" target="_blank" rel="noopener">Pyston</a>：使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。<a href="https://github.com/dropbox/pyston" target="_blank" rel="noopener">官网</a></li><li>Stackless Python：一个强化版的 Python。<a href="https://bitbucket.org/stackless-dev/stackless/overview" target="_blank" rel="noopener">官网</a></li></ul><h3 id="微软的-Windows-平台"><a href="#微软的-Windows-平台" class="headerlink" title="微软的 Windows 平台"></a>微软的 Windows 平台</h3><p>在 Windows 平台上进行 Python 编程。</p><ul><li>Python(x,y)：面向科学应用的 Python 发行版，基于 Qt 和 Spyder。<a href="http://python-xy.github.io/" target="_blank" rel="noopener">官网</a></li><li>pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">官网</a></li><li>PythonNet：Python 与 .NET 公共语言运行库 (CLR)的集成。<a href="https://github.com/pythonnet/pythonnet" target="_blank" rel="noopener">官网</a></li><li>PyWin32：针对 Windows 的 Python 扩展。<a href="https://sourceforge.net/projects/pywin32/" target="_blank" rel="noopener">官网</a></li><li>WinPython：Windows 7/8 系统下便携式开发环境。<a href="https://winpython.github.io/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="网络可视化和-SDN"><a href="#网络可视化和-SDN" class="headerlink" title="网络可视化和 SDN"></a>网络可视化和 SDN</h3><p>用来进行网络可视化和 SDN(软件定义网络)的工具和库。</p><ul><li>Mininet：一款流行的网络模拟器以及用 Python 编写的 API。<a href="http://mininet.org/" target="_blank" rel="noopener">官网</a></li><li>POX：一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。<a href="https://github.com/noxrepo/pox" target="_blank" rel="noopener">官网</a></li><li>Pyretic：火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。<a href="http://frenetic-lang.org/pyretic/" target="_blank" rel="noopener">官网</a></li><li>SDX Platform：基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。<a href="https://github.com/sdn-ixp/internet2award" target="_blank" rel="noopener">官网</a></li><li>NRU：一个基于组件的软件定义网络框架。<a href="http://ryu.readthedocs.io/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>用来对硬件进行编程的库。</p><ul><li>ino：操作 <a href="https://www.arduino.cc/" target="_blank" rel="noopener">Arduino</a> 的命令行工具。<a href="http://inotool.org/" target="_blank" rel="noopener">官网</a> </li><li>Pyro：Python 机器人编程库。<a href="http://pyrorobotics.com/" target="_blank" rel="noopener">官网</a></li><li>PyUserInput：跨平台的，控制鼠标和键盘的模块。<a href="https://github.com/SavinaRoja/PyUserInput" target="_blank" rel="noopener">官网</a></li><li>scapy：一个非常棒的操作数据包的库。<a href="https://github.com/secdev/scapy" target="_blank" rel="noopener">官网</a></li><li>wifi：一个 Python 库和命令行工具用来在 Linux 平台上操作 WiFi。<a href="https://wifi.readthedocs.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li>Pingo：Pingo 为类似 Raspberry Pi，pcDuino， Intel Galileo 等设备提供统一的 API 用以编程。<a href="http://www.pingo.io/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>帮助从 Python 2 向 Python 3 迁移的库。</p><ul><li>Python-Future：这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。<a href="http://python-future.org/index.html" target="_blank" rel="noopener">官网</a></li><li>Python-Modernize：使 Python 代码更加现代化以便最终迁移到 Python 3。<a href="https://github.com/mitsuhiko/python-modernize" target="_blank" rel="noopener">官网</a></li><li>Six：Python 2 和 3 的兼容性工具。<a href="https://pypi.python.org/pypi/six" target="_blank" rel="noopener">官网</a></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>不属于上面任何一个类别，但是非常有用的库。</p><ul><li>blinker：一个快速的 Python 进程内信号/事件分发系统。<a href="https://github.com/jek/blinker" target="_blank" rel="noopener">官网</a></li><li>itsdangerous：一系列辅助工具用来将可信的数据传入不可信的环境。<a href="https://github.com/pallets/itsdangerous" target="_blank" rel="noopener">官网</a></li><li>pluginbase：一个简单但是非常灵活的 Python 插件系统。<a href="https://github.com/mitsuhiko/pluginbase" target="_blank" rel="noopener">官网</a></li><li>Pychievements：一个用来创建和追踪成就的 Python 框架。<a href="https://github.com/PacketPerception/pychievements" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/tryton/" target="_blank" rel="noopener">Tryton</a>：一个通用商务框架。<a href="http://www.tryton.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="算法和设计模式"><a href="#算法和设计模式" class="headerlink" title="算法和设计模式"></a>算法和设计模式</h3><p>Python 实现的算法和设计模式。</p><ul><li><a href="http://hao.jobbole.com/algorithms/" target="_blank" rel="noopener">algorithms</a>：一个 Python 算法模块。<a href="https://github.com/nryoung/algorithms" target="_blank" rel="noopener">官网</a> </li><li>python-patterns：Python 设计模式的集合。<a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">官网</a></li><li>sortedcontainers：快速，纯 Python 实现的 SortedList，SortedDict 和 SortedSet 类型。<a href="http://www.grantjenks.com/docs/sortedcontainers/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h3><p>编辑器和 IDE 的插件</p><ul><li>Emacs<ul><li>Elpy：Emacs Python 开发环境。<a href="https://github.com/jorgenschaefer/elpy" target="_blank" rel="noopener">官网</a></li></ul></li><li>Sublime Text<ul><li>SublimeJEDI：一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。<a href="https://github.com/srusskih/SublimeJEDI" target="_blank" rel="noopener">官网</a></li><li>Anaconda：Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。<a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="noopener">官网</a></li></ul></li><li>Vim<ul><li><a href="http://hao.jobbole.com/youcompleteme/" target="_blank" rel="noopener">YouCompleteMe</a>：引入基于 <a href="https://github.com/davidhalter/jedi" target="_blank" rel="noopener">Jedi</a> 的 Python 自动补全引擎。<a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">官网</a></li><li>Jedi-vim：绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。<a href="https://github.com/davidhalter/jedi-vim" target="_blank" rel="noopener">官网</a></li><li>Python-mode：将 Vim 变成 Python IDE 的一款多合一插件。<a href="https://github.com/klen/python-mode" target="_blank" rel="noopener">官网</a></li></ul></li><li>Visual Studio<ul><li>PTVS：Visual Studio 的 Python 工具。<a href="https://github.com/Microsoft/PTVS" target="_blank" rel="noopener">官网</a></li></ul></li></ul><h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>流行的 Python 集成开发环境。</p><ul><li>PyCharm：商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">官网</a></li><li>LiClipse：基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。<a href="http://www.liclipse.com/" target="_blank" rel="noopener">官网</a></li><li>Spyder：开源 Python IDE。<a href="https://github.com/spyder-ide/spyder" target="_blank" rel="noopener">官网</a></li></ul><h3 id="自动聊天工具"><a href="#自动聊天工具" class="headerlink" title="自动聊天工具"></a>自动聊天工具</h3><p>用于开发聊天机器人的库</p><ul><li>Errbot：最简单和最流行的聊天机器人用来实现自动聊天工具。<a href="http://errbot.io/en/latest/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在线工具和简化开发的 API 。</p><h3 id="金融数据"><a href="#金融数据" class="headerlink" title="金融数据"></a>金融数据</h3><ul><li>Tushare ：一个可以提供免费股票、基金、期货、港股等金融数据的 Python 开源数据。<a href="http://tushare.org" target="_blank" rel="noopener">官网</a></li><li>Ta-Lib ：金融数据技术分析库，可以依据原始金融数据计算各种技术指标,计算性能比较优异。<a href="https://www.ta-lib.org/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>参见: <a href="https://github.com/ciandcd/awesome-ciandcd#online-build-system" target="_blank" rel="noopener">awesome-CIandCD</a>.</p><ul><li>Travis CI：一个流行的工具，为你的开源和 <a href="https://travis-ci.com/" target="_blank" rel="noopener">私人</a> 项目提供持续集成服务。(仅支持 GitHub)<a href="https://travis-ci.org/" target="_blank" rel="noopener">官网</a></li><li>CircleCI：一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)<a href="https://circleci.com/" target="_blank" rel="noopener">官网</a></li><li>Vexor CI：一个为私人 app 提供持续集成的工具，支持按分钟付费。<a href="https://vexor.io/" target="_blank" rel="noopener">官网</a></li><li>Wercker：基于 Docker 平台，用来构建和部署微服务。<a href="http://wercker.com/" target="_blank" rel="noopener">官网</a></li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul><li>Codacy：自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。<a href="https://www.codacy.com/" target="_blank" rel="noopener">官网</a></li><li>QuantifiedCode：一个数据驱动、自动、持续的代码审查工具。<a href="https://www.quantifiedcode.com/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在这里可以找到新的 Python 库。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://www.reddit.com/r/python" target="_blank" rel="noopener">r/Python</a></li><li><a href="https://www.coolgithubprojects.com/" target="_blank" rel="noopener">CoolGithubProjects</a></li><li><a href="https://www.djangopackages.com/" target="_blank" rel="noopener">Django Packages</a></li><li><a href="http://www.fullstackpython.com/" target="_blank" rel="noopener">Full Stack Python</a></li><li><a href="http://python3wos.appspot.com/" target="_blank" rel="noopener">Python 3 Wall of Superpowers</a></li><li><a href="http://pythonhackers.com/open-source/" target="_blank" rel="noopener">Python Hackers</a></li><li><a href="https://python.zeef.com/alan.richmond" target="_blank" rel="noopener">Python ZEEF</a></li><li><a href="https://github.com/trending?l=python" target="_blank" rel="noopener">Trending Python repositories on GitHub today</a></li><li><a href="http://pypi-ranking.info/alltime" target="_blank" rel="noopener">PyPI Ranking</a></li></ul><h3 id="周刊"><a href="#周刊" class="headerlink" title="周刊"></a>周刊</h3><ul><li><a href="http://importpython.com/newsletter/" target="_blank" rel="noopener">Import Python Newsletter</a></li><li><a href="http://pycoders.com/" target="_blank" rel="noopener">Pycoder’s Weekly</a></li><li><a href="http://www.pythonweekly.com/" target="_blank" rel="noopener">Python Weekly</a></li></ul><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><ul><li><a href="https://twitter.com/codetengu" target="_blank" rel="noopener">@codetengu</a></li><li><a href="https://twitter.com/getpy" target="_blank" rel="noopener">@getpy</a></li><li><a href="https://twitter.com/planetpython" target="_blank" rel="noopener">@planetpython</a></li><li><a href="https://twitter.com/pycoders" target="_blank" rel="noopener">@pycoders</a></li><li><a href="https://twitter.com/pypi" target="_blank" rel="noopener">@pypi</a></li><li><a href="https://twitter.com/pythontrending" target="_blank" rel="noopener">@pythontrending</a></li><li><a href="https://twitter.com/PythonWeekly" target="_blank" rel="noopener">@PythonWeekly</a></li></ul><h3 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h3><ul><li><a href="http://hao.jobbole.com/scipy-lecture-notes/" target="_blank" rel="noopener">Scipy-lecture-notes</a>：如何用 Python 来做学术？<a href="https://github.com/scipy-lectures/scipy-lecture-notes" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/scientific-python-lectures/" target="_blank" rel="noopener">SScientific-python-lectures</a>：Python 科学计算的资料。<a href="https://github.com/jrjohansson/scientific-python-lectures" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/mario-level-1/" target="_blank" rel="noopener">Mario-Level-1</a>：用 Python 和 Pygame 写的超级马里奥第一关。<a href="https://github.com/justinmeister/Mario-Level-1" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-koans/" target="_blank" rel="noopener">Python Koans</a>：Python 的交互式学习工具。<a href="https://github.com/gregmalcolm/python_koans" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/minecraft-python/" target="_blank" rel="noopener">Minecraft</a>：用 python 写的 Minecraft 游戏。<a href="https://github.com/fogleman/Minecraft" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-pycrumbs/" target="_blank" rel="noopener">pycrumbs</a>：Python 资源大全。<a href="https://github.com/kirang89/pycrumbs/blob/master/pycrumbs.md" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-patterns/" target="_blank" rel="noopener">python-patterns</a>：使用 python 实现设计模式。<a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/python-projects/" target="_blank" rel="noopener">Projects</a>：Python 项目大集合。<a href="https://github.com/karan/Projects" target="_blank" rel="noopener">官网</a></li><li><a href="http://hao.jobbole.com/the-hitchhikers-guide-to-python/" target="_blank" rel="noopener">The Hitchhiker’s Guide to Python</a>：旅行者的 Python 学习指南。<a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="noopener">官网</a></li><li><a href="http://top.jobbole.com/18767/" target="_blank" rel="noopener">Code Like a Pythonista: Idiomatic Python</a>：如何像 Python 高手(Pythonista)一样编程。<a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" target="_blank" rel="noopener">官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-资源大全中文版&quot;&gt;&lt;a href=&quot;#Python-资源大全中文版&quot; class=&quot;headerlink&quot; title=&quot;Python 资源大全中文版&quot;&gt;&lt;/a&gt;Python 资源大全中文版&lt;/h1&gt;&lt;h2 id=&quot;关于项目&quot;&gt;&lt;a href=&quot;#关
      
    
    </summary>
    
      <category term="资源" scheme="http://yoursite.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Python3.x标准模块库目录</title>
    <link href="http://yoursite.com/2018/11/23/Python3-x%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97%E5%BA%93%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/11/23/Python3-x标准模块库目录/</id>
    <published>2018-11-23T07:28:16.000Z</published>
    <updated>2018-11-23T07:33:17.157Z</updated>
    
    <content type="html"><![CDATA[<p>Python3.x标准模块库目录</p><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><pre><code>1. string：通用字符串操作2. re：正则表达式操作3. difflib：差异计算工具4. textwrap：文本填充5. unicodedata：Unicode字符数据库6. stringprep：互联网字符串准备工具7. readline：GNU按行读取接口8. rlcompleter：GNU按行读取的实现函数</code></pre><h1 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h1><pre><code>9. struct：将字节解析为打包的二进制数据10. codecs：注册表与基类的编解码器</code></pre><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><pre><code>11. datetime：基于日期与时间工具12. calendar：通用月份函数13. collections：容器数据类型14. collections.abc：容器虚基类15. heapq：堆队列算法16. bisect：数组二分算法17. array：高效数值数组18. weakref：弱引用19. types：内置类型的动态创建与命名20. copy：浅拷贝与深拷贝21. pprint：格式化输出22. reprlib：交替repr()的实现</code></pre><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><pre><code>23. numbers：数值的虚基类24. math：数学函数25. cmath：复数的数学函数26. decimal：定点数与浮点数计算27. fractions：有理数28. random：生成伪随机数</code></pre><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><pre><code>29. itertools：为高效循环生成迭代器30. functools：可调用对象上的高阶函数与操作31. operator：针对函数的标准操作</code></pre><h1 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h1><pre><code>32. os.path：通用路径名控制33. fileinput：从多输入流中遍历行34. stat：解释stat()的结果35. filecmp：文件与目录的比较函数36. tempfile：生成临时文件与目录37. glob：Unix风格路径名格式的扩展38. fnmatch：Unix风格路径名格式的比对39. linecache：文本行的随机存储40. shutil：高级文件操作41. macpath：Mac OS 9路径控制函数</code></pre><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><pre><code>42. pickle：Python对象序列化43. copyreg：注册机对pickle的支持函数44. shelve：Python对象持久化45. marshal：内部Python对象序列化46. dbm：Unix“数据库”接口47. sqlite3：针对SQLite数据库的API 2.0</code></pre><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><pre><code>48. zlib：兼容gzip的压缩49. gzip：对gzip文件的支持50. bz2：对bzip2压缩的支持51. lzma：使用LZMA算法的压缩52. zipfile：操作ZIP存档53. tarfile：读写tar存档文件# 文件格式化54. csv：读写CSV文件55. configparser：配置文件解析器56. netrc：netrc文件处理器57. xdrlib：XDR数据编码与解码58. plistlib：生成和解析Mac OS X .plist文件</code></pre><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><pre><code>59. hashlib：安全散列与消息摘要60. hmac：针对消息认证的键散列</code></pre><h1 id="操作系统工具"><a href="#操作系统工具" class="headerlink" title="操作系统工具"></a>操作系统工具</h1><pre><code>61. os：多方面的操作系统接口62. io：流核心工具63. time：时间的查询与转化64. argparser：命令行选项、参数和子命令的解析器65. optparser：命令行选项解析器66. getopt：C风格的命令行选项解析器67. logging：Python日志工具68. logging.config：日志配置69. logging.handlers：日志处理器70. getpass：简易密码输入71. curses：字符显示的终端处理72. curses.textpad：curses程序的文本输入域73. curses.ascii：ASCII字符集工具74. curses.panel：curses的控件栈扩展75. platform：访问底层平台认证数据76. errno：标准错误记号77. ctypes：Python外部函数库</code></pre><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><pre><code>78. threading：基于线程的并行79. multiprocessing：基于进程的并行80. concurrent：并发包81. concurrent.futures：启动并行任务82. subprocess：子进程管理83. sched：事件调度84. queue：同步队列85. select：等待I/O完成86. dummy_threading：threading模块的替代（当_thread不可用时）87. _thread：底层的线程API（threading基于其上）88. _dummy_thread：_thread模块的替代（当_thread不可用时）</code></pre><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><pre><code>89. socket：底层网络接口90. ssl：socket对象的TLS/SSL填充器91. asyncore：异步套接字处理器92. asynchat：异步套接字命令/响应处理器93. signal：异步事务信号处理器94. mmap：内存映射文件支持</code></pre><h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><pre><code>95. email：邮件与MIME处理包96. json：JSON编码与解码97. mailcap：mailcap文件处理98. mailbox：多种格式控制邮箱99. mimetypes：文件名与MIME类型映射100. base64：RFC 3548：Base16、Base32、Base64编码101. binhex：binhex4文件编码与解码102. binascii：二进制码与ASCII码间的转化103. quopri：MIME quoted-printable数据的编码与解码104. uu：uuencode文件的编码与解码</code></pre><p>#　HTML与XML</p><pre><code>105. html：HTML支持106. html.parser：简单HTML与XHTML解析器107. html.entities：HTML通用实体的定义108. xml：XML处理模块109. xml.etree.ElementTree：树形XML元素API110. xml.dom：XML DOM API111. xml.dom.minidom：XML DOM最小生成树112. xml.dom.pulldom：构建部分DOM树的支持113. xml.sax：SAX2解析的支持114. xml.sax.handler：SAX处理器基类115. xml.sax.saxutils：SAX工具116. xml.sax.xmlreader：SAX解析器接口117. xml.parsers.expat：运用Expat快速解析XML</code></pre><h1 id="互联网协议与支持"><a href="#互联网协议与支持" class="headerlink" title="互联网协议与支持"></a>互联网协议与支持</h1><pre><code>118. webbrowser：简易Web浏览器控制器119. cgi：CGI支持120. cgitb：CGI脚本反向追踪管理器121. wsgiref：WSGI工具与引用实现122. urllib：URL处理模块123. urllib.request：打开URL连接的扩展库124. urllib.response：urllib模块的响应类125. urllib.parse：将URL解析成组件126. urllib.error：urllib.request引发的异常类127. urllib.robotparser：robots.txt的解析器128. http：HTTP模块129. http.client：HTTP协议客户端130. ftplib：FTP协议客户端131. poplib：POP协议客户端132. imaplib：IMAP4协议客户端133. nntplib：NNTP协议客户端134. smtplib：SMTP协议客户端135. smtpd：SMTP服务器136. telnetlib：Telnet客户端137. uuid：RFC4122的UUID对象138. socketserver：网络服务器框架139. http.server：HTTP服务器140. http.cookies：HTTPCookie状态管理器141. http.cookiejar：HTTP客户端的Cookie处理142. xmlrpc：XML-RPC服务器和客户端模块143. xmlrpc.client：XML-RPC客户端访问144. xmlrpc.server：XML-RPC服务器基础145. ipaddress：IPv4/IPv6控制库</code></pre><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><pre><code>146. audioop：处理原始音频数据147. aifc：读写AIFF和AIFC文件148. sunau：读写Sun AU文件149. wave：读写WAV文件150. chunk：读取IFF大文件151. colorsys：颜色系统间转化152. imghdr：指定图像类型153. sndhdr：指定声音文件类型154. ossaudiodev：访问兼容OSS的音频设备</code></pre><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><pre><code>155. gettext：多语言的国际化服务156. locale：国际化服务</code></pre><h1 id="编程框架"><a href="#编程框架" class="headerlink" title="编程框架"></a>编程框架</h1><pre><code>157. turtle：Turtle图形库158. cmd：基于行的命令解释器支持159. shlex：简单词典分析</code></pre><h1 id="Tk图形用户接口"><a href="#Tk图形用户接口" class="headerlink" title="Tk图形用户接口"></a>Tk图形用户接口</h1><pre><code>160. tkinter：Tcl/Tk接口161. tkinter.ttk：Tk主题控件162. tkinter.tix：Tk扩展控件163. tkinter.scrolledtext：滚轴文本控件</code></pre><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><pre><code>164. pydoc：文档生成器和在线帮助系统165. doctest：交互式Python示例166. unittest：单元测试框架167. unittest.mock：模拟对象库168. test：Python回归测试包169. test.support：Python测试工具套件170. venv：虚拟环境搭建</code></pre><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><pre><code>171. bdb：调试框架172. faulthandler：Python反向追踪库173. pdb：Python调试器174. timeit：小段代码执行时间测算175. trace：Python执行状态追踪</code></pre><h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><pre><code>176. sys：系统相关的参数与函数177. sysconfig：访问Python配置信息178. builtins：内置对象179. __main__：顶层脚本环境180. warnings：警告控制181. contextlib：with状态的上下文工具182. abc：虚基类183. atexit：出口处理器184. traceback：打印或读取一条栈的反向追踪185. __future__：未来状态定义186. gc：垃圾回收接口187. inspect：检查存活的对象188. site：址相关的配置钩子（hook）189. fpectl：浮点数异常控制190. distutils：生成和安装Python模块</code></pre><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><pre><code>191. code：基类解释器192. codeop：编译Python代码</code></pre><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><pre><code>193. imp：访问import模块的内部194. zipimport：从ZIP归档中导入模块195. pkgutil：包扩展工具196. modulefinder：通过脚本查找模块197. runpy：定位并执行Python模块198. importlib：import的一种实施</code></pre><h1 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h1><pre><code>199. parser：访问Python解析树200. ast：抽象句法树201. symtable：访问编译器符号表202. symbol：Python解析树中的常量203. token：Python解析树中的常量204. keyword：Python关键字测试205. tokenize：Python源文件分词206. tabnany：模糊缩进检测207. pyclbr：Python类浏览支持208. py_compile：编译Python源文件209. compileall：按字节编译Python库210. dis：Python字节码的反汇编器211. pickletools：序列化开发工具</code></pre><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><pre><code>212. formatter：通用格式化输出</code></pre><h1 id="Windows相关"><a href="#Windows相关" class="headerlink" title="Windows相关"></a>Windows相关</h1><pre><code>213. msilib：读写Windows Installer文件214. msvcrt：MS VC++ Runtime的有用程序215. winreg：Windows注册表访问216. winsound：Windows声音播放接口</code></pre><h1 id="Unix相关"><a href="#Unix相关" class="headerlink" title="Unix相关"></a>Unix相关</h1><pre><code>217. posix：最常用的POSIX调用218. pwd：密码数据库219. spwd：影子密码数据库220. grp：组数据库221. crypt：Unix密码验证222. termios：POSIX风格的tty控制223. tty：终端控制函数224. pty：伪终端工具225. fcntl：系统调用fcntl()和ioctl()226. pipes：shell管道接口227. resource：资源可用信息228. nis：Sun的NIS的接口229. syslog：Unix syslog程序库</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python3.x标准模块库目录&lt;/p&gt;
&lt;h1 id=&quot;文本&quot;&gt;&lt;a href=&quot;#文本&quot; class=&quot;headerlink&quot; title=&quot;文本&quot;&gt;&lt;/a&gt;文本&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. string：通用字符串操作

2. re：正则表达式操作

3. d
      
    
    </summary>
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Django之用户认证-auth模块</title>
    <link href="http://yoursite.com/2018/11/16/Django%E4%B9%8B%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81-auth%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/11/16/Django之用户认证-auth模块/</id>
    <published>2018-11-16T10:05:56.000Z</published>
    <updated>2018-11-18T12:31:59.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户认知———auth模块"><a href="#用户认知———auth模块" class="headerlink" title="用户认知———auth模块"></a>用户认知———auth模块</h1><blockquote><h3 id="一、auth模块"><a href="#一、auth模块" class="headerlink" title="一、auth模块"></a>一、auth模块</h3></blockquote><blockquote><p>from django.contrib import auth</p></blockquote><blockquote><h6 id="1、authenticate-：验证用户输入的用户名和密码是否相同"><a href="#1、authenticate-：验证用户输入的用户名和密码是否相同" class="headerlink" title="1、authenticate()：验证用户输入的用户名和密码是否相同"></a>1、authenticate()：验证用户输入的用户名和密码是否相同</h6><ul><li><p>提供了用户认证，即<strong>验证用户名以及密码是否正确</strong>,一般需要usernamepassword两个关键字参数</p></li><li><p>如果认证信息有效，会返回一个User对象。authenticate()会在User对象上设置一个属性标识，那</p><p>种认证，后端认证了该用户，且信息在后面的登录过程中是需要的。当我们试图登录一个从数据库</p><p>中直接取出来不经过authenticate()的User对象会报错的！！！</p></li></ul><h6 id="2、login-HttpRequest-user-登录"><a href="#2、login-HttpRequest-user-登录" class="headerlink" title="2、login(HttpRequest,user):登录"></a>2、login(HttpRequest,user):登录</h6><ul><li><p>该函数接受一个HttpRequest对象，以及一个认证的User对象</p></li><li><p>此函数使用django的session框架给每个已认证的用户附加上session id等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login</span><br><span class="line">&gt;     </span><br><span class="line">&gt;  <span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    username = request.POST[<span class="string">'username'</span>]</span><br><span class="line">&gt;    password = request.POST[<span class="string">'password'</span>]</span><br><span class="line">&gt;    user = authenticate(username=username, password=password)</span><br><span class="line">&gt;    <span class="keyword">if</span> user:</span><br><span class="line">&gt;      login(request, user)</span><br><span class="line">&gt;      <span class="comment"># Redirect to a success page.</span></span><br><span class="line">&gt;      ...</span><br><span class="line">&gt;    <span class="keyword">else</span>:</span><br><span class="line">&gt;      <span class="comment"># Return an 'invalid login' error message.</span></span><br><span class="line">&gt;      ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><h6 id="3、logout-request-注销用户"><a href="#3、logout-request-注销用户" class="headerlink" title="3、logout(request):注销用户"></a>3、logout(request):注销用户</h6><ul><li><p>该函数接受一个HttpRequest对象，无返回值，当调用该函数是时，当请求的session信息会全部</p><p>清除。该用户即使没有登录，使用该函数也不会登录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> logout</span><br><span class="line">&gt;     </span><br><span class="line">&gt;  <span class="function"><span class="keyword">def</span> <span class="title">logout_view</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    logout(request)</span><br><span class="line">&gt;    <span class="comment"># Redirect to a success page.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><h6 id="4、user对象的is-authenticated"><a href="#4、user对象的is-authenticated" class="headerlink" title="4、user对象的is_authenticated()"></a>4、user对象的is_authenticated()</h6><ul><li><p>要求</p><ul><li>用户登录后才能访问某些页面</li><li>如果用户没有登录就访问该页面的话直接跳转登录页面</li><li>用户在跳转的登录界面中完成登录后，自动访问跳转到之前访问的地址</li></ul></li><li><p>方法一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_authenticated():</span><br><span class="line">&gt;      <span class="keyword">return</span> redirect(<span class="string">'%s?next=%s'</span> % (settings.LOGIN_URL, request.path))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>方法二：django已经为我们设计好了一个用于次情况的装饰器：login_request()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line">&gt;        </span><br><span class="line">&gt;  @login_required</span><br><span class="line">&gt;  <span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p> 若用户没有登录，则会跳转到django默认的登录URL’/account/login’(这个值可以在settings文件中</p><p> 通过LOGIN_URL进行修改）。并传递当前访问url的绝对路径（登录成功后，会重定向该路径）</p></blockquote><blockquote><h3 id="二、User对象"><a href="#二、User对象" class="headerlink" title="二、User对象"></a>二、User对象</h3></blockquote><blockquote><ul><li><p>User对象属性：</p><ul><li>username</li><li>password（必填项）password用哈希算法保存到数据库</li><li>is_staff：用户是否拥有网站的管理权限</li><li>is_active：是否允许用户登录，设置为‘False’，可以不用删除用户来禁止用户登录</li></ul></li><li><p>is_authenticated()</p><ul><li><p>如果是真正的User对象，返回值恒为True。用于检测用户是否已经通过认证。</p></li><li><p>通过认证并不意味着用户拥有任何权限，甚至也不检查该用户是否处于激活状态，这只是表明</p><p>用户成功通过了认证。</p><ul><li>这个方法很重要，在后台使用</li><li>request.user.is_authenticated()判断用户是否已经登录，如果True则可以向前台展示</li><li>-request.user.name</li></ul></li></ul></li><li><p>创建用户<strong>create_user</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">&gt;  user = User.objects.create_user（username=<span class="string">''</span>,password=<span class="string">''</span>,email=<span class="string">''</span>）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>check_passw(passwd):密码检测</p><p>用户需要修改密码的时候 首先要让他输入原来的密码 ，如果给定的字符串通过了密码检查，返回 </p><p>True</p></li><li><p>修改密码：set_password()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  user = User.objects.get(username=<span class="string">''</span>)</span><br><span class="line">&gt;  user.set_password(password=<span class="string">''</span>)</span><br><span class="line">&gt;  user.save　</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote></blockquote><h3 id="三、简单实例"><a href="#三、简单实例" class="headerlink" title="三、简单实例"></a>三、简单实例</h3><blockquote><p>登录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">log_in</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    print(request.POST)</span><br><span class="line">&gt;    <span class="keyword">if</span> request.method ==<span class="string">"POST"</span>:</span><br><span class="line">&gt;        username = request.POST.get(<span class="string">"username"</span>)</span><br><span class="line">&gt;        password = request.POST.get(<span class="string">"password"</span>)</span><br><span class="line">&gt;        print(username,password)</span><br><span class="line">&gt;        user=auth.authenticate(username=username,password=password)<span class="comment">#验证用户名和密码</span></span><br><span class="line">&gt;        <span class="keyword">if</span> user:</span><br><span class="line">&gt;            <span class="comment">#如果认证成功，就让登录，这个login里面包括了session操作和cookie</span></span><br><span class="line">&gt;            auth.login(request,user)</span><br><span class="line">&gt;            <span class="keyword">return</span> redirect(<span class="string">"/chakan/"</span>)</span><br><span class="line">&gt;        <span class="keyword">else</span>:</span><br><span class="line">&gt;            s = <span class="string">"用户名和密码输入错误"</span></span><br><span class="line">&gt;            <span class="keyword">return</span> render(request,<span class="string">"login.html"</span>,&#123;<span class="string">"s"</span>:s&#125;)</span><br><span class="line">&gt;    <span class="keyword">return</span> render(request,<span class="string">"login.html"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>修改密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">set_pwd</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    <span class="keyword">if</span> request.method==<span class="string">"POST"</span>:</span><br><span class="line">&gt;        oldpassword = request.POST.get(<span class="string">"oldpassword"</span>)</span><br><span class="line">&gt;        newpassword = request.POST.get(<span class="string">"newpassword"</span>)</span><br><span class="line">&gt;        <span class="comment">#得到当前登录的用户，判断旧密码是不是和当前的密码一样</span></span><br><span class="line">&gt;        username = request.user  <span class="comment">#打印的是当前登录的用户名</span></span><br><span class="line">&gt;        user = User.objects.get(username=username)  <span class="comment">#查看用户</span></span><br><span class="line">&gt;        ret = user.check_password(oldpassword)  <span class="comment">#检查密码是否正确</span></span><br><span class="line">&gt;        <span class="keyword">if</span> ret:</span><br><span class="line">&gt;            user.set_password(newpassword) <span class="comment">#如果正确就给设置一个新密码</span></span><br><span class="line">&gt;            user.save()  <span class="comment">#保存</span></span><br><span class="line">&gt;            <span class="keyword">return</span> redirect(<span class="string">"/login/"</span>)</span><br><span class="line">&gt;        <span class="keyword">else</span>:</span><br><span class="line">&gt;            info = <span class="string">"输入密码有误"</span></span><br><span class="line">&gt;            <span class="keyword">return</span> render(request,<span class="string">"set_pwd.html"</span>,&#123;<span class="string">"info"</span>:info&#125;)</span><br><span class="line">&gt;    <span class="keyword">return</span> render(request,<span class="string">"set_pwd.html"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注册：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">reg</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    <span class="keyword">if</span> request.method==<span class="string">"POST"</span>:</span><br><span class="line">&gt;        username = request.POST.get(<span class="string">"username"</span>)</span><br><span class="line">&gt;        password = request.POST.get(<span class="string">"password"</span>)</span><br><span class="line">&gt;        <span class="comment">#得到用户输入的用户名和密码创建一个新用户</span></span><br><span class="line">&gt;        User.objects.create_user(username=username,password=password)  <span class="comment">#User是以个对象</span></span><br><span class="line">&gt;        s = <span class="string">"恭喜你注册成功，现在可以登录了"</span></span><br><span class="line">&gt;        <span class="keyword">return</span> redirect(<span class="string">"/login/"</span>)</span><br><span class="line">&gt;    <span class="keyword">return</span> render(request,<span class="string">"reg.html"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注销：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">log_out</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    auth.logout(request)</span><br><span class="line">&gt;    <span class="keyword">return</span> redirect(<span class="string">"/login/"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户认知———auth模块&quot;&gt;&lt;a href=&quot;#用户认知———auth模块&quot; class=&quot;headerlink&quot; title=&quot;用户认知———auth模块&quot;&gt;&lt;/a&gt;用户认知———auth模块&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;一、auth模块
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-admin管理工具</title>
    <link href="http://yoursite.com/2018/11/15/Django-admin%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/15/Django-admin管理工具/</id>
    <published>2018-11-15T11:29:08.130Z</published>
    <updated>2018-11-15T11:44:52.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="admin组件使用"><a href="#admin组件使用" class="headerlink" title="admin组件使用"></a>admin组件使用</h1><p>Django提供了基于web的管理工具</p><p>Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 settings.py 中的</p><p> INSTALLED_APPS 看到它：</p><pre><code># Application definitionINSTALLED_APPS = [    &apos;django.contrib.admin&apos;,    &apos;django.contrib.auth&apos;,    &apos;django.contrib.contenttypes&apos;,    &apos;django.contrib.sessions&apos;,    &apos;django.contrib.messages&apos;,    &apos;django.contrib.staticfiles&apos;,    &quot;app01&quot;]</code></pre><p>django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。</p><p>激活管理工具</p><p>通常在生成项目的时候会在urls.py中自动设置好</p><pre><code>from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [    url(r&apos;^admin/&apos;, admin.site.urls),]</code></pre><p>当这一切配置好后，Django管理工具就可以运行了。</p><h1 id="使用管理工具"><a href="#使用管理工具" class="headerlink" title="使用管理工具"></a>使用管理工具</h1><p>启动开发服务器，然后在浏览器中访问 <a href="http://127.0.0.1:8000/admin/，得到登陆界面，" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/，得到登陆界面，</a></p><p>你可以通过命令 python manage.py createsuperuser 来创建超级用户。</p><p>为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin</p><pre><code>from django.db import models# Create your models here.class Author(models.Model):    name=models.CharField( max_length=32)    age=models.IntegerField()    def __str__(self):        return self.nameclass Publish(models.Model):    name=models.CharField( max_length=32)    email=models.EmailField()    def __str__(self):        return self.nameclass Book(models.Model):    title = models.CharField( max_length=32)    publishDate=models.DateField()    price=models.DecimalField(max_digits=5,decimal_places=2)    publisher=models.ForeignKey(to=&quot;Publish&quot;)    authors=models.ManyToManyField(to=&apos;Author&apos;)    def __str__(self):        return self.title</code></pre><h1 id="admin的定制"><a href="#admin的定制" class="headerlink" title="admin的定制"></a>admin的定制</h1><p>在admin中只需要将Model中的某个类注册，即可在Admin中实现增删改查的功能，如：</p><pre><code>admin.site.register(models.UserInfo)</code></pre><p>但是这种方式比较简单，如果想进行更多的定制操作，需要利用ModelAdmin进行操作，</p><p>如：</p><pre><code>方式一：    class UserAdmin(admin.ModelAdmin):        list_display = (&apos;user&apos;, &apos;pwd&apos;,)    admin.site.register(models.UserInfo, UserAdmin) # 第一个参数可以是列表方式二：    @admin.register(models.UserInfo)                # 第一个参数可以是列表    class UserAdmin(admin.ModelAdmin):        list_display = (&apos;user&apos;, &apos;pwd&apos;,)</code></pre><p>ModelAdmin中提供了大量的可定制功能，如：</p><p>1 list_display，列表时，定制显示的列。</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;)    def xxxxx(self, obj):        return &quot;xxxxx&quot;</code></pre><p>2 list_display_links，列表时，定制列可以点击跳转。</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;)    list_display_links = (&apos;pwd&apos;,)</code></pre><p>3 list_filter，列表时，定制右侧快速筛选。<br>4 list_select_related，列表时，连表查询是否自动select_related<br>5 list_editable，列表时，可以编辑的列 </p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    list_display = (&apos;user&apos;, &apos;pwd&apos;,&apos;ug&apos;,)    list_editable = (&apos;ug&apos;,)</code></pre><p>6 search_fields，列表时，模糊搜索的功能</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    search_fields = (&apos;user&apos;, &apos;pwd&apos;)</code></pre><p>7 date_hierarchy，列表时，对Date和DateTime类型进行搜索</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    date_hierarchy = &apos;ctime&apos;</code></pre><p>8  inlines，详细页面，如果有其他表和当前表做FK，那么详细页面可以进行动态增加和删除</p><pre><code>class UserInfoInline(admin.StackedInline): # TabularInline    extra = 0    model = models.UserInfoclass GroupAdminMode(admin.ModelAdmin):    list_display = (&apos;id&apos;, &apos;title&apos;,)    inlines = [UserInfoInline, ]</code></pre><p>9 action，列表时，定制action中的操作</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    # 定制Action行为具体方法    def func(self, request, queryset):        print(self, request, queryset)        print(request.POST.getlist(&apos;_selected_action&apos;))    func.short_description = &quot;中文显示自定义Actions&quot;    actions = [func, ]    # Action选项都是在页面上方显示    actions_on_top = True    # Action选项都是在页面下方显示    actions_on_bottom = False    # 是否显示选择个数    actions_selection_counter = True</code></pre><p>10 定制HTML模板</p><pre><code>add_form_template = Nonechange_form_template = Nonechange_list_template = Nonedelete_confirmation_template = Nonedelete_selected_confirmation_template = Noneobject_history_template = None</code></pre><p>11 raw_id_fields，详细页面，针对FK和M2M字段变成以Input框形式</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    raw_id_fields = (&apos;FK字段&apos;, &apos;M2M字段&apos;,)</code></pre><p>12  fields，详细页面时，显示字段的字段</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    fields = (&apos;user&apos;,)</code></pre><p>13 exclude，详细页面时，排除的字段</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    exclude = (&apos;user&apos;,)</code></pre><p>14  readonly_fields，详细页面时，只读字段</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    readonly_fields = (&apos;user&apos;,)</code></pre><p>15 fieldsets，详细页面时，使用fieldsets标签对数据进行分割显示</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    fieldsets = (        (&apos;基本数据&apos;, {            &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;, &apos;ctime&apos;,)        }),        (&apos;其他&apos;, {            &apos;classes&apos;: (&apos;collapse&apos;, &apos;wide&apos;, &apos;extrapretty&apos;),  # &apos;collapse&apos;,&apos;wide&apos;, &apos;extrapretty&apos;            &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;),        }),    )</code></pre><p>16 详细页面时，M2M显示时，数据移动选择（方向：上下和左右）</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    filter_vertical = (&quot;m2m字段&quot;,) # 或filter_horizontal = (&quot;m2m字段&quot;,)</code></pre><p>17 ordering，列表时，数据排序规则</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    ordering = (&apos;-id&apos;,)    或    def get_ordering(self, request):        return [&apos;-id&apos;, ]</code></pre><p>18 radio_fields，详细页面时，使用radio显示选项（FK默认使用select）</p><pre><code>radio_fields = {&quot;ug&quot;: admin.VERTICAL} # 或admin.HORIZONTAL</code></pre><p>19 form = ModelForm，用于定制用户请求时候表单验证</p><pre><code>from app01 import modelsfrom django.forms import ModelFormfrom django.forms import fieldsclass MyForm(ModelForm):    others = fields.CharField()    class Meta:        model = models = models.UserInfo        fields = &quot;__all__&quot;@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    form = MyForm</code></pre><p>20 empty_value_display = “列数据为空时，显示默认值”</p><pre><code>@admin.register(models.UserInfo)class UserAdmin(admin.ModelAdmin):    empty_value_display = &quot;列数据为空时，默认显示&quot;    list_display = (&apos;user&apos;,&apos;pwd&apos;,&apos;up&apos;)    def up(self,obj):        return obj.user    up.empty_value_display = &quot;指定列数据为空时，默认显示&quot;</code></pre><p>例子：</p><pre><code>from django.contrib import admin# Register your models here.from .models import *class BookInline(admin.StackedInline): # TabularInline    extra = 0    model = Bookclass BookAdmin(admin.ModelAdmin):    list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;,&quot;foo&quot;,&quot;publisher&quot;)    list_display_links = (&apos;publishDate&apos;,&quot;price&quot;)    list_filter = (&apos;price&apos;,)    list_editable=(&quot;title&quot;,&quot;publisher&quot;)    search_fields = (&apos;title&apos;,)    date_hierarchy = &apos;publishDate&apos;    preserve_filters=False    def foo(self,obj):        return obj.title+str(obj.price)    # 定制Action行为具体方法    def func(self, request, queryset):        print(self, request, queryset)        print(request.POST.getlist(&apos;_selected_action&apos;))    func.short_description = &quot;中文显示自定义Actions&quot;    actions = [func, ]    # Action选项都是在页面上方显示    actions_on_top = True    # Action选项都是在页面下方显示    actions_on_bottom = False    # 是否显示选择个数    actions_selection_counter = True    change_list_template=&quot;my_change_list_template.html&quot;class PublishAdmin(admin.ModelAdmin):     list_display = (&apos;name&apos;, &apos;email&apos;,)     inlines = [BookInline, ]admin.site.register(Book, BookAdmin) # 第一个参数可以是列表admin.site.register(Publish,PublishAdmin)admin.site.register(Author)</code></pre><h1 id="admin源码解析"><a href="#admin源码解析" class="headerlink" title="admin源码解析"></a>admin源码解析</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式主要目的是确保某一个类只有一个实例存在。当我们希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个APPConfig    的类来读取配置文件的信息。如果在程序运行期间，有很多地方需要使用配置文    件的内容，也就是说，很多地方都需要APPConfig的实例对象，而这样会严重浪费    内存资源，尤其是在配置文件内容很多的情况下。事实上，类似AppConfig这样的类，我们希望在程序运行期间只存在一个实例对象。</code></pre><p>在python中，我们可以用很多种方式来实现单例模式：<br>使用模块（模块的导入）<br>使用<strong>new</strong><br>使用装饰器（decorator）<br>使用元类（metaclass）<br>（1）使用<strong>new</strong><br>    为了使类只能出现一个实例，我们可以使用<strong>new</strong>来控制实例的创建过程，代码<br>    如下：</p><pre><code>class Singleton(object):    _instance = None    def __new__(cls, *args, **kw):        if not cls._instance:            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)          return cls._instance  class MyClass(Singleton):      a = 1</code></pre><p>  在上面的代码中，我们将类的实例和一个类变量instance关联起来，如果cls.instance为None则创<br>建实例，否则直接返回cls._instance<br>执行情况：</p><pre><code>&gt;&gt;&gt; one = MyClass()&gt;&gt;&gt; two = MyClass()&gt;&gt;&gt; one == twoTrue&gt;&gt;&gt; one is twoTrue&gt;&gt;&gt; id(one), id(two)(4303862608, 4303862608)</code></pre><p>(2)使用模块<br>    其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当<br>    第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的<br>    函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可<br>    以考虑这样做：</p><pre><code>    # mysingleton.py    class My_Singleton(object):        def foo(self):            pass    my_singleton = My_Singleton()将上面的代码保存在文件 mysingleton.py 中，然后这样使用：    from mysingleton import my_singleton    my_singleton.foo()</code></pre><h2 id="admin执行流程"><a href="#admin执行流程" class="headerlink" title="admin执行流程"></a>admin执行流程</h2><h3 id="循环加载执行所有已经注册的app中的admin-py文件"><a href="#循环加载执行所有已经注册的app中的admin-py文件" class="headerlink" title="循环加载执行所有已经注册的app中的admin.py文件"></a>循环加载执行所有已经注册的app中的admin.py文件</h3><pre><code>def autodiscover():    autodiscover_modules(&apos;admin&apos;, register_to=site)</code></pre><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><pre><code>＃admin.pyclass BookAdmin(admin.ModelAdmin):    list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;)admin.site.register(Book, BookAdmin) admin.site.register(Publish)</code></pre><h3 id="admin-site"><a href="#admin-site" class="headerlink" title="admin.site"></a>admin.site</h3><pre><code>class AdminSite(object):...# This global object represents the default admin site, for the common case.# You can instantiate AdminSite in your own code to create a custom admin site.site = AdminSite()</code></pre><p>这里应用的是一个单例模式，对于AdminSite类的一个单例模式，执行的每一个app中的每一个admin.site</p><p>都是一个对象。</p><h3 id="执行register方法"><a href="#执行register方法" class="headerlink" title="执行register方法"></a>执行register方法</h3><pre><code>admin.site.register(Book, BookAdmin) admin.site.register(Publish)class ModelAdmin(BaseModelAdmin):passdef register(self, model_or_iterable, admin_class=None, **options):    if not admin_class:            admin_class = ModelAdmin    # Instantiate the admin class to save in the registry    self._registry[model] = admin_class(model, self)# 思考：在每一个app的admin .py中加上print(admin.site._registry)   ＃ 执行结果？</code></pre><p> 到这里，注册结束！</p><h3 id="admin的URL配置"><a href="#admin的URL配置" class="headerlink" title="admin的URL配置"></a>admin的URL配置</h3><pre><code>urlpatterns = [    url(r&apos;^admin/&apos;, admin.site.urls),]class AdminSite(object):     def get_urls(self):        from django.conf.urls import url, include        urlpatterns = []        # Add in each model&apos;s views, and create a list of valid URLS for the        # app_index        valid_app_labels = []        for model, model_admin in self._registry.items():            urlpatterns += [                url(r&apos;^%s/%s/&apos; % (model._meta.app_label, model._meta.model_name), include(model_admin.urls)),            ]            if model._meta.app_label not in valid_app_labels:                valid_app_labels.append(model._meta.app_label)        return urlpatterns    @property    def urls(self):        return self.get_urls(), &apos;admin&apos;, self.name</code></pre><h3 id="url方法的扩展应用"><a href="#url方法的扩展应用" class="headerlink" title="url方法的扩展应用"></a>url方法的扩展应用</h3><pre><code>from django.shortcuts import HttpResponsedef test01(request):    return HttpResponse(&quot;test01&quot;)def test02(request):    return HttpResponse(&quot;test02&quot;)urlpatterns = [    url(r&apos;^admin/&apos;, admin.site.urls),    url(r&apos;^ward/&apos;, ([                    url(r&apos;^test01/&apos;, test01),                    url(r&apos;^test02/&apos;, test02),                    ],None,None)),]</code></pre><h1 id="扩展优化"><a href="#扩展优化" class="headerlink" title="扩展优化"></a>扩展优化</h1><pre><code>from django.conf.urls import url,includefrom django.contrib import adminfrom django.shortcuts import HttpResponsedef change_list_view(request):    return HttpResponse(&quot;change_list_view&quot;)def add_view(request):    return HttpResponse(&quot;add_view&quot;)def delete_view(request):    return HttpResponse(&quot;delete_view&quot;)def change_view(request):    return HttpResponse(&quot;change_view&quot;)def get_urls():    temp=[        url(r&quot;^$&quot;.format(app_name,model_name),change_list_view),        url(r&quot;^add/$&quot;.format(app_name,model_name),add_view),        url(r&quot;^\d+/del/$&quot;.format(app_name,model_name),delete_view),        url(r&quot;^\d+/change/$&quot;.format(app_name,model_name),change_view),    ]    return tempurl_list=[]for model_class,obj in admin.site._registry.items():    model_name=model_class._meta.model_name    app_name=model_class._meta.app_label    # temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),(get_urls(),None,None))    temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),include(get_urls()))    url_list.append(temp)urlpatterns = [    url(r&apos;^admin/&apos;, admin.site.urls),    url(r&apos;^ward/&apos;, (url_list,None,None)),]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;admin组件使用&quot;&gt;&lt;a href=&quot;#admin组件使用&quot; class=&quot;headerlink&quot; title=&quot;admin组件使用&quot;&gt;&lt;/a&gt;admin组件使用&lt;/h1&gt;&lt;p&gt;Django提供了基于web的管理工具&lt;/p&gt;
&lt;p&gt;Django 自动管理工具是 
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli目录结构总结的步骤</title>
    <link href="http://yoursite.com/2018/11/14/vue-cli%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2018/11/14/vue-cli自己总结的步骤/</id>
    <published>2018-11-14T12:37:04.000Z</published>
    <updated>2018-11-15T06:33:03.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="main-js这是js的入口文件"><a href="#main-js这是js的入口文件" class="headerlink" title="main.js这是js的入口文件"></a>main.js这是js的入口文件</h1><pre><code>// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import store from &quot;./store&quot;import axios from &apos;axios&apos;// 使用element-uiimport ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-chalk/index.css&apos;Vue.use(ElementUI);// 全局的（一个一个比较麻烦）// axios.request({//   url: XXX,//   method: &quot;get&quot;// });// 通过使用原型链 这样所有的组件都可以通过$axios去访问了Vue.prototype.$axios = axios;Vue.config.productionTip = false;/* eslint-disable no-new */new Vue({el: &apos;#app&apos;,router,store,components: { App },template: &apos;&lt;App/&gt;&apos;});</code></pre><h1 id="App-vue页面级App组件"><a href="#App-vue页面级App组件" class="headerlink" title="App.vue页面级App组件"></a>App.vue页面级App组件</h1><pre><code>&lt;template&gt;&lt;div id=&quot;app&quot;&gt;    &lt;MyHeader&gt;&lt;/MyHeader&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;MyFooter&gt;&lt;/MyFooter&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyHeader from &quot;./components/MyHeader&quot;import MyFooter from &quot;./components/MyFooter&quot;export default {name: &apos;App&apos;,components: {    MyHeader,    MyFooter,}}&lt;/script&gt;&lt;style&gt;body {    margin: 0;    padding: 0;}&lt;/style&gt;</code></pre><h1 id="router-index-js"><a href="#router-index-js" class="headerlink" title="router-index.js"></a>router-index.js</h1><pre><code>import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;../components/headers/Home&apos;import Course from &apos;../components/headers/Course&apos;Vue.use(Router);export default new Router({routes: [    {    path: &apos;/&apos;,    name: &apos;home&apos;,    component: Home    },    {    path: &apos;/course&apos;,    name: &apos;course&apos;,    component: Course    }]})</code></pre><h1 id="Vuex-axios的使用"><a href="#Vuex-axios的使用" class="headerlink" title="Vuex+axios的使用"></a>Vuex+axios的使用</h1><h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code>import Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;Vue.use(Vuex);export default new Vuex.Store({// this.$store.state.name    拿数据state: {    name: &apos;1&apos;,},// 对state中的数据进行处理// this.$store.getters.new_name    拿数据getters: {    new_name: function (state) {    return state.name + &apos;xxx&apos;;    },    new_new_name: function (state, getters) {    return getters.new_name + &apos;000&apos;;    },},mutations: {    change_data: function (state, data) {    // 自己处理change_data事件的    state.name = data;    }}})</code></pre><h2 id="Course-vue"><a href="#Course-vue" class="headerlink" title="Course.vue"></a>Course.vue</h2><pre><code>&lt;template&gt;&lt;div&gt;&lt;h1&gt;course&lt;/h1&gt;{{name}}{{new_name}}&lt;hr&gt;{{try_again}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: &quot;Course&quot;,    data(){        return {            name : this.$store.state.name,            new_name: this.$store.getters.new_new_name,            try_again: &apos;&apos;,        }    },    // 方法执行完会改版数据但是不会刷新    // methods: {    //     my_click: function () {    //       this.$store.commit(&quot;change_data&quot;, &apos;到到&apos;)    //     }    // },    // 能够监听到数据的改变能够实时跟新    // computed: {    //     name: function () {    //       return  this.$store.state.name;    //     }    // }    mounted(){        let that = this;        this.$axios.request({            url: &quot;http://127.0.0.1:8000/tryagain/&quot;,            method: &apos;get&apos;,        }).then(function (data) {            // success do something~~            that.try_again = data.data        }).catch(function (data) {            // fail do something~~        })        // 单纯的发get请求        // this.$axios.get(&quot;url&quot;, {}).then()    }    }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;main-js这是js的入口文件&quot;&gt;&lt;a href=&quot;#main-js这是js的入口文件&quot; class=&quot;headerlink&quot; title=&quot;main.js这是js的入口文件&quot;&gt;&lt;/a&gt;main.js这是js的入口文件&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// The
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vuex+axios</title>
    <link href="http://yoursite.com/2018/11/13/Vuex-axios/"/>
    <id>http://yoursite.com/2018/11/13/Vuex-axios/</id>
    <published>2018-11-13T13:54:25.000Z</published>
    <updated>2018-11-15T06:36:23.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vuex-简介"><a href="#Vuex-简介" class="headerlink" title="Vuex 简介"></a>Vuex 简介</h1><pre><code>vuex是一个专门为Vue.js设计的集中式状态管理架构。状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。Vuex和单纯的全局对象有以下不同：1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。</code></pre><h2 id="安装使用vuex"><a href="#安装使用vuex" class="headerlink" title="安装使用vuex"></a>安装使用vuex</h2><p>–  npm install vuex</p><pre><code>vuex的使用一// main.jsimport Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import vuex from &apos;vuex&apos;Vue.use(vuex)Vue.config.productionTip = falseconst store = new vuex.Store({    state: {    show: false,    }});new Vue({el: &apos;#app&apos;,router,store,components: { App },template: &apos;&lt;App/&gt;&apos;});vuex的使用二// 为了方便维护，我们通常把在src下面新建一个store文件夹，// 然后在里面新建一个index.jsimport Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    show: false,    },});// 那么main.js要改成import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import store from &quot;./store&quot;Vue.config.productionTip = false;new Vue({el: &apos;#app&apos;,router,store,components: { App },template: &apos;&lt;App/&gt;&apos;});</code></pre><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><pre><code>简而言之~~state是保存我们data中需要共享的数据。由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。this.$store.state.count</code></pre><p>组件中获取vuex中状态</p><pre><code>// 创建一个组件const Counter = {template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,computed: {    count(){    return this.$store.state.count    }}};</code></pre><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。</p><p>并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。</p><p>我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被</p><p>缓存起来，只有它的依赖发生改变时，才会重新计算。</p><p>Getter会接收state作为其第一个参数：</p><pre><code>import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 通过 this.$store.getters.my_funcgetters: {    my_func: function (state) {    return state.count * 2    }},});</code></pre><p>Getter也可以接收getters为第二个参数：</p><pre><code>import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 通过 this.$store.getters.my_funcgetters: {    my_func: function (state) {    return state.count * 2    },    // 通过 this.$store.getters.my_func_count    my_func_count: function (state, getters) {    return getters.my_func.length    }},});</code></pre><h2 id="Mutatiion"><a href="#Mutatiion" class="headerlink" title="Mutatiion"></a>Mutatiion</h2><p>更改Vuex中的store中的状态的唯一方法是提交mutation。</p><p>每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。</p><p>也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。</p><p>这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数：</p><pre><code>Mutation基本使用import Vue from &apos;vue&apos;import Vue_x from &quot;vuex&quot;Vue.use(Vue_x);export default  new Vue_x.Store({state: {    count: 20,},// 需要通过 this.$store.commit(&apos;increment&apos;, 10)mutations: {    increment (state, n) {    // 变更状态    state.count += n    }}});</code></pre><p>Mutation需要遵守Vue的响应规则</p><p>既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。</p><p>这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项：</p><p>　　– 1，最好提前在你的store中初始化好所有的所需要的属性</p><p>　　– 2，当对象需要添加属性时，你应该使用</p><p>　　　　　　–  Vue.set(obj, ‘newProp’, 123)</p><p>　　　　　　–  以新对象代替老对象  state.obj = { …state.obj, newProp: 123}</p><h1 id="axios的简单使用"><a href="#axios的简单使用" class="headerlink" title="axios的简单使用"></a>axios的简单使用</h1><p>基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。</p><p>##　使用npm安装axios</p><p>– npm install axios -D</p><h2 id="基本的配置"><a href="#基本的配置" class="headerlink" title="基本的配置"></a>基本的配置</h2><pre><code>// main.jsimport axios from &quot;axios&quot;Vue.prototype.$axios = axios// 组件中methods: {    init () {        this.$axios({            method: &quot;get&quot;,            url: &quot;/user&quot;        })    },};</code></pre><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><p>get请求</p><pre><code>test(){      this.$axios.get(this.$store.state.apiList.course,{        params: {          id: 123,        }      }).then(function (response) {        // 请求成功回调函数      }).catch(function (response) {        // 请求失败的回调函数      })}</code></pre><p>post请求</p><pre><code>test(){      this.$axios.post(this.$store.state.apiList.course,{          course_title: &quot;Python&quot;,          course_price: &quot;19.88&quot;      }).then(function (response) {        // 请求成功回调函数      }).catch(function (response) {        // 请求失败的回调函数      })}</code></pre><p>发送多个并发请求</p><pre><code>function getCourse(){      return this.$axios.get(&apos;/course/12&apos;)    }function getCourse_all() {        return this.$axios.get(&apos;/course&apos;)        }this.$axios.all([getCourse_all(),getCourse()])        .then().catch()</code></pre><p>axios.request</p><pre><code>methods: {      init(){        var that = this        this.$axios.request({          url: that.$store.state.apiList.course,          method: &apos;get&apos;        }).then(function (data) {          if (data.status === 200){              that.courseList = data.data          }        }).catch(function (reason) {          console.log(reason)        })      }},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vuex-简介&quot;&gt;&lt;a href=&quot;#Vuex-简介&quot; class=&quot;headerlink&quot; title=&quot;Vuex 简介&quot;&gt;&lt;/a&gt;Vuex 简介&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;vuex是一个专门为Vue.js设计的集中式状态管理架构。
状态？ 我们把它理解
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>npm+webpack+vue-cli快速上手</title>
    <link href="http://yoursite.com/2018/11/13/npm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://yoursite.com/2018/11/13/npm-webpack-vue-cli快速上手/</id>
    <published>2018-11-13T12:53:56.000Z</published>
    <updated>2018-11-15T06:37:09.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-npm"><a href="#Node-js-npm" class="headerlink" title="Node.js   npm"></a>Node.js   npm</h1><h2 id="什么是Node-js-以及npm"><a href="#什么是Node-js-以及npm" class="headerlink" title="什么是Node.js  以及npm"></a>什么是Node.js  以及npm</h2><pre><code>简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。npm 是Node.js 的包管理工具。</code></pre><h2 id="npm的安装和更新"><a href="#npm的安装和更新" class="headerlink" title="npm的安装和更新"></a>npm的安装和更新</h2><pre><code>Node.js下载安装   Node.js 官网下载安装。npm自带的包管理工具。查看安装版本信息：</code></pre><p>　　    –  node -v  查看Node.js 版本信息</p><p>　　    –  npm -v  查看npm版本信息</p><pre><code>更新npm到指定版本：</code></pre><p>　　    –  npm install <a href="mailto:npm@5.3.0" target="_blank" rel="noopener">npm@5.3.0</a> -g</p><p>　　    – npm install npm@latest -g 更新最新的稳定版本</p><h2 id="npm-常用操作"><a href="#npm-常用操作" class="headerlink" title="npm 常用操作"></a>npm 常用操作</h2><pre><code>之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。有了npm，我们管理自己的依赖包以及版本更加简单。到自己项目目录下，进行以下命令：</code></pre><p>　　    – npm init -y    输入-y使用默认配置项 生成package.json文件。</p><p>　　    – npm i <a href="mailto:jquery@0.0.0" target="_blank" rel="noopener">jquery@0.0.0</a>   简写install 为 i 下载依赖  不写@ 默认最新版本</p><p>　　    – npm uninstall jquery  卸载依赖包</p><p>　　    – npm update jquery   更新依赖包</p><p>　　    – npm list  列出已安装的依赖</p><p>　　    – npm install webpack –D 保存为开发环境依赖</p><p>　　    – 老版本需要 –save 参数 现在不需要了</p><pre><code>我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。如果我们删掉 node_modules目录，可以使用 npm i  来下载所有依赖。</code></pre><h2 id="npm-常用配置项"><a href="#npm-常用配置项" class="headerlink" title="npm 常用配置项"></a>npm 常用配置项</h2><pre><code>当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。在我们的package.json文件中有很多配置项</code></pre><p>　　    – name  项目名字 中间不能有空格只能用小写</p><p>　　    – version  项目版本</p><p>　　    – description   项目描述信息</p><p>　　    – main  项目的入口文件</p><p>　　    – scripts 指定命令的快捷方式 npm run test     test是scripts里的键名 值为具体命令</p><p>　　    – author 作者</p><p>　　    – license  许可证</p><p>　　    – dependencies  生成环境依赖的包以及版本信息</p><p>　　    – devDependencies  开发环境的依赖</p><h1 id="webpack3"><a href="#webpack3" class="headerlink" title="webpack3"></a>webpack3</h1><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析，</p><p>然后将这些模块按照指定的规则生成静态资源。</p><p>那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##安装和配置</span><br><span class="line">    webpack是跑在Node.js环境下的，所以确定自己有node环境。</span><br><span class="line"></span><br><span class="line">安装方式：</span><br><span class="line"></span><br><span class="line">　　-- npm install webpack -g  全局安装</span><br><span class="line"></span><br><span class="line">　　-- webpack  &lt;要打包文件&gt;  &lt;打包后文件&gt;     全局这种方式进行打包</span><br><span class="line"></span><br><span class="line">　　-- npm install webpack   在自己的项目下 npm init 后在下载webpack 这就是局部安装</span><br><span class="line"></span><br><span class="line">　　-- node_modules/.bin/webpack &lt;要打包文件&gt;  &lt;打包后文件&gt;   项目里要打包文件是入口文件</span><br><span class="line"></span><br><span class="line">　　-- 路径太长 太烦 可以自定义命令  在package.json 文件的 scripts下面自定义</span><br><span class="line"></span><br><span class="line">## entry 和 output</span><br><span class="line">    entry 入口文件  output 出口文件</span><br><span class="line"></span><br><span class="line">    上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~</span><br><span class="line"></span><br><span class="line">    我们可以把命令写在webpack.config.js文件中~~</span><br><span class="line">&gt;webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">    // 所有的入口文件</span><br><span class="line">    entry: &#123;</span><br><span class="line">         home: &apos;./main.js&apos;, </span><br><span class="line">         login: &apos;./login.js&apos;,</span><br><span class="line">    &#125;, </span><br><span class="line">    // 出口文件  </span><br><span class="line">    output: &#123;</span><br><span class="line">         filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">         path: __dirname + &apos;/dist&apos;,</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line">// backage.json  下的scripts</span><br><span class="line">scripts: &#123;</span><br><span class="line">     &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;</span><br><span class="line">&#125;</span><br><span class="line">//  运行命令</span><br><span class="line">npm  run pack</span><br><span class="line"></span><br><span class="line"># webpack4</span><br><span class="line">## webpack的新特性</span><br><span class="line">1, webpack不在单独使用，需要webpack-cli</span><br><span class="line"></span><br><span class="line">　　-- 全局安装  npm install webpack webpack-cli -g -D</span><br><span class="line"></span><br><span class="line">　　-- 局部安装  npm install webpack webpack-cli -D</span><br><span class="line"></span><br><span class="line">2, 增加了模式区分 （development, production）</span><br><span class="line"></span><br><span class="line">　　--webpack --mode development/production 进行模式切换</span><br><span class="line"></span><br><span class="line">　　-- development 开发者模式 打包默认不压缩代码</span><br><span class="line"></span><br><span class="line">　　-- production  生产者模式 上线时使用，压缩代码。 默认是这个模式</span><br><span class="line"></span><br><span class="line">3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下</span><br><span class="line"></span><br><span class="line">　　-- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js</span><br><span class="line"></span><br><span class="line">4，多入口以及多出口</span><br><span class="line">&gt;webpack.config.js　</span><br><span class="line">entry: &#123;</span><br><span class="line">    // 多入口</span><br><span class="line">    a: &quot;./src/js/index.js&quot;,</span><br><span class="line">    b: &quot;./src/js/index2.js&quot;,</span><br><span class="line">&#125;</span><br><span class="line">output: &#123;</span><br><span class="line">    // 多出口</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;./js/[name].bundle.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># vue-cli</span><br><span class="line">vue-cli是官方提供的快速构建这个单页面应用的脚手架。</span><br><span class="line"></span><br><span class="line">## 根据官方文档中的构件流程：</span><br><span class="line"></span><br><span class="line">　　-- 前提是已经安装了node.js 否则npm都用不了</span><br><span class="line"></span><br><span class="line">　　-- 1，使用npm全局安装vue-cli </span><br><span class="line"></span><br><span class="line">　　　　　　npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">　　-- 2, 安装完成后在自己的工作空间里</span><br><span class="line"></span><br><span class="line">　　　　　　vue init webpack vue-demo  </span><br><span class="line"></span><br><span class="line">　　　　输入命令后进入安装阶段，需要用户输入一些信息 这里省略了.....</span><br><span class="line"></span><br><span class="line">　　-- 3，切换到我们的项目目录下 </span><br><span class="line"></span><br><span class="line">　　　　　　cd vue-demo</span><br><span class="line"></span><br><span class="line">　　　　　　npm run dev</span><br><span class="line"></span><br><span class="line">## 目录结构：</span><br><span class="line"></span><br><span class="line">　　-- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件</span><br><span class="line"></span><br><span class="line">　　-- config 配置文件，执行文件需要的配置信息</span><br><span class="line"></span><br><span class="line">　　-- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下</span><br><span class="line"></span><br><span class="line">　　-- node_modules  项目依赖包</span><br><span class="line"></span><br><span class="line">　　-- static 静态资源</span><br><span class="line"></span><br><span class="line">　　-- package.json   依赖包的json文件</span><br><span class="line"></span><br><span class="line">其实这里面命令很多~我们在后续项目中应用到再说</span><br></pre></td></tr></table></figure></p><h1 id="vue-cli配置JQuery、bootstrap"><a href="#vue-cli配置JQuery、bootstrap" class="headerlink" title="vue-cli配置JQuery、bootstrap"></a>vue-cli配置JQuery、bootstrap</h1><h2 id="第一步-下载安装"><a href="#第一步-下载安装" class="headerlink" title="第一步  下载安装"></a>第一步  下载安装</h2><p>　　– npm install jquery </p><p>　　– npm install bootstrap </p><h2 id="第二步-修改build-webpack-base-conf-js"><a href="#第二步-修改build-webpack-base-conf-js" class="headerlink" title="第二步 修改build/webpack.base.conf.js"></a>第二步 修改build/webpack.base.conf.js</h2><blockquote><p>const webpack = require(‘webpack’)<br>// 在module.exports里添加插件<br>plugins: [<br>    new webpack.ProvidePlugin({<br>      $: “jquery”,<br>      jQuery: “jquery”,<br>      “windows.jQuery”: “jquery”,<br>      // Popper: [‘popper.js’, ‘default’]<br>    })<br>],<br>//  <strong>***</strong>下面是如果手动下载bootstrap用的<strong>***</strong><br>resolve: {<br>    extensions: [‘.js’, ‘.vue’, ‘.json’],<br>    alias: {<br>      ‘vue$’: ‘vue/dist/vue.esm.js’,<br>      ‘@’: resolve(‘src’),<br>      // 如果是手动下载的bootstrap需要添加这个配置<br>      // ‘assets’: path.resolve(__dirname, ‘../src/assets’),<br>      // ‘jquery’: ‘jquery/src/jquery’<br>    }<br>  },</p></blockquote><p>修改配置文件</p><h2 id="第三步-修改主程序的js文件-main-js"><a href="#第三步-修改主程序的js文件-main-js" class="headerlink" title="第三步 修改主程序的js文件 main.js"></a>第三步 修改主程序的js文件 main.js</h2><blockquote><p>import $ from ‘jquery’<br>import ‘bootstrap/dist/css/bootstrap.min.css’<br>import ‘bootstrap/dist/js/bootstrap.min.js’</p></blockquote><h1 id="vue-cli-3-0"><a href="#vue-cli-3-0" class="headerlink" title="vue-cli 3.0"></a>vue-cli 3.0</h1><h2 id="第一步-下载vue-cli-3-0"><a href="#第一步-下载vue-cli-3-0" class="headerlink" title="第一步 下载vue-cli 3.0"></a>第一步 下载vue-cli 3.0</h2><p>　　– npm install -g @vue/cli</p><p>　　– 报错 npm error  可以运行下面命令</p><p>　　　　– npm cache clean –force &amp;&amp; npm cache verify</p><h2 id="第二步-创建项目"><a href="#第二步-创建项目" class="headerlink" title="第二步 创建项目"></a>第二步 创建项目</h2><p>　　– vue create xxxx</p><p>　　之后会出现很多选项，我们可以根据自己的习惯去选择~~</p><h2 id="第三步-目录结构以及配置文件"><a href="#第三步-目录结构以及配置文件" class="headerlink" title="第三步 目录结构以及配置文件"></a>第三步 目录结构以及配置文件</h2><p>　　– vue-cli3 目录更加简单</p><p>　　– 我们手动在项目根目录下创建  vue.config.js 里面写vue的配置信息</p><h1 id="vue-cli3-配置jQuery、bootstrap"><a href="#vue-cli3-配置jQuery、bootstrap" class="headerlink" title="vue-cli3 配置jQuery、bootstrap"></a>vue-cli3 配置jQuery、bootstrap</h1><p>　　– 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-js-npm&quot;&gt;&lt;a href=&quot;#Node-js-npm&quot; class=&quot;headerlink&quot; title=&quot;Node.js   npm&quot;&gt;&lt;/a&gt;Node.js   npm&lt;/h1&gt;&lt;h2 id=&quot;什么是Node-js-以及npm&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue总结</title>
    <link href="http://yoursite.com/2018/11/13/Vue%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/13/Vue总结/</id>
    <published>2018-11-13T00:30:00.000Z</published>
    <updated>2018-11-15T06:36:05.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue总结"><a href="#vue总结" class="headerlink" title="vue总结"></a>vue总结</h1><blockquote><p>MVC  Model View Controller</p></blockquote><blockquote><p>MVVM Model View ViweMode</p></blockquote><h2 id="ES6常用语法"><a href="#ES6常用语法" class="headerlink" title="ES6常用语法"></a>ES6常用语法</h2><pre><code>1.1 变量的提升1.2 模板字符串 ``${}1.3 数据的解构1.4 类 class extends constructor  super1.5 函数    1.5.1 注意this和普通函数的区别1.6 箭头函数1.7 单体模式1.8 import export   export default</code></pre><h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><pre><code>2.1 v-text  innerText2.2 v-html  innerHtml2.3 v-for  :key2.4 v-if v-else-if v-else  appendChild2.5 v-show  display2.6 v-on  @xxxx=&quot;自己处理的方法&quot;2.7 v-bind  :属性名称=“属性的值”2.8 v-model    2.8.1 input    2.8.2 textarea    2.8.3 select2.9 指令修饰符    2.9.1 .lazy    2.9.2 .number    2.9.3 .trim2.10 计算属性    2.10.1 放入缓存    2.10.2 只有数据改变的时候才会重新计算2.11 数据监听    2.11.1 注意可变类型和不可变    2.11.2 深监听  deep=true2.12 获取DOM    2.12.1 给便签绑定ref属性  ref=“属性值”    2.12.2 this.$refs.属性值2.13 自定义指令    2.13.1 vue.directive(“指令名称”, function(el, binding){        el 绑定指令的便签元素        binding 指令的所有信息    })</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>3.1 数据监听    3.1.1 改变数据        直接赋值    3.1.2 改变数组长度        能够被监听到，新值和旧值一样    3.1.3 改变数组内的值        app = new vue({})        app.$set(this.hobby, 0, &apos;抽烟&apos;)        $set()修改数组中的值可以监听        $delete()</code></pre><h2 id="Vue的组件"><a href="#Vue的组件" class="headerlink" title="Vue的组件"></a>Vue的组件</h2><h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><pre><code>Vue.compontent(“组件名称”, {})</code></pre><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><pre><code>const = app = new Vue({    el: &apos;#app&apos;,    components: {        组件的名称: 组件的配置信息    }})</code></pre><h4 id="子组件的注册"><a href="#子组件的注册" class="headerlink" title="子组件的注册"></a>子组件的注册</h4><pre><code>在父组件中注册components## 注意写组件标签## 每个组件的template只识别一个作用域块</code></pre><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h4 id="父子的通信"><a href="#父子的通信" class="headerlink" title="父子的通信"></a>父子的通信</h4><pre><code>在父组件中给子组件绑定属性子组件通过props=[&quot;属性名称&quot;]</code></pre><h4 id="子父的通信"><a href="#子父的通信" class="headerlink" title="子父的通信"></a>子父的通信</h4><pre><code>子组件先提交事件    this.$emit(&quot;事件名称&quot;, 值)在父组件中给子组件绑定事件    &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt;</code></pre><h4 id="非父子的通信"><a href="#非父子的通信" class="headerlink" title="非父子的通信"></a>非父子的通信</h4><pre><code>其中一个组件向中间调度器提交事件另一个组件监听中间调度器的事件注意this的问题中间调度器  let temp = new Vue();temp.$emit(&quot;say&quot;, value) // 事件名称和值mounted(){    that = this    // 监听中间调度器中的方法    temp.$on(&quot;say&quot;, function(data){        // 这里的this是temp的this        that.xxx = data // 这样改值    })}</code></pre><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><pre><code>&lt;slot&gt;&lt;/slot&gt;命名的插槽</code></pre><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><pre><code>代码重用的mixins = [base] </code></pre><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><h3 id="vue生命周期之beforeCreate"><a href="#vue生命周期之beforeCreate" class="headerlink" title="vue生命周期之beforeCreate"></a>vue生命周期之beforeCreate</h3><pre><code>实例创建之前除标签外，所有的vue需要的数据，事件都不存在</code></pre><h3 id="vue生命周期之created"><a href="#vue生命周期之created" class="headerlink" title="vue生命周期之created"></a>vue生命周期之created</h3><pre><code>实例创建之后，data和事件已经被解析到，el还没有找到</code></pre><h3 id="vue生命周期之beforeMount"><a href="#vue生命周期之beforeMount" class="headerlink" title="vue生命周期之beforeMount"></a>vue生命周期之beforeMount</h3><pre><code>开始找标签，数据还没有被渲染，事件也没有被监听</code></pre><h3 id="vue生命周期之mounted"><a href="#vue生命周期之mounted" class="headerlink" title="vue生命周期之mounted"></a>vue生命周期之mounted</h3><pre><code>开始渲染数据，开始监听事件</code></pre><h3 id="vue生命周期之beforeUpdata"><a href="#vue生命周期之beforeUpdata" class="headerlink" title="vue生命周期之beforeUpdata"></a>vue生命周期之beforeUpdata</h3><pre><code>数据已经被修改在虚拟DOM，但没有被渲染到页面上</code></pre><h3 id="vue生命周期之updata"><a href="#vue生命周期之updata" class="headerlink" title="vue生命周期之updata"></a>vue生命周期之updata</h3><pre><code>开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改</code></pre><h3 id="vue生命周期之beforeDestory"><a href="#vue生命周期之beforeDestory" class="headerlink" title="vue生命周期之beforeDestory"></a>vue生命周期之beforeDestory</h3><pre><code>所有的数据都存在</code></pre><h3 id="vue生命周期之destoryed"><a href="#vue生命周期之destoryed" class="headerlink" title="vue生命周期之destoryed"></a>vue生命周期之destoryed</h3><pre><code>所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了&lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签用activated和deactivated取代了beforeUpdate和destory的执行</code></pre><h3 id="最常用的钩子"><a href="#最常用的钩子" class="headerlink" title="最常用的钩子"></a>最常用的钩子</h3><pre><code>beforeMountmounted</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><pre><code>let url = [    {        path: &apos;/&apos;,        name: &quot;home&quot;,        component: {            template: ``,        }    }]let router = nwe VueRouter({    routes: url})const app = new Vue({    el: &apos;app&apos;,    router: router,})&lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt;&lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h3 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h3><pre><code>children: [    {}]append在父路由对应的组件的template里面写router-link router-view</code></pre><h3 id="路由的命名"><a href="#路由的命名" class="headerlink" title="路由的命名"></a>路由的命名</h3><pre><code>name注意to加冒号动态绑定</code></pre><h3 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h3><pre><code>{    path: &quot;/course/:id&quot;,}this.$route.params.idthis.$route.query.xxx$route 是一个对象 存放当前路由的所有信息$router VueRouter实例化对象</code></pre><h3 id="手动路由"><a href="#手动路由" class="headerlink" title="手动路由"></a>手动路由</h3><pre><code>this.$router.push(&apos;/&apos;)this.$router.push({name:&quot;home&quot;})</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>redirect: {name: &apos;xxx&apos;, params: {key: value}}</code></pre><h3 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h3><pre><code>router.beforeEach(function(to, from next){    // to 你要去哪    // from 你要从哪里来    // next() 你要去做什么 参数可以给路径  必须有，没有就不走})router.afterEach(function(to, from){    // to 你要去哪    // from 你从哪里来})to和from都是$route对象   路由的所有信息</code></pre><p></p><h2 id="node-js-npm-webpack-vue-cli-自带webpack"><a href="#node-js-npm-webpack-vue-cli-自带webpack" class="headerlink" title="node.js + npm + webpack + vue-cli(自带webpack)"></a>node.js + npm + webpack + vue-cli(自带webpack)</h2><pre><code>node.js / npm    - npm 管理工作目录        npm init -y    - 下载包        npm i xxx@0.0.0    - 卸载        npm uninstall xxx    - 更新        npm updata xxxwebpack  4    - 下载        npm i webpack webpack-cli    - 打包        webpack --mode development/production    - 打包默认的入口文件        src目录下的index.js    - 出口文件        dist目录的main.jswue-cli  2    - 帮助我们快速搭建项目的脚手架工具    - 下载        npm i vue-cli    - 用vue-cli帮助我们创建项目        vue init webpack xxxx(项目名称)    - 启动项目        cd xxxx(项目名称)        npm run dev    - 打吧包        npm run build</code></pre><h2 id="Vuex和axios"><a href="#Vuex和axios" class="headerlink" title="Vuex和axios"></a>Vuex和axios</h2><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><pre><code>存放一些公共的东西,是一个仓库安装    npm i vuex配置    导入        import vuex from &quot;vuex&quot;    vue使用vuex        vue.use(vuex)    实例化仓库        new vuex.Store({            state: {},            getters: {},            mutations: {}        })    new Vue({        el: &apos;#app&apos;,        store,    })获取残仓库数据    this.$store.state.xxx    this.$store.getters.xxx改变仓库中的数据    组件向仓库提交修改事件        this.$store.commit(&quot;事件名称&quot;, data)    在仓库中的mutations中        mutations: {            &quot;事件名称&quot;: function(state, data){                修改state中的数据            }        }注意计算属性    仓库中的数据建议都放在计算属性中</code></pre><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><pre><code>向后端服务器发送请求实现ajax技术的工具配置    下载        npm i axios    导入        import axios from “axios”    在vue的原型链中加入方法        Vue.prototype.#axios = axios发送请求    this.$axios.request({        url: &apos;&apos;,        method: &apos;&apos;,    }).then(function(){    }).catch(function(){    })</code></pre><h2 id="前后端的接通"><a href="#前后端的接通" class="headerlink" title="前后端的接通"></a>前后端的接通</h2><pre><code>后端设计一个接口前端通过axios发送请求拿到数据跨域问题</code></pre><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><pre><code>按照文档安装，并研究如何使用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue总结&quot;&gt;&lt;a href=&quot;#vue总结&quot; class=&quot;headerlink&quot; title=&quot;vue总结&quot;&gt;&lt;/a&gt;vue总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;MVC  Model View Controller&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue组件系统</title>
    <link href="http://yoursite.com/2018/10/14/vue%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/10/14/vue组件系统/</id>
    <published>2018-10-14T12:37:04.000Z</published>
    <updated>2018-11-15T06:36:47.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue组件系统之全局组件的注册"><a href="#Vue组件系统之全局组件的注册" class="headerlink" title="Vue组件系统之全局组件的注册"></a>Vue组件系统之全局组件的注册</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 注册</span></span><br><span class="line"><span class="undefined">&gt;    Vue.component(</span></span><br><span class="line"><span class="undefined">&gt;        // 第一个是组件名称  第二个object</span></span><br><span class="line"><span class="undefined">&gt;        "global-component", &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // 组件内容  抱一个div-单个根元素</span></span><br><span class="line"><span class="xml">&gt;            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;            // data必须是函数</span></span><br><span class="line"><span class="undefined">&gt;            data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;                // return中写数据</span></span><br><span class="line"><span class="undefined">&gt;                return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;            &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    );</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="xml">&gt;        // template: `<span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 注册组件</span></span><br><span class="line"><span class="undefined">&gt;    Vue.component(</span></span><br><span class="line"><span class="undefined">&gt;        // 第一个是组件名称  第二个object</span></span><br><span class="line"><span class="undefined">&gt;        "global-component", &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // 组件内容  抱一个div-单个根元素，包在app这个div中</span></span><br><span class="line"><span class="xml">&gt;            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;            // data必须是函数</span></span><br><span class="line"><span class="undefined">&gt;            data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;                // return中写数据</span></span><br><span class="line"><span class="undefined">&gt;                return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;            &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    );</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        // 根元素会替换div</span></span><br><span class="line"><span class="xml">&gt;        template: `<span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>全局组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;// 总结</span><br><span class="line">&gt;Vue.component(</span><br><span class="line">&gt;        // 第一个是组件名称  第二个object</span><br><span class="line">&gt;        "global-component", &#123;</span><br><span class="line">&gt;            // 组件内容  抱一个div-单个根元素，包在app这个div中</span><br><span class="line">&gt;            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">&gt;            // data必须是函数</span><br><span class="line">&gt;            data()&#123;</span><br><span class="line">&gt;                // return中写数据</span><br><span class="line">&gt;                return &#123;</span><br><span class="line">&gt;                    db: 'hello',</span><br><span class="line">&gt;                &#125;,</span><br><span class="line">&gt;computed: &#123;&#125;,</span><br><span class="line">&gt;watch: &#123;&#125;,</span><br><span class="line">&gt;methods: &#123;&#125;,</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    );</span><br><span class="line">&gt;</span><br><span class="line">&gt;new Vue(&#123;</span><br><span class="line">&gt;        el: '#app',</span><br><span class="line">&gt;        // 根元素会替换div</span><br><span class="line">&gt;        template: `<span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span>`</span><br><span class="line">&gt;    &#125;)</span><br><span class="line">&gt;</span><br><span class="line">&gt;// data 必须是函数</span><br><span class="line">&gt;// 没有属性</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="组件系统之组件的复用"><a href="#组件系统之组件的复用" class="headerlink" title="组件系统之组件的复用"></a>组件系统之组件的复用</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 注册</span></span><br><span class="line"><span class="undefined">&gt;    Vue.component(</span></span><br><span class="line"><span class="undefined">&gt;        // 第一个是组件名称  第二个object</span></span><br><span class="line"><span class="undefined">&gt;        "global-component", &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // 组件内容  抱一个div-单个根元素</span></span><br><span class="line"><span class="xml">&gt;            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;            // data必须是函数</span></span><br><span class="line"><span class="undefined">&gt;            data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;                // return中写数据</span></span><br><span class="line"><span class="undefined">&gt;                return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;            &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    );</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        </span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="组价系统之局部组件的注册"><a href="#组价系统之局部组件的注册" class="headerlink" title="组价系统之局部组件的注册"></a>组价系统之局部组件的注册</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="xml">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;            return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        computed: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="xml">&gt;        template: `<span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            'app-header': Header</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;    <span class="comment">&lt;!--&lt;App&gt;&lt;/App&gt;--&gt;</span>   </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="xml">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;            return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        computed: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // ...</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 在入口组件中注册写的局部组件</span></span><br><span class="line"><span class="undefined">&gt;    let App = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        template: `</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            'app-header': Header</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // 组件的私有数据</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;&#125;,</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 根实例</span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        // 作为根被渲染</span></span><br><span class="line"><span class="xml">&gt;        template: `<span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // App:App,</span></span><br><span class="line"><span class="undefined">&gt;            App,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>局部组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;- 总结</span><br><span class="line">&gt;</span><br><span class="line">&gt;创建组件</span><br><span class="line">&gt;创建局部组件，起始就是创建一个JavaScript object</span><br><span class="line">&gt;    let Header = &#123;</span><br><span class="line">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; db &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">&gt;        data()&#123;</span><br><span class="line">&gt;            return &#123;</span><br><span class="line">&gt;                    db: 'hello',</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;        &#125;,</span><br><span class="line">&gt;        computed: &#123;&#125;,</span><br><span class="line">&gt;    &#125;;</span><br><span class="line">&gt;注册组件</span><br><span class="line">&gt;</span><br><span class="line">&gt;    new Vue(&#123;</span><br><span class="line">&gt;        el: '#app',</span><br><span class="line">&gt;        template: `<span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span>`,</span><br><span class="line">&gt;        components: &#123;</span><br><span class="line">&gt;            'app-header': Header</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;)</span><br><span class="line">&gt;</span><br><span class="line">&gt;组件可以嵌套使用</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h1 id="Vue组件系统之父子组件的通信"><a href="#Vue组件系统之父子组件的通信" class="headerlink" title="Vue组件系统之父子组件的通信"></a>Vue组件系统之父子组件的通信</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 子</span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="undefined">&gt;      template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;h3&gt;&#123;&#123; fData &#125;&#125;&lt;/h3&gt;&lt;&lt;/div&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;            return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                    db: 'hello',</span></span><br><span class="line"><span class="undefined">&gt;                &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // 接收父亲传来的数据</span></span><br><span class="line"><span class="undefined">&gt;        props:['fData'],</span></span><br><span class="line"><span class="undefined">&gt;        computed: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // ...</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 在入口组件中注册写的局部组件</span></span><br><span class="line"><span class="undefined">&gt;    // 父</span></span><br><span class="line"><span class="undefined">&gt;    let App = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        template: `</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">app-header</span> <span class="attr">v-bind:fData</span>=<span class="string">"fatherData"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            'app-header': Header</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // 组件的私有数据</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;            return &#123;fatherData: 0,&#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 根实例</span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        // 作为根被渲染</span></span><br><span class="line"><span class="xml">&gt;        template: `<span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // App:App,</span></span><br><span class="line"><span class="undefined">&gt;            App,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Vue组件系统之子父组件的通信"><a href="#Vue组件系统之子父组件的通信" class="headerlink" title="Vue组件系统之子父组件的通信"></a>Vue组件系统之子父组件的通信</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dic</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 子</span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="xml">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'sonClick'</span>&gt;</span>点击改变字体大小<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        methods: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            sonClick: function()&#123;</span></span><br><span class="line"><span class="undefined">&gt;                // 儿子的的行为传给父亲</span></span><br><span class="line"><span class="undefined">&gt;                this.$emit("change-size", 0.1)</span></span><br><span class="line"><span class="undefined">&gt;            &#125;  </span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        computed: &#123;&#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // ...</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 父</span></span><br><span class="line"><span class="undefined">&gt;    let App = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        template: `</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: postFontSize + 'em' &#125;"</span>&gt;</span>我是字体<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">app-header</span> <span class="attr">v-on:change-size</span>=<span class="string">"fatherClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            'app-header': Header</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        // 组件的私有数据</span></span><br><span class="line"><span class="undefined">&gt;        data()&#123;</span></span><br><span class="line"><span class="undefined">&gt;            return &#123;</span></span><br><span class="line"><span class="undefined">&gt;                postFontSize: 1,</span></span><br><span class="line"><span class="undefined">&gt;            &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        methods: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // 自己定义的change-size事件，一直在监听，等着儿子传来的信息</span></span><br><span class="line"><span class="undefined">&gt;            fatherClick: function(value)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                this.postFontSize += value;</span></span><br><span class="line"><span class="undefined">&gt;            &#125;</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 根实例</span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        // 作为根被渲染</span></span><br><span class="line"><span class="xml">&gt;        template: `<span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            // App:App,</span></span><br><span class="line"><span class="undefined">&gt;            App,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Vue组件系统之混入（mixin）"><a href="#Vue组件系统之混入（mixin）" class="headerlink" title="Vue组件系统之混入（mixin）"></a>Vue组件系统之混入（mixin）</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dic</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">my-header</span>&gt;</span><span class="tag">&lt;/<span class="name">my-header</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">my-app</span>&gt;</span><span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="xml">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'show('</span><span class="attr">xxx</span>')'&gt;</span>点击显示xxx来了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'hide('</span><span class="attr">xxx</span>')'&gt;</span>点击显示xxx去了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        methods: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            show: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;            &#125;,</span></span><br><span class="line"><span class="undefined">&gt;            hide: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;            &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;,</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    let App = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        template: `</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">'show('</span><span class="attr">000</span>')'&gt;</span>点击显示000来了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseleve</span>=<span class="string">'hide('</span><span class="attr">000</span>')'&gt;</span>点击显示000去了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        methods: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            show: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;            &#125;,</span></span><br><span class="line"><span class="undefined">&gt;            hide: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;            &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 根实例</span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            "my-header": Header,</span></span><br><span class="line"><span class="undefined">&gt;            "my-app": App,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">my-header</span>&gt;</span><span class="tag">&lt;/<span class="name">my-header</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">my-app</span>&gt;</span><span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dic</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    let mixs = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        methods:&#123;</span></span><br><span class="line"><span class="undefined">&gt;            show: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                    console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;                &#125;,</span></span><br><span class="line"><span class="undefined">&gt;            hide: function(name)&#123;</span></span><br><span class="line"><span class="undefined">&gt;                    console.log(name+'来了');</span></span><br><span class="line"><span class="undefined">&gt;                &#125;,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;</span></span><br><span class="line"><span class="undefined">&gt;    let Header = &#123;</span></span><br><span class="line"><span class="xml">&gt;      template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'show('</span><span class="attr">xxx</span>')'&gt;</span>点击显示xxx来了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'hide('</span><span class="attr">xxx</span>')'&gt;</span>点击显示xxx去了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        mixins: [mixs],</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    let App = &#123;</span></span><br><span class="line"><span class="undefined">&gt;        template: `</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">'show("000")'</span>&gt;</span>点击显示000来了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseleve</span>=<span class="string">'hide("000")'</span>&gt;</span>点击显示000去了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">&gt;`,</span></span><br><span class="line"><span class="undefined">&gt;        mixins: [mixs],</span></span><br><span class="line"><span class="undefined">&gt;    &#125;;</span></span><br><span class="line"><span class="undefined">&gt;    // 根实例</span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;        components: &#123;</span></span><br><span class="line"><span class="undefined">&gt;            "my-header": Header,</span></span><br><span class="line"><span class="undefined">&gt;            "my-app": App,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h1 id="Vue组件系统之插槽"><a href="#Vue组件系统之插槽" class="headerlink" title="Vue组件系统之插槽"></a>Vue组件系统之插槽<slot></slot></h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;- 内容分发</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    .box &#123;</span></span><br><span class="line"><span class="undefined">&gt;        width: 50px;</span></span><br><span class="line"><span class="undefined">&gt;        height: 50px;</span></span><br><span class="line"><span class="undefined">&gt;        float: left;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">global-component</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span>免费<span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span>收费<span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 注册全局组件</span></span><br><span class="line"><span class="undefined">&gt;    Vue.component(</span></span><br><span class="line"><span class="undefined">&gt;        "global-component", &#123;</span></span><br><span class="line"><span class="xml">&gt;            template: `<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    );</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Vue组件系统之具名插槽"><a href="#Vue组件系统之具名插槽" class="headerlink" title="Vue组件系统之具名插槽"></a>Vue组件系统之具名插槽</h1><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    .box &#123;</span></span><br><span class="line"><span class="undefined">&gt;        width: 50px;</span></span><br><span class="line"><span class="undefined">&gt;        height: 50px;</span></span><br><span class="line"><span class="undefined">&gt;        float: left;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">'home'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">'free'</span>&gt;</span>免费<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">'toll'</span>&gt;</span>收费<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    // 注册全局组件</span></span><br><span class="line"><span class="undefined">&gt;    Vue.component(</span></span><br><span class="line"><span class="undefined">&gt;        "global-component", &#123;</span></span><br><span class="line"><span class="xml">&gt;            template: `<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"home"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"free"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"toll"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="undefined">&gt;        &#125;</span></span><br><span class="line"><span class="undefined">&gt;    );</span></span><br><span class="line"><span class="undefined">&gt;    </span></span><br><span class="line"><span class="undefined">&gt;    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">&gt;        el: '#app',</span></span><br><span class="line"><span class="undefined">&gt;    &#125;)</span></span><br><span class="line"><span class="undefined">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue组件系统之全局组件的注册&quot;&gt;&lt;a href=&quot;#Vue组件系统之全局组件的注册&quot; class=&quot;headerlink&quot; title=&quot;Vue组件系统之全局组件的注册&quot;&gt;&lt;/a&gt;Vue组件系统之全局组件的注册&lt;/h1&gt;&lt;blockquote&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>权限管理的三级菜单的流程</title>
    <link href="http://yoursite.com/2018/08/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/14/权限管理组件流程大总结/</id>
    <published>2018-08-14T08:34:44.000Z</published>
    <updated>2018-11-15T06:39:17.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限管理的三级菜单的流程"><a href="#权限管理的三级菜单的流程" class="headerlink" title="权限管理的三级菜单的流程"></a>权限管理的三级菜单的流程</h1><blockquote><p>权限控制</p><ul><li><p>url代表了权限</p></li><li><p>表结构（6张表，ORM创建4个类，两个many2many会自动再生成两张表）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;  用户表</span><br><span class="line">&gt;  用户名</span><br><span class="line">&gt;  密码</span><br><span class="line">&gt;  多对多 roles(角色)</span><br><span class="line">&gt;  角色表</span><br><span class="line">&gt;  标题 title</span><br><span class="line">&gt;  多对多 permission(权限)</span><br><span class="line">&gt;  权限表</span><br><span class="line">&gt;  标题 title</span><br><span class="line">&gt;  权限 url</span><br><span class="line">&gt;  URL别名 name    - 设置唯一(方便为了将权限粒度控制到按钮级别)</span><br><span class="line">&gt;  外键 menu(菜单)</span><br><span class="line">&gt;  外键 permission(self自己)</span><br><span class="line">&gt;  菜单表</span><br><span class="line">&gt;  标题 title</span><br><span class="line">&gt;  图标 icon</span><br><span class="line">&gt;  权重 weight</span><br><span class="line">&gt;  用户和角色关系表</span><br><span class="line">&gt;  角色和权限的关系表</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;from django.db import models</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;class Menu(models.Model):</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    一级菜单</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;, unique=True)  # 一级菜单的名字</span><br><span class="line">&gt;  &gt;    icon = models.CharField(max_length=32, verbose_name=&apos;图标&apos;, null=True, blank=True)</span><br><span class="line">&gt;  &gt;    weight = models.IntegerField(verbose_name=&apos;权重&apos;, default=1)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    class Meta:</span><br><span class="line">&gt;  &gt;        verbose_name_plural = &apos;菜单表&apos;</span><br><span class="line">&gt;  &gt;        verbose_name = &apos;菜单表&apos;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    def __str__(self):</span><br><span class="line">&gt;  &gt;        return self.title</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;class Permission(models.Model):</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    权限表</span><br><span class="line">&gt;  &gt;    有关联Menu的二级菜单</span><br><span class="line">&gt;  &gt;    没有关联Menu的不是二级菜单，是不可以做菜单的权限</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;)</span><br><span class="line">&gt;  &gt;    url = models.CharField(max_length=32, verbose_name=&apos;权限&apos;)</span><br><span class="line">&gt;  &gt;    menu = models.ForeignKey(&apos;Menu&apos;, null=True, blank=True, verbose_name=&apos;菜单&apos;)</span><br><span class="line">&gt;  &gt;    # 该权限关联的其他权限是否也是在当前url上展示</span><br><span class="line">&gt;  &gt;    parent = models.ForeignKey(to=&apos;Permission&apos;, null=True, blank=True, verbose_name=&apos;父权限&apos;)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    name = models.CharField(max_length=32, null=True, blank=True, unique=True, verbose_name=&apos;权限的别名&apos;)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    class Meta:</span><br><span class="line">&gt;  &gt;        verbose_name_plural = &apos;权限表&apos;</span><br><span class="line">&gt;  &gt;        verbose_name = &apos;权限表&apos;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    def __str__(self):</span><br><span class="line">&gt;  &gt;        return self.title</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;class Role(models.Model):</span><br><span class="line">&gt;  &gt;    name = models.CharField(max_length=32, verbose_name=&apos;角色名称&apos;)</span><br><span class="line">&gt;  &gt;    permissions = models.ManyToManyField(to=&apos;Permission&apos;, verbose_name=&apos;角色所拥有的权限&apos;, blank=True)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    def __str__(self):</span><br><span class="line">&gt;  &gt;        return self.name</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;class User(models.Model):</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    用户表</span><br><span class="line">&gt;  &gt;    &quot;&quot;&quot;</span><br><span class="line">&gt;  &gt;    name = models.CharField(max_length=32, verbose_name=&apos;用户名&apos;)</span><br><span class="line">&gt;  &gt;    password = models.CharField(max_length=32, verbose_name=&apos;密码&apos;)</span><br><span class="line">&gt;  &gt;    roles = models.ManyToManyField(to=&apos;Role&apos;, verbose_name=&apos;用户所拥有的角色&apos;, blank=True)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    def __str__(self):</span><br><span class="line">&gt;  &gt;        return self.name</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><ul><li><p>流程梳理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;  - 当一个url回车发出这个请求后，给到server端先判断这个请求url是不是有访问的权限</span><br><span class="line">&gt;    这个时候我们设置了白名单(在中间件这里(因为一开始就要判断身份))，如果是白名单</span><br><span class="line">&gt;    谁都可以访问</span><br><span class="line">&gt;    eg：</span><br><span class="line">&gt;      PERMISSION_SESSION_KEY = &apos;permissions&apos;</span><br><span class="line">&gt;      MENU_SESSION_KEY = &apos;menus&apos;</span><br><span class="line">&gt;      WHITE_URL_LIST = [</span><br><span class="line">&gt;          r&apos;^/login/$&apos;,</span><br><span class="line">&gt;          r&apos;^/logout/$&apos;,</span><br><span class="line">&gt;          r&apos;^/reg/$&apos;,</span><br><span class="line">&gt;          r&apos;^/admin/.*&apos;,</span><br><span class="line">&gt;      ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  - 这时用户登录，如果登录成功</span><br><span class="line">&gt;    不同的用户对应不同的权限，也就是可以访问不同的url</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;  - 登录成功，(权限信息的初始化)</span><br><span class="line">&gt;    我们该做的就是拿到这个用户对应的权限信息 - ORM(用户信息-角色-权限-菜单)</span><br><span class="line">&gt;    # user = models.User.objects.filter(name=username, password=pwd).first()</span><br><span class="line">&gt;    permission_query = user.roles.filter(permissions__url__isnull=False).values(</span><br><span class="line">&gt;          &apos;permissions__url&apos;,  # 权限url</span><br><span class="line">&gt;          &apos;permissions__title&apos;,  # 权限的标题</span><br><span class="line">&gt;          &apos;permissions__id&apos;,  # 权限的id</span><br><span class="line">&gt;          &apos;permissions__name&apos;,  # 权限的别名</span><br><span class="line">&gt;          &apos;permissions__parent_id&apos;,  # 此权限对应的父权限的id</span><br><span class="line">&gt;          &apos;permissions__parent__name&apos;,  # 次权限对应的父权限的别名</span><br><span class="line">&gt;          &apos;permissions__menu_id&apos;,  # 此权限对应的菜单id</span><br><span class="line">&gt;          &apos;permissions__menu__title&apos;,  # 此权限对应的菜单标题</span><br><span class="line">&gt;          &apos;permissions__menu__icon&apos;,  # 此权限对应的菜单的图标</span><br><span class="line">&gt;          &apos;permissions__menu__weight&apos;,  # 表单排序用的</span><br><span class="line">&gt;      ).distinct()</span><br><span class="line">&gt;    数据结构(字典)</span><br><span class="line">&gt;    permission_dict来存储此权限信息</span><br><span class="line">&gt;    menu_dict来存储菜单信息</span><br><span class="line">&gt;    permission_dict = &#123;</span><br><span class="line">&gt;        &apos;URL的别名&apos;：&#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&apos;pid&apos;,&apos;pname&apos; &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    menu_list = &#123;</span><br><span class="line">&gt;        &apos;菜单ID&apos;：&#123;</span><br><span class="line">&gt;  &apos;title&apos;: 一级菜单的标题，</span><br><span class="line">&gt;  &apos;icon&apos;: 一级菜单的图标，</span><br><span class="line">&gt;  &apos;weight&apos;: 权重，</span><br><span class="line">&gt;  &apos;children&apos;: [</span><br><span class="line">&gt;  &#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&#125;</span><br><span class="line">&gt;  ]</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  权限信息存的就是：</span><br><span class="line">&gt;  当前这个权限的是谁，他的id多少，他的标题是什么，他的父权限是谁(id)，他的父权限的别名是什么</span><br><span class="line">&gt;  菜单信息存的就是：</span><br><span class="line">&gt;  这个权限(url)对应的菜单的标题是什么，菜单的图标是什么，权重是多少，他对应的二级菜单是哪些</span><br><span class="line">&gt;  二级菜单(children)也就是，对应的权限信息</span><br><span class="line">&gt;  这里面存的也就是他的权限信息(他的title，url，id，parent_id)</span><br><span class="line">&gt;  将所有的权限遍历一遍后，将这些信息存入session中</span><br><span class="line">&gt;  为什么存入session，是因为session可以配置(放入缓存，访问次数比较多，所有存到缓存比较好)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;  # 遍历此用户对应的权限信息</span><br><span class="line">&gt;  for item in permission_query:</span><br><span class="line">&gt;  # 首先是权限信息，以权限的别名为键</span><br><span class="line">&gt;          permission_dict[item[&apos;permissions__name&apos;]] = (&#123;</span><br><span class="line">&gt;              &apos;url&apos;: item[&apos;permissions__url&apos;],</span><br><span class="line">&gt;              &apos;id&apos;: item[&apos;permissions__id&apos;],</span><br><span class="line">&gt;              &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],</span><br><span class="line">&gt;              &apos;parent_name&apos;: item[&apos;permissions__parent__name&apos;],</span><br><span class="line">&gt;              &apos;title&apos;: item[&apos;permissions__title&apos;],</span><br><span class="line">&gt;          &#125;)</span><br><span class="line">&gt;          menu_id = item.get(&apos;permissions__menu_id&apos;)</span><br><span class="line">&gt;          if not menu_id:</span><br><span class="line">&gt;              continue</span><br><span class="line">&gt;          if menu_id not in menu_dict:</span><br><span class="line">&gt;              menu_dict[menu_id] = &#123;</span><br><span class="line">&gt;                  &apos;title&apos;: item[&apos;permissions__menu__title&apos;],</span><br><span class="line">&gt;                  &apos;icon&apos;: item[&apos;permissions__menu__icon&apos;],</span><br><span class="line">&gt;                  &apos;weight&apos;: item[&apos;permissions__menu__weight&apos;],</span><br><span class="line">&gt;                  &apos;children&apos;: [</span><br><span class="line">&gt;                      &#123;</span><br><span class="line">&gt;                          &apos;title&apos;: item[&apos;permissions__title&apos;],</span><br><span class="line">&gt;                          &apos;url&apos;: item[&apos;permissions__url&apos;],</span><br><span class="line">&gt;                          &apos;id&apos;: item[&apos;permissions__id&apos;],</span><br><span class="line">&gt;                          &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],</span><br><span class="line">&gt;                      &#125;</span><br><span class="line">&gt;                  ]</span><br><span class="line">&gt;              &#125;</span><br><span class="line">&gt;          else:</span><br><span class="line">&gt;              menu_dict[menu_id][&apos;children&apos;].append(</span><br><span class="line">&gt;                  &#123;</span><br><span class="line">&gt;                      &apos;title&apos;: item[&apos;permissions__title&apos;],</span><br><span class="line">&gt;                      &apos;url&apos;: item[&apos;permissions__url&apos;],</span><br><span class="line">&gt;                      &apos;id&apos;: item[&apos;permissions__id&apos;],</span><br><span class="line">&gt;                      &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],</span><br><span class="line">&gt;                  &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;  - 登录成功后，信息存入session后，这时给服务器发送一个请求，这时就会走中间件进行权限的校验</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  - 走中间件process_request(self, request):</span><br><span class="line">&gt;  - 先获取这个请求的url   request.path_info</span><br><span class="line">&gt;  刚开始也先判断白名单， 白名单不符合从session中获取这个用户存的权限信息</span><br><span class="line">&gt;  permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)</span><br><span class="line">&gt;  - 导航栏可以存这里  - 写了一个inclution_tag来处理</span><br><span class="line">&gt;  request.breadcrumd_list = [</span><br><span class="line">&gt;              &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,</span><br><span class="line">&gt;          ]</span><br><span class="line">&gt;          @register.inclusion_tag(&apos;rbac/breadcrumbs.html&apos;)</span><br><span class="line">&gt;  def breadcrumb(request):</span><br><span class="line">&gt;      return &#123;&quot;breadcrumd_list&quot;: request.breadcrumd_list&#125;</span><br><span class="line">&gt;  - 遍历这个权限信息</span><br><span class="line">&gt;  可以通过正则匹配，匹配他是不是该用户的权限</span><br><span class="line">&gt;  如果匹配成功看他是否由parent_id有是子权限没有是父权限</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  if parent_id:</span><br><span class="line">&gt;          # 表示当前权限是子权限，让父权限是展开</span><br><span class="line">&gt;              request.current_menu_id = parent_id</span><br><span class="line">&gt;              request.breadcrumd_list.extend([</span><br><span class="line">&gt;              &#123;</span><br><span class="line">&gt;                &quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],</span><br><span class="line">&gt;                    &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]</span><br><span class="line">&gt;                   &#125;,</span><br><span class="line">&gt;                     &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,</span><br><span class="line">&gt;                   ])</span><br><span class="line">&gt;           else:</span><br><span class="line">&gt;           # 表示当前权限是父权限，要展开的二级菜单</span><br><span class="line">&gt;              request.current_menu_id = id</span><br><span class="line">&gt;              # 添加面包屑导航</span><br><span class="line">&gt;              request.breadcrumd_list.append(&#123;</span><br><span class="line">&gt;              &quot;title&quot;: item[&apos;title&apos;], </span><br><span class="line">&gt;              &apos;url&apos;: item[&apos;url&apos;]</span><br><span class="line">&gt;              &#125;)</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   - request.current_menu_id</span><br><span class="line">&gt;  这个就是用来展示菜单和展示该权限的子权限为了选中同一个二级菜单的时候用的</span><br><span class="line">&gt;  -写一个includtion_tag</span><br><span class="line">&gt;  - </span><br><span class="line">&gt;     @register.inclusion_tag(&apos;rbac/menu.html&apos;)</span><br><span class="line">&gt;                  def menu(request):</span><br><span class="line">&gt;                      menu_list = request.session.get(settings.MENU_SESSION_KEY)</span><br><span class="line">&gt;                      order_dict = OrderedDict()</span><br><span class="line">&gt;                      for key in sorted(menu_list, key=lambda x: menu_list[x][&apos;weight&apos;], reverse=True):</span><br><span class="line">&gt;                          order_dict[key] = menu_list[key]</span><br><span class="line">&gt;                          item = order_dict[key]</span><br><span class="line">&gt;                          item[&apos;class&apos;] = &apos;hide&apos;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;                          for i in item[&apos;children&apos;]:</span><br><span class="line">&gt;  </span><br><span class="line">&gt;                              if i[&apos;id&apos;] == request.current_menu_id:</span><br><span class="line">&gt;                                  i[&apos;class&apos;] = &apos;active&apos;</span><br><span class="line">&gt;                                  item[&apos;class&apos;] = &apos;&apos;</span><br><span class="line">&gt;                      return &#123;&quot;menu_list&quot;: order_dict&#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt;  from django.utils.deprecation import MiddlewareMixin</span><br><span class="line">&gt;  from django.conf import settings</span><br><span class="line">&gt;  from django.shortcuts import HttpResponse</span><br><span class="line">&gt;  import re</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt;  class PermissionMiddleware(MiddlewareMixin):</span><br><span class="line">&gt;      def process_request(self, request):</span><br><span class="line">&gt;          # 对权限进行校验</span><br><span class="line">&gt;          # 1. 当前访问的URL</span><br><span class="line">&gt;          current_url = request.path_info</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          # 白名单的判断</span><br><span class="line">&gt;          for i in settings.WHITE_URL_LIST:</span><br><span class="line">&gt;              if re.match(i, current_url):</span><br><span class="line">&gt;                  return</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          # 2. 获取当前用户的所有权限信息</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          request.breadcrumd_list = [</span><br><span class="line">&gt;              &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,</span><br><span class="line">&gt;          ]</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          # 3. 权限的校验</span><br><span class="line">&gt;          print(current_url)</span><br><span class="line">&gt;  </span><br><span class="line">&gt;          for item in permission_dict.values():</span><br><span class="line">&gt;              print(permission_dict)</span><br><span class="line">&gt;              url = item[&apos;url&apos;]</span><br><span class="line">&gt;              if re.match(&quot;^&#123;&#125;$&quot;.format(url), current_url):</span><br><span class="line">&gt;                  parent_id = item[&apos;parent_id&apos;]</span><br><span class="line">&gt;                  id = item[&apos;id&apos;]</span><br><span class="line">&gt;                  parent_name = item[&apos;parent_name&apos;]</span><br><span class="line">&gt;                  if parent_id:</span><br><span class="line">&gt;                      # 表示当前权限是子权限，让父权限是展开</span><br><span class="line">&gt;                      request.current_menu_id = parent_id</span><br><span class="line">&gt;                      request.breadcrumd_list.extend([</span><br><span class="line">&gt;                          &#123;&quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],</span><br><span class="line">&gt;                           &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]&#125;,</span><br><span class="line">&gt;                          &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,</span><br><span class="line">&gt;                      ])</span><br><span class="line">&gt;                  else:</span><br><span class="line">&gt;                      # 表示当前权限是父权限，要展开的二级菜单</span><br><span class="line">&gt;                      request.current_menu_id = id</span><br><span class="line">&gt;                      # 添加面包屑导航</span><br><span class="line">&gt;                      request.breadcrumd_list.append(&#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;)</span><br><span class="line">&gt;                  return</span><br><span class="line">&gt;          else:</span><br><span class="line">&gt;              return HttpResponse(&apos;没有权限&apos;)</span><br><span class="line">&gt;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  - 权限力度控制到按钮级别</span><br><span class="line">&gt;  一个filter</span><br><span class="line">&gt;  一个url的反向解析</span><br><span class="line">&gt;  @register.filter</span><br><span class="line">&gt;  def has_permission(request, permission):</span><br><span class="line">&gt;  # session中存的就是权限的别名，别名就是反向解析的那个字符串</span><br><span class="line">&gt;      if permission in request.session.get(settings.PERMISSION_SESSION_KEY):</span><br><span class="line">&gt;          return True</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &#123;% if request|has_permission:&apos;web:customer_edit&apos; or request|has_permission:&apos;web:customer_del&apos; %&#125;</span><br><span class="line">&gt;  &lt;td&gt;</span><br><span class="line">&gt;  &#123;% if request|has_permission:&apos;web:customer_edit&apos; %&#125;</span><br><span class="line">&gt;  &lt;a style=&quot;color: #333333;&quot; href=&quot;&#123;% url &apos;web:customer_edit&apos; row.id %&#125;&quot;&gt;</span><br><span class="line">&gt;  &lt;i class=&quot;fa fa-edit&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt;</span><br><span class="line">&gt;  &#123;% endif %&#125;</span><br><span class="line">&gt;  &#123;% if request|has_permission:&apos;web:customer_del&apos; %&#125;</span><br><span class="line">&gt;  &lt;a style=&quot;color: #d9534f;&quot; href=&quot;&#123;% url &apos;web:customer_del&apos; row.id  %&#125;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot;&gt;&lt;/i&gt;&lt;/a&gt;</span><br><span class="line">&gt;  &#123;% endif %&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h1 id="菜单和权限的展示在一个页面"><a href="#菜单和权限的展示在一个页面" class="headerlink" title="菜单和权限的展示在一个页面"></a>菜单和权限的展示在一个页面</h1><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># 菜单和权限的展示</span></span><br><span class="line">&gt;<span class="comment"># 点击每一个菜单出现对应的权限信息</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">menu_list</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;    all_menu = models.Menu.objects.all()</span><br><span class="line">&gt;    <span class="comment"># 拿到菜单对应的菜单id</span></span><br><span class="line">&gt;    mid = request.GET.get(<span class="string">'mid'</span>)</span><br><span class="line">&gt;    <span class="comment"># 如果拿到菜单id代表着有子权限</span></span><br><span class="line">&gt;    <span class="keyword">if</span> mid:</span><br><span class="line">&gt;        <span class="comment"># 从子权限出发 拿到 父权限对应的菜单id对应的权限  或者  菜单对应的权限（也就是二级菜单） 因为自己关联自己（从父亲和儿子两方面出发）</span></span><br><span class="line">&gt;        permission_query = models.Permission.objects.filter(Q(menu_id=mid) | Q(parent__menu_id=mid))</span><br><span class="line">&gt;    <span class="comment"># 如果没有菜单id则输出所有的权限信息</span></span><br><span class="line">&gt;    <span class="keyword">else</span>:</span><br><span class="line">&gt;        permission_query = models.Permission.objects.all()</span><br><span class="line">&gt;    <span class="comment"># 拿到查询出的权限对应的信息</span></span><br><span class="line">&gt;    all_permission = permission_query.values(<span class="string">'id'</span>, <span class="string">'url'</span>, <span class="string">'title'</span>, <span class="string">'name'</span>, <span class="string">'menu_id'</span>, <span class="string">'parent_id'</span>, <span class="string">'menu__title'</span>)</span><br><span class="line">&gt;    all_permission_dict = &#123;&#125;</span><br><span class="line">&gt;    <span class="keyword">for</span> item <span class="keyword">in</span> all_permission:</span><br><span class="line">&gt;        menu_id = item.get(<span class="string">'menu_id'</span>)</span><br><span class="line">&gt;        <span class="comment"># 找到有菜单id的权限，将其存入字典，键为权限的id</span></span><br><span class="line">&gt;        <span class="keyword">if</span> menu_id:</span><br><span class="line">&gt;            all_permission_dict[item[<span class="string">'id'</span>]] = item</span><br><span class="line">&gt;            <span class="comment"># 可以改都是引用</span></span><br><span class="line">&gt;            <span class="comment"># 得到所有有菜单的权限后，将每一个权限都设置一个children键值对，用来存储子权限信息</span></span><br><span class="line">&gt;            item[<span class="string">'children'</span>] = []</span><br><span class="line">&gt;    <span class="keyword">for</span> item <span class="keyword">in</span> all_permission:</span><br><span class="line">&gt;        pid = item.get(<span class="string">'parent_id'</span>)</span><br><span class="line">&gt;        <span class="comment"># 如果有父id代表的是子权限</span></span><br><span class="line">&gt;        <span class="keyword">if</span> pid:</span><br><span class="line">&gt;            <span class="comment"># 如果是子权限，就将子权限的信息存入多上一步做的处理（有菜单的父权限）children中</span></span><br><span class="line">&gt;            all_permission_dict[pid][<span class="string">'children'</span>].append(item)</span><br><span class="line">&gt;    <span class="keyword">return</span> render(request, <span class="string">'rbac/menu_list.html'</span>, &#123;</span><br><span class="line">&gt;        <span class="string">"mid"</span>: mid,</span><br><span class="line">&gt;        <span class="string">"all_menu"</span>: all_menu,</span><br><span class="line">&gt;        <span class="string">"all_permission_dict"</span>: all_permission_dict,</span><br><span class="line">&gt;    &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="权限系统的应用"><a href="#权限系统的应用" class="headerlink" title="权限系统的应用"></a>权限系统的应用</h1><blockquote><ul><li><p>拷贝rbac  App到新项目中</p></li><li><p>注册APP 以及配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;  #  ###### 权限相关的配置 ######</span><br><span class="line">&gt;  PERMISSION_SESSION_KEY = &apos;permissions&apos;</span><br><span class="line">&gt;  MENU_SESSION_KEY = &apos;menus&apos;</span><br><span class="line">&gt;  WHITE_URL_LIST = [</span><br><span class="line">&gt;      r&apos;^/login/$&apos;,</span><br><span class="line">&gt;      r&apos;^/logout/$&apos;,</span><br><span class="line">&gt;      r&apos;^/reg/$&apos;,</span><br><span class="line">&gt;      r&apos;^/admin/.*&apos;,</span><br><span class="line">&gt;  ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>数据库迁移命令</p><ul><li>删除rbac所有的迁移文件</li><li>执行两条命令</li></ul></li><li><p>路由相关</p><ul><li>url(r’rbac/‘,include(‘rbac.urls’,namespace=’rbac’))</li><li>给所有的URL起名字</li></ul></li><li><p>layout  模板注意</p><ul><li>block   css  js   content</li></ul></li><li><p>权限的管理</p><ul><li>添加角色</li><li>添加菜单</li><li>添加权限</li></ul></li><li><p>分配权限</p><ul><li><p>用户关联—修改原系统的用户表</p><ul><li>跟rbac的UserInfo<br>user = models.OneToOneField(UserInfo,null=True,blank=True)</li><li>给用户分角色</li><li>给角色分权限</li></ul></li><li><p>登录应用权限</p><ul><li><p>登录成功后</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;      auth.login(request, obj)</span><br><span class="line">&gt;      ret = init_permission(request, obj)</span><br><span class="line">&gt;      if ret:</span><br><span class="line">&gt;          return ret</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></blockquote><blockquote><ul><li><p>初始化权限信息init_permission函数中修改</p><p>user -&gt; user.user</p><p>permission_query = user.user.roles.filter</p></li><li><p>应用权限校验中间件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;      &apos;rbac.middleware.rbac.PermissionMiddleware&apos;,</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>应用左侧菜单和面包屑导航</p><ul><li><p>在layout模板中，引用CSS和JS</p></li><li><p>二级菜单</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &#123;% load rbac %&#125;</span><br><span class="line">&gt;    &#123;% menu request %&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><blockquote><ul><li><p>应用路径导航</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &#123;% breadcrumb request %&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>权限控制到按钮级别</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &#123;% load rbac %&#125;</span><br><span class="line">&gt;    判断 filter  判断里面只能用filter 只能一个一个判断</span><br><span class="line">&gt;    &#123;% load rbac %&#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &#123;% if request|has_permission:&apos;add_customer&apos; %&#125;</span><br><span class="line">&gt;    &lt;a href=&quot;&#123;% url &apos;add_customer&apos; %&#125;?&#123;&#123; query_params &#125;&#125;&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;添加&lt;/a&gt;</span><br><span class="line">&gt;    &#123;% endif %&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><blockquote><ul><li><p>使用注意事项</p><ul><li>用户注册后  对应在rbac中的UserInfo创建用户 和 原系统的用户做一对一关联</li><li>菜单   父权限  子权限  的层级关系</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;权限管理的三级菜单的流程&quot;&gt;&lt;a href=&quot;#权限管理的三级菜单的流程&quot; class=&quot;headerlink&quot; title=&quot;权限管理的三级菜单的流程&quot;&gt;&lt;/a&gt;权限管理的三级菜单的流程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;权限控制&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="RBAC" scheme="http://yoursite.com/categories/RBAC/"/>
    
    
  </entry>
  
  <entry>
    <title>Django之中间件</title>
    <link href="http://yoursite.com/2018/07/15/Django%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/15/Django之中间件/</id>
    <published>2018-07-15T07:38:48.000Z</published>
    <updated>2018-11-15T09:46:31.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><blockquote><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><ul><li><p>中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局</p><p>上改变django的输入与输出。因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。</p></li><li><p>Django的中间件的定义：</p><blockquote><p>Middleware <code>is` `a framework of hooks into Django’s request</code>/<code>response processing.</code></p><p><code>&lt;br&gt;It’s a light, low</code>-<code>level “plugin” system</code>forglobally altering Django’s <code>input</code> <code>or</code></p><p><code>output</code>.</p></blockquote><p>应用：</p><ul><li><p>如果想修改请求，例如被传送到view中的<strong>HttpRequest</strong>对象。 或者想修改view返回的HttpResponse对象，这些都可以通过中间件来实现。</p></li><li><p>可能还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。</p></li><li><p>我们可能频繁在view使用<code>request.user</code>吧。 Django想在每个view执行之前把user设置request</p><p>的属性，于是就用了一个中间件来实现这个目标。所以Django提供了可以修改request 对象的中间</p><p>件 <code>AuthenticationMiddleware</code>。</p><p>Django默认的Middleware：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;    MIDDLEWARE = [</span><br><span class="line">&gt;        <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">&gt;        <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">&gt;    ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><blockquote><p>   每一个中间件都有具体的功能</p></blockquote><blockquote><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><ul><li><p>中间件一共有四种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="comment"># process_request</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  <span class="comment"># process_view</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  <span class="comment">#　process_exception</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  <span class="comment">#　process_response</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><h6 id="process-request-process-response"><a href="#process-request-process-response" class="headerlink" title="process_request,process_response"></a>process_request,process_response</h6><blockquote><ul><li><p>当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。</p></li><li><p>我们也可以自己定义一个中间件，我们可以自己写一个类，但是必须继承MiddlewareMixin</p><p>需要导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  <span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></blockquote><blockquote><blockquote><p> <img src="/Users/busensei/Desktop/MiddlewareMixin.png" alt=""></p><blockquote><p><strong>in views:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  &gt;<span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;</span><br><span class="line">&gt;  &gt;  &gt;    print(<span class="string">"view函数..."</span>)</span><br><span class="line">&gt;  &gt;  &gt;    <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line">&gt;  &gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p><strong>in Mymiddlewares.py：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  &gt;<span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line">&gt;  &gt;  &gt;<span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line">&gt;  &gt;  &gt;</span><br><span class="line">&gt;  &gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;</span><br><span class="line">&gt;  &gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;        print(<span class="string">"Md1请求"</span>)</span><br><span class="line">&gt;  &gt;  &gt; </span><br><span class="line">&gt;  &gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;        print(<span class="string">"Md1返回"</span>)</span><br><span class="line">&gt;  &gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;  &gt;</span><br><span class="line">&gt;  &gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;</span><br><span class="line">&gt;  &gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;        print(<span class="string">"Md2请求"</span>)</span><br><span class="line">&gt;  &gt;  &gt;        <span class="comment">#return HttpResponse("Md2中断")</span></span><br><span class="line">&gt;  &gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;  &gt;        print(<span class="string">"Md2返回"</span>)</span><br><span class="line">&gt;  &gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p><strong>结果：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;  &gt;view函数...</span><br><span class="line">&gt;  &gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p><strong>注意：</strong>如果当请求到达请求2的时候直接不符合条件返回，即return HttpResponse(“Md2中断”)，程序将把请求直接发给中间件2返回，然后依次返回到请求者，结果如下：</p><p>返回Md2中断的页面，后台打印如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>流程图如下：</p><p><img src="/Users/busensei/Desktop/process_request，process_response.png" alt=""></p></blockquote></blockquote><h5 id="process-view"><a href="#process-view" class="headerlink" title="process_view"></a>process_view</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;process_view(self, request, callback, callback_args, callback_kwargs)</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p><strong>Mymiddlewares.py</strong>修改如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;<span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line">&gt;  &gt;<span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1请求"</span>)</span><br><span class="line">&gt;  &gt;        <span class="comment">#return HttpResponse("Md1中断")</span></span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1返回"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1view"</span>)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md2请求"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> HttpResponse(<span class="string">"Md2中断"</span>)</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md2返回"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md2view"</span>)</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;Md1view</span><br><span class="line">&gt;  &gt;Md2view</span><br><span class="line">&gt;  &gt;view函数...</span><br><span class="line">&gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>下图进行分析上面的过程：</p><p><img src="/Users/busensei/Desktop/process_view.png" alt="img"></p><p>当最后一个中间的process_request到达路由关系映射之后，返回到中间件1的process_view，然后</p><p>依次往下，到达views函数，最后通过process_response依次返回到达用户。</p><p>process_view可以用来调用视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1请求"</span>)</span><br><span class="line">&gt;  &gt;        <span class="comment">#return HttpResponse("Md1中断")</span></span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1返回"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;        <span class="comment"># return HttpResponse("hello")</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;        response=callback(request,*callback_args,**callback_kwargs)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;view函数...</span><br><span class="line">&gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>注意：process_view如果有返回值，会越过其他的process_view以及视图函数，但是所有的</p><p>process_response都还会执行。</p></blockquote><h5 id="process-exception"><a href="#process-exception" class="headerlink" title="process_exception"></a>process_exception</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;process_exception(self, request, exception)</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>示例修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1请求"</span>)</span><br><span class="line">&gt;  &gt;        <span class="comment">#return HttpResponse("Md1中断")</span></span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md1返回"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;        <span class="comment"># return HttpResponse("hello")</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;        <span class="comment"># response=callback(request,*callback_args,**callback_kwargs)</span></span><br><span class="line">&gt;  &gt;        <span class="comment"># return response</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"md1 process_view..."</span>)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"md1 process_exception..."</span>)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;<span class="class"><span class="keyword">class</span> <span class="title">Md2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md2请求"</span>)</span><br><span class="line">&gt;  &gt;        <span class="comment"># return HttpResponse("Md2中断")</span></span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"Md2返回"</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> response</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"md2 process_view..."</span>)</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;  &gt;        print(<span class="string">"md1 process_exception..."</span>)</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;md1 process_view...</span><br><span class="line">&gt;  &gt;md2 process_view...</span><br><span class="line">&gt;  &gt;view函数...</span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>流程图如下：</p><p>当views出现错误时：</p><p><img src="/Users/busensei/Desktop/process_exception.png" alt="img"></p><p>将md2的process_exception修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;  <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self,request,exception)</span>:</span></span><br><span class="line">&gt;  &gt;</span><br><span class="line">&gt;  &gt;        print(<span class="string">"md2 process_exception..."</span>)</span><br><span class="line">&gt;  &gt;        <span class="keyword">return</span> HttpResponse(<span class="string">"error"</span>)</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;Md1请求</span><br><span class="line">&gt;  &gt;Md2请求</span><br><span class="line">&gt;  &gt;md1 process_view...</span><br><span class="line">&gt;  &gt;md2 process_view...</span><br><span class="line">&gt;  &gt;view函数...</span><br><span class="line">&gt;  &gt;md2 process_exception...</span><br><span class="line">&gt;  &gt;Md2返回</span><br><span class="line">&gt;  &gt;Md1返回</span><br><span class="line">&gt;  &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;中间件的概念&quot;&gt;&lt;a href=&quot;#中间件的概念&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Python之Linux下的virtualenv&amp;&amp;virtualenvwrapper</title>
    <link href="http://yoursite.com/2018/06/03/Python%E4%B9%8BLinux%E4%B8%8B%E7%9A%84virtualenv-virtualenvwrapper/"/>
    <id>http://yoursite.com/2018/06/03/Python之Linux下的virtualenv-virtualenvwrapper/</id>
    <published>2018-06-03T04:51:45.000Z</published>
    <updated>2018-12-03T04:54:42.796Z</updated>
    
    <content type="html"><![CDATA[<p>virtualenv 可以在系统中建立多个不同并且相互不干扰的虚拟环境。</p><pre><code>#指定清华源下载pip的包pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv#升级pip工具pip3 install --upgrade pip</code></pre><h1 id="一、Linux下安装、配置、使用virtualenv"><a href="#一、Linux下安装、配置、使用virtualenv" class="headerlink" title="一、Linux下安装、配置、使用virtualenv"></a>一、Linux下安装、配置、使用virtualenv</h1><pre><code>1.安装virtualenvpip3 install virtualenv 2.创建目录mkdir Myprojectcd Myproject3.创建独立运行环境-命名virtualenv --no-site-packages --python=python3  venv#得到独立第三方包的环境，并且指定解释器是python34.进入虚拟环境source venv/bin/activate#此时进入虚拟环境(venv)Myproject5.安装第三方包(venv)Myproject: pip3 install django==1.9.8#此时pip的包都会安装到venv环境下，venv是针对Myproject创建的6.退出venv环境deactivate命令7.virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</code></pre><h1 id="二、确保开发环境的一致性"><a href="#二、确保开发环境的一致性" class="headerlink" title="二、确保开发环境的一致性"></a>二、确保开发环境的一致性</h1><pre><code>1.假设我们在本地开发环境，准备好了项目+依赖包环境2.现在需要将项目上传至服务器，上线发布3.那么就要保证服务器的python环境一致性解决方案：1.通过命令保证环境的一致性，导出当前python环境的包pip3 freeze &gt; requirements.txt   这将会创建一个 requirements.txt 文件，其中包含了当前环境中所有包及 各自的版本的简单列表。可以使用 “pip list”在不产生requirements文件的情况下， 查看已安装包的列表。2.上传至服务器后，在服务器下创建virtualenv，在venv中导入项目所需的模块依赖pip3 install -r requirements.txt</code></pre><h1 id="三、虚拟环境之virtualenvwrapper"><a href="#三、虚拟环境之virtualenvwrapper" class="headerlink" title="三、虚拟环境之virtualenvwrapper"></a>三、虚拟环境之virtualenvwrapper</h1><pre><code>virtualenv 的一个最大的缺点就是：每次开启虚拟环境之前要去虚拟环境所在目录下的 bin 目录下 source 一下 activate，这就需要我们记住每个虚拟环境所在的目录。并且还有可能你忘记了虚拟环境放在哪。。。一种可行的解决方案是，将所有的虚拟环境目录全都集中起来，例如/opt/all_venv/，并且针对不同的目录做不同的事。使用virtualenvwrapper管理你的虚拟环境（virtualenv），其实他就是统一管理虚拟环境的目录，并且省去了source的步骤。</code></pre><h2 id="步骤1：安装virtualenvwrapper"><a href="#步骤1：安装virtualenvwrapper" class="headerlink" title="步骤1：安装virtualenvwrapper"></a>步骤1：安装virtualenvwrapper</h2><p>pip3 install virtualenvwrapper</p><h2 id="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"><a href="#步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper" class="headerlink" title="步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper"></a>步骤2：设置Linux的环境变量，每次启动就加载virtualenvwrapper</h2><pre><code>把下面两行代码添加到 ~/.bashrc文件中打开文件vim ~/.bashrc写入以下两行代码export WORKON_HOME=~/Envs   #设置virtualenv的统一管理目录export VIRTUALENVWRAPPER_VIRTUALENV_ARGS=&apos;--no-site-packages&apos;   #添加virtualenvwrapper的参数，生成干净隔绝的环境export VIRTUALENVWRAPPER_PYTHON=/opt/python347/bin/python3     #指定python解释器source /opt/python34/bin/virtualenvwrapper.sh #执行virtualenvwrapper安装脚本读取文件，使得生效，此时已经可以使用virtalenvwrappersource ~/.bashrc</code></pre><h2 id="步骤3：基本使用virtualenvwrapper"><a href="#步骤3：基本使用virtualenvwrapper" class="headerlink" title="步骤3：基本使用virtualenvwrapper"></a>步骤3：基本使用virtualenvwrapper</h2><pre><code>创建一个虚拟环境：$ mkvirtualenv my_django115这会在 ~/Envs 中创建 my_django115 文件夹。在虚拟环境上工作：激活虚拟环境my_django115$ workon my_django115再创建一个新的虚拟环境$ mkvirtualenv my_django2virtualenvwrapper 提供环境名字的tab补全功能。当有很多环境， 并且很难记住它们的名字时，这就显得很有用。workon还可以任意停止你当前的环境，可以在多个虚拟环境中来回切换workon django1.15workon django2.0也可以手动停止虚拟环境deactivate删除虚拟环境，需要先退出虚拟环境rmvirtualenv my_django115</code></pre><h2 id="步骤四：常用其他命令"><a href="#步骤四：常用其他命令" class="headerlink" title="步骤四：常用其他命令"></a>步骤四：常用其他命令</h2><pre><code>lsvirtualenv列举所有的环境。cdvirtualenv导航到当前激活的虚拟环境的目录中，比如说这样您就能够浏览它的 site-packages 。cdsitepackages和上面的类似，但是是直接进入到 site-packages 目录中。lssitepackages显示 site-packages 目录中的内容。完整官网介绍：https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;virtualenv 可以在系统中建立多个不同并且相互不干扰的虚拟环境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#指定清华源下载pip的包
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv
#升级
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql主从复制</title>
    <link href="http://yoursite.com/2018/05/05/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2018/05/05/mysql主从复制/</id>
    <published>2018-05-05T12:08:02.000Z</published>
    <updated>2018-12-05T12:15:54.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h1><pre><code>备份mysqldump -u root -p --all-databases &gt; /tmp/mysql.dump恢复mysql -uroot -p &lt; /tmp/mysql.dump</code></pre><h1 id="mysql-主从复制"><a href="#mysql-主从复制" class="headerlink" title="mysql 主从复制"></a>mysql 主从复制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主从机制实现原理：</span><br><span class="line">(1) master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； </span><br><span class="line">(2) slave将master的binary log events拷贝到它的中继日志(relay log)； </span><br><span class="line">(3) slave重做中继日志中的事件，将改变反映它自己的数据。</span><br></pre></td></tr></table></figure><h2 id="master-主库配置："><a href="#master-主库配置：" class="headerlink" title="master 主库配置："></a>master 主库配置：</h2><ol><li>修改配置文件my.cnf，在[mysqld]节点增加两行内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">　　 server-id=1  # 服务的唯一标识，主从之间要不同</span><br><span class="line">　　 log-bin=mysql-bin  # master将改变保存到二进制文件的名称</span><br></pre></td></tr></table></figure></li></ol><p>master 主库添加从库账号：</p><ol><li><p>新建用于主从同步的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;gandoufu&apos;@&apos;%&apos; identified by &apos;123&apos;;</span><br><span class="line">如果提示密码太简单不复合策略加在前面加这句</span><br><span class="line">mysql&gt; set global validate_password_policy=0;</span><br></pre></td></tr></table></figure></li><li><p>给从库账号授权，给上一步新建的用户<code>gandoufu</code>从库复制的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to &apos;ganfoufu&apos;@&apos;%&apos;;</span><br><span class="line">检查授权账号的权限：</span><br><span class="line">    show grants for &apos;ganfoufu&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure></li><li><p>实现对主数据库锁表只读，防止数据写入，数据复制失败</p><p> <strong>flush table with read lock;</strong></p></li><li><p>检查主库的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show master status;                                                   │</span><br><span class="line">+-------------------+----------+--------------+------------------+                      │</span><br><span class="line">| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |                      │</span><br><span class="line">+-------------------+----------+--------------+------------------+                      │</span><br><span class="line">| master-bin.000001 |      473 |              |                  |                      │</span><br><span class="line">+-------------------+----------+--------------+------------------+                      │</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><p>File是二进制日志文件名，Position 是日志开始的位置。后面配置从库时会用到。</p><ol start="5"><li><p>锁表后，导出数据库的所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --all-databases &gt; /tmp/mysql.dump</span><br></pre></td></tr></table></figure></li><li><p>导出数据完毕后，解锁主库，恢复可写；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure></li><li><p>将备份导出的数据scp至Slave数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /tmp/mysql.dump root@slave_server_ip:/tmp/</span><br></pre></td></tr></table></figure></li></ol><h2 id="slave-从库配置："><a href="#slave-从库配置：" class="headerlink" title="slave 从库配置："></a>slave 从库配置：</h2><p>从库我用的是centos6</p><ol><li><p>设置server-id值并关闭binlog功能参数</p><p> 数据库的server-id在主从复制体系内是唯一的，Slave的server-id要与主库和其他从库不同，并且注释掉Slave的binlog参数。<br> 修改Slave的/etc/my.cnf，写入一行内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=6</span><br></pre></td></tr></table></figure><ol start="2"><li><p>重启数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure></li><li><p>检查slave从数据库的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;server_id&apos;;</span><br></pre></td></tr></table></figure></li><li><p>恢复主库Master的数据导入到Slave库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /tmp/mysql.dump;</span><br></pre></td></tr></table></figure></li><li><p>配置复制的参数，Slave从库连接Master主库的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; change master to master_host=&apos;192.168.12.99&apos;,</span><br><span class="line">master_user=&apos;jia&apos;,</span><br><span class="line">master_password=&apos;1234&apos;,</span><br><span class="line">master_log_file=&apos;master1.000001&apos;,</span><br><span class="line">master_log_pos=564;</span><br></pre></td></tr></table></figure></li><li><p>启动从库的同步开关，测试主从复制的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看复制情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure></li></ol><p>检查两条参数，如果都是yes，即主从ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure></p><p>这时在主服务器中修改数据，都会自动同步到从服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库备份与恢复&quot;&gt;&lt;a href=&quot;#数据库备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;数据库备份与恢复&quot;&gt;&lt;/a&gt;数据库备份与恢复&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;备份
mysqldump -u root -p --all-database
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>redis之python使用手册</title>
    <link href="http://yoursite.com/2018/03/23/redis%E4%B9%8Bpython%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2018/03/23/redis之python使用手册/</id>
    <published>2018-03-23T10:43:30.000Z</published>
    <updated>2018-11-23T11:11:25.936Z</updated>
    
    <content type="html"><![CDATA[<p>Redis for Python开发手册</p><h1 id="redis基本命令-String"><a href="#redis基本命令-String" class="headerlink" title="redis基本命令 String"></a>redis基本命令 String</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>set(name, value, ex=None, px=None, nx=False, xx=False)在Redis中设置值，默认，不存在则创建，存在则修改参数说明：ex，过期时间（秒）px，过期时间（毫秒）nx，如果设置为True，则只有name不存在时，当前set操作才执行xx，如果设置为True，则只有name存在时，当前set操作才执行1.ex，过期时间（秒） 这里过期时间是3秒，3秒后p，键food的值就变成Noneimport redispool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.set(&apos;food&apos;, &apos;mutton&apos;, ex=3)    # key是&quot;food&quot; value是&quot;mutton&quot; 将键值对存入redis缓存print(r.get(&apos;food&apos;))  # mutton 取出键food对应的值2.px，过期时间（豪秒） 这里过期时间是3豪秒，3毫秒后，键foo的值就变成Noneimport redispool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.set(&apos;food&apos;, &apos;beef&apos;, px=3)print(r.get(&apos;food&apos;))3.nx，如果设置为True，则只有name不存在时，当前set操作才执行 （新建）import redispool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)print(r.set(&apos;fruit&apos;, &apos;watermelon&apos;, nx=True))    # True--不存在# 如果键fruit不存在，那么输出是True；如果键fruit已经存在，输出是None4.xx，如果设置为True，则只有name存在时，当前set操作才执行 （修改）print((r.set(&apos;fruit&apos;, &apos;watermelon&apos;, xx=True)))   # True--已经存在# 如果键fruit已经存在，那么输出是True；如果键fruit不存在，输出是None5.setnx(name, value)设置值，只有name不存在时，执行设置操作（添加）print(r.setnx(&apos;fruit1&apos;, &apos;banana&apos;))  # fruit1不存在，输出为True</code></pre><h2 id="setex"><a href="#setex" class="headerlink" title="setex"></a>setex</h2><pre><code>setex(name, value, time)设置值参数：time，过期时间（数字秒 或 timedelta对象）import redisimport timepool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.setex(&quot;fruit2&quot;, &quot;orange&quot;, 5)time.sleep(5)print(r.get(&apos;fruit2&apos;))  # 5秒后，取值就从orange变成None</code></pre><h2 id="psetex"><a href="#psetex" class="headerlink" title="psetex"></a>psetex</h2><pre><code>psetex(name, time_ms, value)设置值参数：time_ms，过期时间（数字毫秒 或 timedelta对象）r.psetex(&quot;fruit3&quot;, 5000, &quot;apple&quot;)time.sleep(5)print(r.get(&apos;fruit3&apos;))  # 5000毫秒后，取值就从apple变成None</code></pre><h2 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h2><pre><code>mset(args, *kwargs)批量设置值如：r.mget({&apos;k1&apos;: &apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})r.mset(k1=&quot;v1&quot;, k2=&quot;v2&quot;) # 这里k1 和k2 不能带引号 一次设置对个键值对print(r.mget(&quot;k1&quot;, &quot;k2&quot;))   # 一次取出多个键对应的值print(r.mget(&quot;k1&quot;))</code></pre><h2 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h2><pre><code>mget(keys, *args)批量获取如：print(r.mget(&apos;k1&apos;, &apos;k2&apos;))print(r.mget([&apos;k1&apos;, &apos;k2&apos;]))print(r.mget(&quot;fruit&quot;, &quot;fruit1&quot;, &quot;fruit2&quot;, &quot;k1&quot;, &quot;k2&quot;))  # 将目前redis缓存中的键对应的值批量取出来</code></pre><h2 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h2><pre><code>getset(name, value)设置新值并获取原来的值print(r.getset(&quot;food&quot;, &quot;barbecue&quot;))  # 设置的新值是barbecue 设置前的值是beef1getrangegetrange(key, start, end)获取子序列（根据字节获取，非字符）参数：name，Redis 的 namestart，起始位置（字节）end，结束位置（字节）如： “君惜大大” ，0-3表示 “君”r.set(&quot;cn_name&quot;, &quot;君惜大大&quot;) # 汉字print(r.getrange(&quot;cn_name&quot;, 0, 2))   # 取索引号是0-2 前3位的字节 君 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）print(r.getrange(&quot;cn_name&quot;, 0, -1))  # 取所有的字节 君惜大大 切片操作r.set(&quot;en_name&quot;,&quot;junxi&quot;) # 字母print(r.getrange(&quot;en_name&quot;, 0, 2))  # 取索引号是0-2 前3位的字节 jun 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）print(r.getrange(&quot;en_name&quot;, 0, -1)) # 取所有的字节 junxi 切片操作</code></pre><h2 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h2><pre><code>setrange(name, offset, value)修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）参数：offset，字符串的索引，字节（一个汉字三个字节）value，要设置的值r.setrange(&quot;en_name&quot;, 1, &quot;ccc&quot;)print(r.get(&quot;en_name&quot;))    # jccci 原始值是junxi 从索引号是1开始替换成ccc 变成 jccci2</code></pre><h2 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h2><pre><code>setbit(name, offset, value)对name对应值的二进制表示的位进行操作参数：name，redis的nameoffset，位的索引（将值变换成二进制后再进行索引）value，值只能是 1 或 0注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，那么字符串foo的二进制表示为：01100110 01101111 01101111所以，如果执行 setbit(&apos;n1&apos;, 7, 1)，则就会将第7位设置为1，那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;扩展，转换二进制表示：source = &quot;郭加磊&quot;source = &quot;foo&quot;for i in source:num = ord(i)print bin(num).replace(&apos;b&apos;,&apos;&apos;)特别的，如果source是汉字 &quot;郭加磊&quot;怎么办？答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;郭加磊&quot; 则有 9个字节对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000</code></pre><h2 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h2><pre><code>getbit(name, offset)获取name对应的值的二进制表示中的某位的值 （0或1）print(r.getbit(&quot;foo1&quot;, 0)) # 0 foo1 对应的二进制 4个字节 32位 第0位是0还是1bitcountbitcount(key, start=None, end=None)获取name对应的值的二进制表示中 1 的个数参数：key，Redis的namestart 字节起始位置end，字节结束位置print(r.get(&quot;foo&quot;))  # goo1 01100111print(r.bitcount(&quot;foo&quot;,0,1))  # 11 表示前2个字节中，1出现的个数</code></pre><h2 id="bittop"><a href="#bittop" class="headerlink" title="bittop"></a>bittop</h2><pre><code>bitop(operation, dest, *keys)获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值参数：operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）dest, 新的Redis的name*keys,要查找的Redis的name如：bitop(&quot;AND&quot;, &apos;new_name&apos;, &apos;n1&apos;, &apos;n2&apos;, &apos;n3&apos;)获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中r.set(&quot;foo&quot;,&quot;1&quot;)  # 0110001r.set(&quot;foo1&quot;,&quot;2&quot;)  # 0110010print(r.mget(&quot;foo&quot;,&quot;foo1&quot;))  # [&apos;goo1&apos;, &apos;baaanew&apos;]print(r.bitop(&quot;AND&quot;,&quot;new&quot;,&quot;foo&quot;,&quot;foo1&quot;))  # &quot;new&quot; 0 0110000print(r.mget(&quot;foo&quot;,&quot;foo1&quot;,&quot;new&quot;))source = &quot;12&quot;for i in source:num = ord(i)print(num)  # 打印每个字母字符或者汉字字符对应的ascii码值 f-102-0b100111-01100111print(bin(num))  # 打印每个10进制ascii码值转换成二进制的值 0b1100110（0b表示二进制）print bin(num).replace(&apos;b&apos;,&apos;&apos;)  # 将二进制0b1100110替换成01100110</code></pre><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><pre><code>strlen(name)返回name对应值的字节长度（一个汉字3个字节）print(r.strlen(&quot;foo&quot;))  # 4 &apos;goo1&apos;的长度是4incrincr(self, name, amount=1)自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。参数：name,Redis的nameamount,自增数（必须是整数）注：同incrbyr.set(&quot;foo&quot;, 123)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))r.incr(&quot;foo&quot;, amount=1)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))应用场景 – 页面点击数假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。当redis服务器启动时，可以从关系数据库读入点击数的初始值（12306这个页面被访问了34634次）r.set(&quot;visit:12306:totals&quot;, 34634)print(r.get(&quot;visit:12306:totals&quot;))每当有一个页面点击，则使用INCR增加点击数即可。r.incr(&quot;visit:12306:totals&quot;)r.incr(&quot;visit:12306:totals&quot;)页面载入的时候则可直接获取这个值print(r.get(&quot;visit:12306:totals&quot;))</code></pre><h2 id="incrfloat"><a href="#incrfloat" class="headerlink" title="incrfloat"></a>incrfloat</h2><pre><code>incrbyfloat(self, name, amount=1.0)自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。参数：name,Redis的nameamount,自增数（浮点型）r.set(&quot;foo1&quot;, &quot;123.0&quot;)r.set(&quot;foo2&quot;, &quot;221.0&quot;)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))r.incrbyfloat(&quot;foo1&quot;, amount=2.0)r.incrbyfloat(&quot;foo2&quot;, amount=3.0)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))</code></pre><h2 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h2><pre><code>decr(self, name, amount=1)自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。参数：name,Redis的nameamount,自减数（整数)r.decr(&quot;foo4&quot;, amount=3) # 递减3r.decr(&quot;foo1&quot;, amount=1) # 递减1print(r.mget(&quot;foo1&quot;, &quot;foo4&quot;))</code></pre><h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><pre><code>append(key, value)在redis name对应的值后面追加内容参数：key, redis的namevalue, 要追加的字符串r.append(&quot;name&quot;, &quot;haha&quot;)    # 在name对应的值junxi后面追加字符串hahaprint(r.mget(&quot;name&quot;))</code></pre><h1 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h1><h2 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h2><p>1.单个增加–修改(单个取出)–没有就新增，有的话就修改<br>hset(name, key, value)<br>    name对应的hash中设置一个键值对（不存在，则创建；否则，修改）<br>    参数：<br>    name，redis的name<br>    key，name对应的hash中的key<br>    value，name对应的hash中的value<br>    注：<br>    hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）<br>    import redis<br>    import time</p><pre><code>pool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.hset(&quot;hash1&quot;, &quot;k1&quot;, &quot;v1&quot;)r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v2&quot;)print(r.hkeys(&quot;hash1&quot;)) # 取hash中所有的keyprint(r.hget(&quot;hash1&quot;, &quot;k1&quot;))    # 单个取hash的key对应的值print(r.hmget(&quot;hash1&quot;, &quot;k1&quot;, &quot;k2&quot;)) # 多个取hash的key对应的值r.hsetnx(&quot;hash1&quot;, &quot;k2&quot;, &quot;v3&quot;) # 只能新建print(r.hget(&quot;hash1&quot;, &quot;k2&quot;))</code></pre><h2 id="hmset"><a href="#hmset" class="headerlink" title="hmset"></a>hmset</h2><pre><code>批量增加（取出）hmset(name, mapping)在name对应的hash中批量设置键值对参数：name，redis的namemapping，字典，如：{‘k1’:’v1’, ‘k2’: ‘v2’}如：r.hmset(&quot;hash2&quot;, {&quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;})hget(name,key)在name对应的hash中获取根据key获取valuehmgethmget(name, keys, *args)在name对应的hash中获取多个key的值参数：name，reids对应的namekeys，要获取key集合，如：[‘k1’, ‘k2’, ‘k3’]*args，要获取的key，如：k1,k2,k3如：print(r.hget(&quot;hash2&quot;, &quot;k2&quot;))  # 单个取出&quot;hash2&quot;的key-k2对应的valueprint(r.hmget(&quot;hash2&quot;, &quot;k2&quot;, &quot;k3&quot;))  # 批量取出&quot;hash2&quot;的key-k2 k3对应的value --方式1print(r.hmget(&quot;hash2&quot;, [&quot;k2&quot;, &quot;k3&quot;]))  # 批量取出&quot;hash2&quot;的key-k2 k3对应的value </code></pre><h2 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h2><pre><code>取出所有的键值对hgetall(name)获取name对应hash的所有键值print(r.hgetall(&quot;hash1&quot;))</code></pre><h2 id="hlen"><a href="#hlen" class="headerlink" title="hlen"></a>hlen</h2><pre><code>得到所有键值对的格式 hash长度</code></pre><h2 id="hlen-name"><a href="#hlen-name" class="headerlink" title="hlen(name)"></a>hlen(name)</h2><pre><code>获取name对应的hash中键值对的个数print(r.hlen(&quot;hash1&quot;))</code></pre><h2 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h2><pre><code>得到所有的keys（类似字典的取所有keys）</code></pre><h2 id="hkeys-name"><a href="#hkeys-name" class="headerlink" title="hkeys(name)"></a>hkeys(name)</h2><pre><code>获取name对应的hash中所有的key的值print(r.hkeys(&quot;hash1&quot;))</code></pre><h2 id="hvals"><a href="#hvals" class="headerlink" title="hvals"></a>hvals</h2><pre><code>得到所有的value（类似字典的取所有value）</code></pre><h2 id="hvals-name"><a href="#hvals-name" class="headerlink" title="hvals(name)"></a>hvals(name)</h2><pre><code>获取name对应的hash中所有的value的值print(r.hvals(&quot;hash1&quot;))</code></pre><h2 id="hexists"><a href="#hexists" class="headerlink" title="hexists"></a>hexists</h2><pre><code>判断成员是否存在（类似字典的in）</code></pre><h2 id="hexists-name-key"><a href="#hexists-name-key" class="headerlink" title="hexists(name, key)"></a>hexists(name, key)</h2><pre><code>检查name对应的hash是否存在当前传入的keyprint(r.hexists(&quot;hash1&quot;, &quot;k4&quot;))  # False 不存在print(r.hexists(&quot;hash1&quot;, &quot;k1&quot;))  # True 存在</code></pre><h2 id="hdel"><a href="#hdel" class="headerlink" title="hdel"></a>hdel</h2><pre><code>删除键值对hdel(name,*keys)将name对应的hash中指定key的键值对删除print(r.hgetall(&quot;hash1&quot;))r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v222&quot;)   # 修改已有的key k2r.hset(&quot;hash1&quot;, &quot;k11&quot;, &quot;v1&quot;)   # 新增键值对 k11r.hdel(&quot;hash1&quot;, &quot;k1&quot;)    # 删除一个键值对print(r.hgetall(&quot;hash1&quot;))</code></pre><h2 id="hincrby"><a href="#hincrby" class="headerlink" title="hincrby"></a>hincrby</h2><pre><code>自增自减整数(将key对应的value–整数 自增1或者2，或者别的整数 负数就是自减)hincrby(name, key, amount=1)自增name对应的hash中的指定key的值，不存在则创建key=amount参数：name，redis中的namekey， hash对应的keyamount，自增数（整数）r.hset(&quot;hash1&quot;, &quot;k3&quot;, 123)r.hincrby(&quot;hash1&quot;, &quot;k3&quot;, amount=-1)print(r.hgetall(&quot;hash1&quot;))r.hincrby(&quot;hash1&quot;, &quot;k4&quot;, amount=1)  # 不存在的话，value默认就是1print(r.hgetall(&quot;hash1&quot;))</code></pre><h2 id="hincrbyfloat"><a href="#hincrbyfloat" class="headerlink" title="hincrbyfloat"></a>hincrbyfloat</h2><pre><code>自增自减浮点数(将key对应的value–浮点数 自增1.0或者2.0，或者别的浮点数 负数就是自减)hincrbyfloat(name, key, amount=1.0)自增name对应的hash中的指定key的值，不存在则创建key=amount参数：name，redis中的namekey， hash对应的keyamount，自增数（浮点数）自增name对应的hash中的指定key的值，不存在则创建key=amountr.hset(&quot;hash1&quot;, &quot;k5&quot;, &quot;1.0&quot;)r.hincrbyfloat(&quot;hash1&quot;, &quot;k5&quot;, amount=-1.0)    # 已经存在，递减-1.0print(r.hgetall(&quot;hash1&quot;))r.hincrbyfloat(&quot;hash1&quot;, &quot;k6&quot;, amount=-1.0)    # 不存在，value初始值是-1.0 每次递减1.0print(r.hgetall(&quot;hash1&quot;))</code></pre><h2 id="hscan"><a href="#hscan" class="headerlink" title="hscan"></a>hscan</h2><pre><code>取值查看–分片读取hscan(name, cursor=0, match=None, count=None)增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆参数：name，redis的namecursor，游标（基于游标分批取获取数据）match，匹配指定key，默认None 表示所有的keycount，每次分片最少获取个数，默认None表示采用Redis的默认分片个数如：第一次：cursor1, data1 = r.hscan(‘xx’, cursor=0, match=None, count=None)第二次：cursor2, data1 = r.hscan(‘xx’, cursor=cursor1, match=None, count=None)…直到返回值cursor的值为0时，表示数据已经通过分片获取完毕print(r.hscan(&quot;hash1&quot;))</code></pre><h2 id="hscan-iter"><a href="#hscan-iter" class="headerlink" title="hscan_iter"></a>hscan_iter</h2><pre><code>hscan_iter(name, match=None, count=None)利用yield封装hscan创建生成器，实现分批去redis中获取数据参数：match，匹配指定key，默认None 表示所有的keycount，每次分片最少获取个数，默认None表示采用Redis的默认分片个数如：for item in r.hscan_iter(&apos;hash1&apos;):    print(item)print(r.hscan_iter(&quot;hash1&quot;))    # 生成器内存地址</code></pre><h1 id="list列表操作"><a href="#list列表操作" class="headerlink" title="list列表操作"></a>list列表操作</h1><h2 id="lpush"><a href="#lpush" class="headerlink" title="lpush"></a>lpush</h2><pre><code>增加（类似于list的append，只是这里是从左边新增加）–没有就新建lpush(name,values)在name对应的list中添加元素，每个新的元素都添加到列表的最左边如：import redisimport timepool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.lpush(&quot;list1&quot;, 11, 22, 33)print(r.lrange(&apos;list1&apos;, 0, -1))保存顺序为: 33,22,11扩展：r.rpush(&quot;list2&quot;, 11, 22, 33)  # 表示从右向左操作print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, 3))  # 切片取出值，范围是索引号0-3</code></pre><h2 id="rpush"><a href="#rpush" class="headerlink" title="rpush"></a>rpush</h2><pre><code>增加（从右边增加）–没有就新建r.rpush(&quot;list2&quot;, 44, 55, 66)    # 在列表的右边，依次添加44,55,66print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)lpushx往已经有的name的列表的左边添加元素，没有的话无法创建</code></pre><h2 id="lpushx-name-value"><a href="#lpushx-name-value" class="headerlink" title="lpushx(name,value)"></a>lpushx(name,value)</h2><pre><code>在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边更多：r.lpushx(&quot;list10&quot;, 10)   # 这里list10不存在print(r.llen(&quot;list10&quot;))  # 0print(r.lrange(&quot;list10&quot;, 0, -1))  # []r.lpushx(&quot;list2&quot;, 77)   # 这里&quot;list2&quot;之前已经存在，往列表最左边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素</code></pre><h2 id="rpushx"><a href="#rpushx" class="headerlink" title="rpushx"></a>rpushx</h2><pre><code>往已经有的name的列表的右边添加元素，没有的话无法创建r.rpushx(&quot;list2&quot;, 99)   # 这里&quot;foo_list1&quot;之前已经存在，往列表最右边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)</code></pre><h2 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h2><pre><code>新增（固定索引号位置插入元素）linsert(name, where, refvalue, value))在name对应的列表的某一个值前或后插入一个新值参数：name，redis的namewhere，BEFORE或AFTERrefvalue，标杆值，即：在它前后插入数据value，要插入的数据r.linsert(&quot;list2&quot;, &quot;before&quot;, &quot;11&quot;, &quot;00&quot;)   # 往列表中左边第一个出现的元素&quot;11&quot;前插入元素&quot;00&quot;print(r.lrange(&quot;list2&quot;, 0, -1))   # 切片取出值，范围是索引号0-最后一个元素</code></pre><h2 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h2><pre><code>修改（指定索引号进行修改）r.lset(name, index, value)对name对应的list中的某一个索引位置重新赋值参数：name，redis的nameindex，list的索引位置value，要设置的值r.lset(&quot;list2&quot;, 0, -11)    # 把索引号是0的元素修改成-11print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><h2 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h2><pre><code>删除（指定值进行删除）r.lrem(name, value, num)在name对应的list中删除指定的值参数：name，redis的namevalue，要删除的值num， num=0，删除列表中所有的指定值；num=2,从前到后，删除2个； num=1,从前到后，删除左边第1个num=-2,从后向前，删除2个r.lrem(&quot;list2&quot;, &quot;11&quot;, 1)    # 将列表中左边第一次出现的&quot;11&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;99&quot;, -1)    # 将列表中右边第一次出现的&quot;99&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;22&quot;, 0)    # 将列表中所有的&quot;22&quot;删除print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><h2 id="lpop"><a href="#lpop" class="headerlink" title="lpop"></a>lpop</h2><pre><code>删除并返回lpop(name)在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素更多：rpop(name) 表示从右向左操作r.lpop(&quot;list2&quot;)    # 删除列表最左边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))r.rpop(&quot;list2&quot;)    # 删除列表最右边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><h2 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h2><pre><code>删除索引之外的值ltrim(name, start, end)在name对应的列表中移除没有在start-end索引之间的值参数：name，redis的namestart，索引的起始位置end，索引结束位置r.ltrim(&quot;list2&quot;, 0, 2)    # 删除索引号是0-2之外的元素，值保留索引号是0-2的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><h2 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h2><pre><code>取值（根据索引号取值）lindex(name, index)在name对应的列表中根据索引获取列表元素print(r.lindex(&quot;list2&quot;, 0))  # 取出索引号是0的值</code></pre><h2 id="rpoplpush"><a href="#rpoplpush" class="headerlink" title="rpoplpush"></a>rpoplpush</h2><pre><code>移动 元素从一个列表移动到另外一个列表rpoplpush(src, dst)从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边参数：src，要取数据的列表的namedst，要添加数据的列表的namer.rpoplpush(&quot;list1&quot;, &quot;list2&quot;)print(r.lrange(&quot;list2&quot;, 0, -1))brpoplpush移动 元素从一个列表移动到另外一个列表 可以设置超时brpoplpush(src, dst, timeout=0)从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧参数：src，取出并要移除元素的列表对应的namedst，要插入元素的列表对应的nametimeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞r.brpoplpush(&quot;list1&quot;, &quot;list2&quot;, timeout=2)print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><p>##blpop</p><pre><code>一次移除多个列表blpop(keys, timeout)将多个列表排列，按照从左到右去pop对应列表的元素参数：keys，redis的name的集合timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞</code></pre><h2 id="更多："><a href="#更多：" class="headerlink" title="更多："></a>更多：</h2><pre><code>r.brpop(keys, timeout) 同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素r.lpush(&quot;list10&quot;, 3, 4, 5)r.lpush(&quot;list11&quot;, 3, 4, 5)while True:    r.blpop([&quot;list10&quot;, &quot;list11&quot;], timeout=2)    print(r.lrange(&quot;list10&quot;, 0, -1), r.lrange(&quot;list11&quot;, 0, -1))自定义增量迭代由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：获取name对应的所有列表循环列表但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：def list_iter(name):    &quot;&quot;&quot;    自定义redis列表增量迭代    :param name: redis中的name，即：迭代name对应的列表    :return: yield 返回 列表元素    &quot;&quot;&quot;    list_count = r.llen(name)    for index in range(list_count):        yield r.lindex(name, index)# 使用for item in list_iter(&apos;list2&apos;): # 遍历这个列表    print(item)</code></pre><h1 id="集合set操作"><a href="#集合set操作" class="headerlink" title="集合set操作"></a>集合set操作</h1><h2 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h2><pre><code>新增sadd(name,values)name对应的集合中添加元素r.sadd(&quot;set1&quot;, 33, 44, 55, 66)  # 往集合中添加元素print(r.scard(&quot;set1&quot;))  # 集合的长度是4print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员</code></pre><h2 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h2><pre><code>获取元素个数 类似于lenscard(name)获取name对应的集合中元素个数print(r.scard(&quot;set1&quot;))  # 集合的长度是4</code></pre><h2 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h2><pre><code>获取集合中所有的成员smembers(name)获取name对应的集合的所有成员print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员获取集合中所有的成员–元组形式sscan(name, cursor=0, match=None, count=None)print(r.sscan(&quot;set1&quot;))1获取集合中所有的成员–迭代器的方式sscan_iter(name, match=None, count=None)同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大for i in r.sscan_iter(&quot;set1&quot;):    print(i)2</code></pre><h2 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h2><pre><code>差集sdiff(keys, *args)在第一个name对应的集合中且不在其他name对应的集合的元素集合r.sadd(&quot;set2&quot;, 11, 22, 33)print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员print(r.smembers(&quot;set2&quot;))print(r.sdiff(&quot;set1&quot;, &quot;set2&quot;))   # 在集合set1但是不在集合set2中print(r.sdiff(&quot;set2&quot;, &quot;set1&quot;))   # 在集合set2但是不在集合set1中</code></pre><h2 id="sdiffstore"><a href="#sdiffstore" class="headerlink" title="sdiffstore"></a>sdiffstore</h2><pre><code>差集–差集存在一个新的集合中sdiffstore(dest, keys, *args)获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中r.sdiffstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)    # 在集合set1但是不在集合set2中print(r.smembers(&quot;set3&quot;))   # 获取集合3中所有的成员</code></pre><h2 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h2><pre><code>交集sinter(keys, *args)获取多一个name对应集合的交集print(r.sinter(&quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的交集</code></pre><h2 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h2><pre><code>交集–交集存在一个新的集合中sinterstore(dest, keys, *args)获取多一个name对应集合的并集，再将其加入到dest对应的集合中print(r.sinterstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的交集print(r.smembers(&quot;set3&quot;))</code></pre><p>##　sunion</p><pre><code>并集sunion(keys, *args)获取多个name对应的集合的并集print(r.sunion(&quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的并集1并集–并集存在一个新的集合sunionstore(dest,keys, *args)获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中print(r.sunionstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取2个集合的并集print(r.smembers(&quot;set3&quot;))</code></pre><h2 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h2><pre><code>判断是否是集合的成员 类似insismember(name, value)检查value是否是name对应的集合的成员，结果为True和Falseprint(r.sismember(&quot;set1&quot;, 33))  # 33是集合的成员print(r.sismember(&quot;set1&quot;, 23))  # 23不是集合的成员</code></pre><h2 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h2><pre><code>移动smove(src, dst, value)将某个成员从一个集合中移动到另外一个集合r.smove(&quot;set1&quot;, &quot;set2&quot;, 44)print(r.smembers(&quot;set1&quot;))print(r.smembers(&quot;set2&quot;))</code></pre><h2 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h2><pre><code>删除–随机删除并且返回被删除值spop(name)从集合移除一个成员，并将其返回,说明一下，集合是无序的，所有是随机删除的print(r.spop(&quot;set2&quot;))   # 这个删除的值是随机删除的，集合是无序的print(r.smembers(&quot;set2&quot;))</code></pre><h2 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h2><pre><code>11.删除–指定值删除srem(name, values)在name对应的集合中删除某些值print(r.srem(&quot;set2&quot;, 11))   # 从集合中删除指定值 11print(r.smembers(&quot;set2&quot;))</code></pre><h1 id="有序集合sort-set操作"><a href="#有序集合sort-set操作" class="headerlink" title="有序集合sort set操作"></a>有序集合sort set操作</h1><pre><code>redis基本命令 有序setSet操作，Set集合就是不允许重复的列表，本身是无序的有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</code></pre><h2 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h2><pre><code>新增zadd(name, args, *kwargs)在name对应的有序集合中添加元素如：import redisimport timepool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.zadd(&quot;zset1&quot;, n1=11, n2=22)r.zadd(&quot;zset2&quot;, &apos;m1&apos;, 22, &apos;m2&apos;, 44)print(r.zcard(&quot;zset1&quot;)) # 集合长度print(r.zcard(&quot;zset2&quot;)) # 集合长度print(r.zrange(&quot;zset1&quot;, 0, -1))   # 获取有序集合中所有元素print(r.zrange(&quot;zset2&quot;, 0, -1, withscores=True))   # 获取有序集合中所有元素和分数2</code></pre><h2 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h2><pre><code>获取有序集合元素个数 类似于lenzcard(name)获取name对应的有序集合元素的数量print(r.zcard(&quot;zset1&quot;)) # 集合长度1</code></pre><h2 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h2><pre><code>获取有序集合的所有元素r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)按照索引范围获取name对应的有序集合的元素参数：name，redis的namestart，有序集合索引起始位置（非分数）end，有序集合索引结束位置（非分数）desc，排序规则，默认按照分数从小到大排序withscores，是否获取元素的分数，默认只获取元素的值score_cast_func，对分数进行数据转换的函数</code></pre><h2 id="zrevrange"><a href="#zrevrange" class="headerlink" title="zrevrange"></a>zrevrange</h2><pre><code>3-1 从大到小排序(同zrange，集合是从大到小排序的)zrevrange(name, start, end, withscores=False, score_cast_func=float)print(r.zrevrange(&quot;zset1&quot;, 0, -1))    # 只获取元素，不显示分数print(r.zrevrange(&quot;zset1&quot;, 0, -1, withscores=True)) # 获取有序集合中所有元素和分数,分数倒序</code></pre><h2 id="zrangebyscore"><a href="#zrangebyscore" class="headerlink" title="zrangebyscore"></a>zrangebyscore</h2><pre><code>3-2 按照分数范围获取name对应的有序集合的元素zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)for i in range(1, 30):element = &apos;n&apos; + str(i)r.zadd(&quot;zset3&quot;, element, i)print(r.zrangebyscore(&quot;zset3&quot;, 15, 25)) # # 在分数是15-25之间，取出符合条件的元素print(r.zrangebyscore(&quot;zset3&quot;, 12, 22, withscores=True))    # 在分数是12-22之间，取出符合条件的元素（带分数）</code></pre><h2 id="zrevrangebyscore"><a href="#zrevrangebyscore" class="headerlink" title="zrevrangebyscore"></a>zrevrangebyscore</h2><pre><code>3-3 按照分数范围获取有序集合的元素并排序（默认从大到小排序）zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)print(r.zrevrangebyscore(&quot;zset3&quot;, 22, 11, withscores=True)) # 在分数是22-11之间，取出符合条件的元素 按照分数倒序1</code></pre><h2 id="zscan"><a href="#zscan" class="headerlink" title="zscan"></a>zscan</h2><pre><code>3-4 获取所有元素–默认按照分数顺序排序zscan(name, cursor=0, match=None, count=None, score_cast_func=float)print(r.zscan(&quot;zset3&quot;))1</code></pre><h2 id="zscan-iter"><a href="#zscan-iter" class="headerlink" title="zscan_iter"></a>zscan_iter</h2><pre><code>3-5 获取所有元素–迭代器zscan_iter(name, match=None, count=None,score_cast_func=float)for i in r.zscan_iter(&quot;zset3&quot;): # 遍历迭代器    print(i)</code></pre><p>##　zcount</p><pre><code>zcount(name, min, max)获取name对应的有序集合中分数 在 [min,max] 之间的个数print(r.zrange(&quot;zset3&quot;, 0, -1, withscores=True))print(r.zcount(&quot;zset3&quot;, 11, 22))</code></pre><h2 id="zincrby"><a href="#zincrby" class="headerlink" title="zincrby"></a>zincrby</h2><pre><code>自增zincrby(name, value, amount)自增name对应的有序集合的 name 对应的分数r.zincrby(&quot;zset3&quot;, &quot;n2&quot;, amount=2)    # 每次将n2的分数自增2print(r.zrange(&quot;zset3&quot;, 0, -1, withscores=True))</code></pre><h2 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h2><pre><code>获取值的索引号zrank(name, value)获取某个值在 name对应的有序集合中的索引（从 0 开始）更多：zrevrank(name, value)，从大到小排序print(r.zrank(&quot;zset3&quot;, &quot;n1&quot;))   # n1的索引号是0 这里按照分数顺序（从小到大）print(r.zrank(&quot;zset3&quot;, &quot;n6&quot;))   # n6的索引号是1print(r.zrevrank(&quot;zset3&quot;, &quot;n1&quot;))    # n1的索引号是29 这里安照分数倒序（从大到小）</code></pre><h2 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h2><pre><code>删除–指定值删除zrem(name, values)删除name对应的有序集合中值是values的成员r.zrem(&quot;zset3&quot;, &quot;n3&quot;)   # 删除有序集合中的元素n3 删除单个print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><h2 id="zremrangebyrank"><a href="#zremrangebyrank" class="headerlink" title="zremrangebyrank"></a>zremrangebyrank</h2><pre><code>删除–根据排行范围删除，按照索引号来删除zremrangebyrank(name, min, max)根据排行范围删除r.zremrangebyrank(&quot;zset3&quot;, 0, 1)  # 删除有序集合中的索引号是0, 1的元素print(r.zrange(&quot;zset3&quot;, 0, -1))zremrangebyscore(name, min, max)根据分数范围删除r.zremrangebyscore(&quot;zset3&quot;, 11, 22)   # 删除有序集合中的分数是11-22的元素print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><h2 id="zscore"><a href="#zscore" class="headerlink" title="zscore"></a>zscore</h2><pre><code>获取值对应的分数zscore(name, value)获取name对应有序集合中 value 对应的分数print(r.zscore(&quot;zset3&quot;, &quot;n27&quot;))   # 获取元素n27对应的分数271</code></pre><h2 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><pre><code>delete (*names)根据删除redis中的任意数据类型（string、hash、list、set、有序set）r.delete(&quot;gender&quot;)  # 删除key为gender的键值对1</code></pre><h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><pre><code>检查名字是否存在exists(name)检测redis的name是否存在，存在就是True，False 不存在print(r.exists(&quot;zset1&quot;))1keys模糊匹配keys(pattern=’‘)根据模型获取redis的name更多：KEYS 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS h*llo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hilloprint(r.keys(&quot;foo*&quot;))1</code></pre><h3 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h3><pre><code>设置超时时间expire(name ,time)为某个redis的某个name设置超时时间r.lpush(&quot;list5&quot;, 11, 22)r.expire(&quot;list5&quot;, time=3)print(r.lrange(&quot;list5&quot;, 0, -1))time.sleep(3)print(r.lrange(&quot;list5&quot;, 0, -1))</code></pre><h3 id="rname"><a href="#rname" class="headerlink" title="rname"></a>rname</h3><pre><code>重命名rename(src, dst)对redis的name重命名r.lpush(&quot;list5&quot;, 11, 22)r.rename(&quot;list5&quot;, &quot;list5-1&quot;)randomkey随机获取namerandomkey()随机获取一个redis的name（不删除）print(r.randomkey())1</code></pre><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><pre><code>获取类型type(name)获取name对应值的类型print(r.type(&quot;set1&quot;))print(r.type(&quot;hash2&quot;))</code></pre><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><pre><code>查看所有元素scan(cursor=0, match=None, count=None)print(r.hscan(&quot;hash2&quot;))print(r.sscan(&quot;set3&quot;))print(r.zscan(&quot;zset2&quot;))print(r.getrange(&quot;foo1&quot;, 0, -1))print(r.lrange(&quot;list2&quot;, 0, -1))print(r.smembers(&quot;set3&quot;))print(r.zrange(&quot;zset3&quot;, 0, -1))print(r.hgetall(&quot;hash1&quot;))</code></pre><h3 id="scan-iter"><a href="#scan-iter" class="headerlink" title="scan_iter"></a>scan_iter</h3><pre><code>查看所有元素–迭代器scan_iter(match=None, count=None)for i in r.hscan_iter(&quot;hash1&quot;):    print(i)for i in r.sscan_iter(&quot;set3&quot;):    print(i)for i in r.zscan_iter(&quot;zset3&quot;):    print(i)8</code></pre><h3 id="other-方法"><a href="#other-方法" class="headerlink" title="other 方法"></a>other 方法</h3><pre><code>print(r.get(&apos;name&apos;))    # 查询key为name的值r.delete(&quot;gender&quot;)  # 删除key为gender的键值对print(r.keys()) # 查询所有的Keyprint(r.dbsize())   # 当前redis包含多少条数据r.save()    # 执行&quot;检查点&quot;操作，将数据写回磁盘。保存时阻塞# r.flushdb()        # 清空r中的所有数据管道（pipeline）redis默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。管道（pipeline）是redis在提供单个请求中缓冲多条服务器命令的基类的子类。它通过减少服务器-客户端之间反复的TCP数据库包，从而大大提高了执行批量命令的功能。import redisimport timepool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)# pipe = r.pipeline(transaction=False)    # 默认的情况下，管道里执行的命令可以保证执行的原子性，执行pipe = r.pipeline(transaction=False)可以禁用这一特性。# pipe = r.pipeline(transaction=True)pipe = r.pipeline() # 创建一个管道pipe.set(&apos;name&apos;, &apos;jack&apos;)pipe.set(&apos;role&apos;, &apos;sb&apos;)pipe.sadd(&apos;faz&apos;, &apos;baz&apos;)pipe.incr(&apos;num&apos;)    # 如果num不存在则vaule为1，如果存在，则value自增1pipe.execute()print(r.get(&quot;name&quot;))print(r.get(&quot;role&quot;))print(r.get(&quot;num&quot;))管道的命令可以写在一起，如：pipe.set(&apos;hello&apos;, &apos;redis&apos;).sadd(&apos;faz&apos;, &apos;baz&apos;).incr(&apos;num&apos;).execute()print(r.get(&quot;name&quot;))print(r.get(&quot;role&quot;))print(r.get(&quot;num&quot;))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis for Python开发手册&lt;/p&gt;
&lt;h1 id=&quot;redis基本命令-String&quot;&gt;&lt;a href=&quot;#redis基本命令-String&quot; class=&quot;headerlink&quot; title=&quot;redis基本命令 String&quot;&gt;&lt;/a&gt;redis基本命令 
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基本系统优化</title>
    <link href="http://yoursite.com/2018/03/18/Linux%E5%9F%BA%E6%9C%AC%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/03/18/Linux基本系统优化/</id>
    <published>2018-03-18T02:35:53.000Z</published>
    <updated>2018-11-28T13:00:07.598Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Linux的网络功能相当强悍，一时之间我们无法了解所有的网络命令，在配置服务器基础环境时，先了解下网络参数设定命令。ifconfig　　查询、设置网卡和ip等参数ifup,ifdown    脚本命令，更简单的方式启动关闭网络ip　　符合指令，直接修改上述功能在我们刚装好linux的时候，需要用xshell进行远程连接，那就得获取ip地址，有时候网卡默认是没启动的，Linux也就拿不到ip地址，因此我们得手动启动网卡#编辑网卡配置文件vim /etc/sysconfig/network-scripts/ifcfg-eth0 #修改配置参数ONBOOT=yes</code></pre><h1 id="网卡配置文件详细"><a href="#网卡配置文件详细" class="headerlink" title="网卡配置文件详细"></a>网卡配置文件详细</h1><pre><code>网络配置文件：/etc/sysconfig/network网络接口配置文件：/etc/sysconfig/network-scripts/ifcfg-INTERFACE_NAMEDEVICE=: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; BOOTPROTO={static|none|dhcp|bootp}: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；IPADDR=: IP地址NETMASK=：子网掩码GATEWAY=：设定默认网关；ONBOOT=：开机时是否自动激活此网络接口；HWADDR=： 硬件地址，要与硬件中的地址保持一致；可省；USERCTL={yes|no}: 是否允许普通用户控制此接口；PEERDNS={yes|no}: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；</code></pre><h2 id="ifup，ifdown"><a href="#ifup，ifdown" class="headerlink" title="ifup，ifdown"></a>ifup，ifdown</h2><pre><code>启动/关闭一块网卡ifup eth0（网卡名）ifdown eth0（网卡名）---如果关闭网卡，xshell会怎样? 会卡主不动啊</code></pre><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><pre><code>ifconfig 查看网卡的ip地址</code></pre><p>直接输入ifconfig会列出已经启动的网卡，也可以输入ifconfig eth0单独显示eth0的信息</p><pre><code>各选项解释是：eth0    网卡的代号 lo        回环地址loopbackinet    IPv4的Ip地址netmask    子网掩码broadcast    广播地址RX/TX     流量发/收情况     tx是发送（transport），rx是接收(receive)packets     数据包数errors     数据包错误数dropped    数据包有问题被丢弃的数量collisions    数据包碰撞情况，数值太多代表网络状况差</code></pre><h2 id="ifup-ifdown命令"><a href="#ifup-ifdown命令" class="headerlink" title="ifup,ifdown命令"></a>ifup,ifdown命令</h2><pre><code>ifup和ifdown是直接连接到/etc/sysconfig/network-scripts目录下搜索对应的网卡文件，例如ifcfg-eth0然后加以设置</code></pre><h2 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h2><pre><code>ip是一个命令，不是TCP/IP那个ip，这个ip命令是结合了ifconfig和route两个命令的功能。ip addr show #查看ip信息</code></pre><p>了解了如何查看网卡信息，接下来查看系统信息。系统是什么版本？</p><pre><code>#查看系统版本信息cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) #查看内核版本号uname -r3.10.0-693.el7.x86_64#查看系统多少位uname -mx86_64#查看内核所有信息uname -a</code></pre><h1 id="用户管理与文件权限"><a href="#用户管理与文件权限" class="headerlink" title="用户管理与文件权限"></a>用户管理与文件权限</h1><pre><code>现代操作系统一般属于多用户的操作系统，也就是说，同一台机器可以为多个用户建立账户，一般这些用户都是为普通用户，这些普通用户能同时登录这台计算机，计算机对这些用户分配一定的资源。普通用户在所分配到的资源内进行各自的操作，相互之间不受影响。但是这些普通用户的权限是有限制的，且用户太多的话，管理就不便，从而引入root用户。此用户是唯一的，且拥有系统的所有权限。root用户所在的组称为root组。“组”是具有相似权限的多个用户的集合。</code></pre><p>root的权利</p><pre><code>Linux系统的特性就是可以满足多个用户，同时工作，因此Linux系统必须具备很好的安全性。在安装RHEL7时设置的root管理员密码，这个root管理员就是所有UNIX系统中的超级用户，它拥有最高的系统所有权，能够管理系统的各项功能，如添加/删除用户，启动/关闭进程，开启/禁用硬件设备等等。因此“能力越大，责任越大”，root权限必须很好的掌握，否则一个错误的命令可能会摧毁整个系统。</code></pre><p>root为什么叫root？</p><pre><code>在Linux系统中，用户也有自己的UID身份账号且唯一系统管理员UID为0系统用户UID为1~999    Linux安装的服务程序都会创建独有的用户负责运行。普通用户UID从1000开始：由管理员创建</code></pre><p>用户组GID</p><pre><code>为了方便管理属于同一组的用户，Linux 系统中还引入了用户组的概念。通过使用用 户组号码(GID，Group IDentification)，我们可以把多个用户加入到同一个组中，从而方 便为组中的用户统一规划权限或指定任务。假设有一个公司中有多个部门，每个部门中又 有很多员工。如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设 置权限。例如，可以通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的 数据库信息等。</code></pre><p>Linux管理员在创建用户时，将自动创建一个与其同名的用户组，这个用户组只有该用户一个人</p><pre><code>Linux/unix是一个多用户、多任务的操作系统。root：默认在Unix/linux操作系统中拥有最高的管理权限。可以理解为qq群的群主普通用户：是管理员或者具备管理权限的用户所创建的，只能读、看，不能增、删、改。</code></pre><h2 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h2><pre><code>#添加用户useradd haiyan #设置密码       passwd redhatroot用户可以修改其他所有人的密码，且不需要验证</code></pre><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><h3 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h3><pre><code>su命令可以切换用户身份的需求，su - username</code></pre><p>su命令中间的-号很重要，意味着完全切换到新的用户，即环境变量信息也变更为新用户的信息</p><pre><code>#先看下当前用户（我是谁）whoami#切换用户su - oldboy#退出用户登录logoutctrl + d</code></pre><p>一般情况下，在生产环境避免直接用root用户，除非有特殊系统维护需求，使用完立刻退回</p><p>普通用户</p><pre><code>非交互式设置密码(echo &quot;redhat&quot;|passwd --stdin haiyan &amp;&amp; history -c)Tip:1.超级用户root切换普通用户无需密码,例如“群主”想踢谁就踢谁2.普通用户切换root，需要输入密码3.普通用户权限较小，只能基本查看信息4.$符号是普通用户命令提示符，#是超级管理员的提示符root是当前用户，oldboyedu是主机名，~代表当前路径，也是家目录</code></pre><h3 id="groupadd命令"><a href="#groupadd命令" class="headerlink" title="groupadd命令"></a>groupadd命令</h3><pre><code>group命令用于创建用户组，为了更加高效的指派系统中各个用户的权限，在工作中常常添加几个用户到一个组里面，这样可以针对一类用户安排权限。例如在公司里，就负责添加openLDAP用户管理，偶尔台湾，美国的同事去上海协作，我就得给他们添加到it部门组里面，以至于他们有对服务器操作的权限。groupadd it_dep</code></pre><h2 id="userdel删除用户"><a href="#userdel删除用户" class="headerlink" title="userdel删除用户"></a>userdel删除用户</h2><pre><code>-f     强制删除用户-r    同事删除用户以及家目录userdel -r pyyu </code></pre><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><pre><code>sudo命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。</code></pre><p>语法</p><pre><code>sudo 【选项】【参数】-b：在后台执行指令；-h：显示帮助；-H：将HOME环境变量设为新身份的HOME环境变量；-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。-l：列出目前用户可执行与无法执行的指令；-p：改变询问密码的提示符号；-s&lt;shell&gt;：执行指定的shell；-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；-v：延长密码有效期限5分钟；-V ：显示版本信息。</code></pre><p>实例：</p><pre><code>权限不够，这时候需要sudo ls /root  以root身份去运行，haiyan权利小，root总可以了吧!!</code></pre><p>这是由于配置sudo必须编辑/etc/sudoers文件，并且只有root才能修改，可以通过<br>visudo命令直接编辑sudoers文件，使用这个命令还可以检查语法，比直接编辑 vim<br>/etc/sudoers更安全</p><pre><code>visudo 编辑sudoers文件写入## Allow root to run any commands anywhereroot    ALL=(ALL)       ALLchaoge  ALL=(ALL)       ALL   #允许chaoge在任何地方，执行任何命令此时切换chaoge用户#su命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。su - chaoge已经可以使用sudo ls /root 命令</code></pre><h2 id="文件与目录权限"><a href="#文件与目录权限" class="headerlink" title="文件与目录权限"></a>文件与目录权限</h2><p>Linux权限的目的是（保护账户的资料）</p><p>Linux权限主要依据三种身份来决定：</p><pre><code>user/owner 文件使用者,文件属于哪个用户group 属组,文件属于哪个组others 既不是user，也不再group，就是other，其他人</code></pre><h3 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h3><pre><code>在Linux中，每个文件都有所属的所有者，和所有组，并且规定了文件的所有者，所有组以及其他人对文件的，可读，可写，可执行等权限。对于目录的权限来说，可读是读取目录文件列表，可写是表示在目录内新增，修改，删除文件。可执行表示可以进入目录</code></pre><h3 id="Linux权限的观察"><a href="#Linux权限的观察" class="headerlink" title="Linux权限的观察"></a>Linux权限的观察</h3><p>使用一条命令查看权限</p><pre><code>ls -l /var/log/mysqld.log </code></pre><img src="/2018/03/18/Linux基本系统优化/1.png"><pre><code>权限，第一个字母为文件类型，后续9个字母，每3个一组，是三种身份的权限文件链接数文件拥有者-属主文件拥有组-属组文件大小最后一次被修改的时间日期文件名 先来分析一下文件的类型-    一般文件d    文件夹l    软连接（快捷方式）b    块设备，存储媒体文件为主c    代表键盘,鼠标等设备</code></pre><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><pre><code>r    read可读，可以用cat等命令查看w    write写入，可以编辑或者删除这个文件x    executable    可以执行</code></pre><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p>权限这里测试不要用root实验！！！！root太牛逼了</p><p>请用普通用户执行！！！！！测试文件、文件夹权限操作，请用普通用户！</p><p>r    可以对此目录执行ls列出所有文件<br>w    可以在这个目录创建文件<br>x    可以cd进入这个目录，或者查看详细信息</p><p>权限与数字转化    </p><img src="/2018/03/18/Linux基本系统优化/2.png"><pre><code>ls -l /var/log/mysqld.log -rw-r--r-- 1 mysql mysql 6735642 3月  11 14:19 /var/log/mysqld.log这个就代表mysqld.log文件属主是mysql，属组是mysql，只有mysql用户可以读取编写这个文件，其他人只能读此文件。</code></pre><h3 id="查看用户权限命令"><a href="#查看用户权限命令" class="headerlink" title="查看用户权限命令"></a>查看用户权限命令</h3><pre><code>id指令查看用户所属群主[root@haiyan ~ 16:34:52]#id rootuid=0(root) gid=0(root) 组=0(root)</code></pre><h3 id="修改文件权限属性"><a href="#修改文件权限属性" class="headerlink" title="修改文件权限属性"></a>修改文件权限属性</h3><pre><code>普通用户只能修改自己的文件名，时间与权限（注意）因此修改其他用户权限，只能用最nb的root用户#切换root用户[pyyu@haiyan root]$ su -当前/tmp/py.txt文件以存在，且信息是-rw-rw-r-- 1 pyyu pyyu    0 3月  11 16:41 py.txt修改属主为root</code></pre><p>chown</p><pre><code>[root@haiyan /tmp 16:43:12]#chown root py.txt </code></pre><p>查看信息</p><pre><code>[root@haiyan /tmp 16:43:42]#ll py.txt -rw-rw-r-- 1 root py 0 3月  11 16:41 py.txt</code></pre><p>修改属组</p><p>chgrp</p><pre><code>[root@haiyan /tmp 16:43:42]#ll py.txt -rw-rw-r-- 1 root pyyu 0 3月  11 16:41 py.txt[root@haiyan /tmp 16:44:59]#chgrp root py.txt [root@haiyan /tmp 16:45:51]#ll py.txt -rw-rw-r-- 1 root root 0 3月  11 16:41 py.txt</code></pre><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><pre><code>我们已知三种身份权限（属主，属组，其他人），每种身份都有rwx的三种权限，系统还提供了数字计算权限。r    read          4w    write        2x    execute     1每种身份最低是0分，最高是r+w+x 7分因此三种身份，最高权限是777，最低是000-rw-rw-r-- 1 root root 0 3月  11 16:41 py.txt因此可知py.txt的权限是属主是6 r+w(4+2)属组是6　r+w(4+2)其他人是4　r(4)</code></pre><h3 id="修改权限的命令"><a href="#修改权限的命令" class="headerlink" title="修改权限的命令"></a>修改权限的命令</h3><pre><code>chmodchmod [身份]　　 [参数] 　　[文件]　　　　u(user)　　 +(添加)　　　　　　g(group)　  -(减去)　　　　o(other)　　=(赋值)　　　　a(all)</code></pre><p>例如</p><pre><code>当前权限-rw-rw-r-- 1 root root 0 3月  11 16:41 py.txt方法1减去属主的写权限chmod u-w py.txt查看权限-r--rw-r-- 1 root root 0 8月  11 16:41 py.txt方法2属主添加可读可写可执行权限chmod 700 py.txt属主可读可写可执行属组可读可执行其他人可读可执行chmod 755 py.txt</code></pre><p>修改文件名，修改文件更改日期</p><pre><code>mv py.txt haiyan.txt#触摸，修改时间touch haiyan.txt</code></pre><h1 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h1><p>连接也叫做符号链接，类似于windows的快捷方式。</p><p>常用于安装软件的快捷方式配置，如python，nginx等</p><pre><code>ln -s 目标文件  软连接名1.存在文件/tmp/test.txt[root@master tmp]# ls -l-rw-r--r-- 1 root root     10 3月 15 21:23 test.txt2.在/home目录中建立软连接，指向/tmp/test.txt文件ln -s /tmp/test.txt my_test3.查看软连接信息lrwxrwxrwx 1 root root 13 3月 15 21:35 my_test -&gt; /tmp/test.txt4.通过软连接查看文件cat my_testmy_test只是/tmp/test.txt的一个别名，因此删除my_test不会影响/tmp/test.txt，但是删除了本尊，快捷方式就无意义不存在了</code></pre><p>PS1变量</p><p>Linux命令提示符由PS1环境变量控制</p><pre><code>[root@haiyan ~]# echo $PS1[\u@\h \W]\$可以自行调整全局变量/etc/profile文件用于永久生效 PS1=&apos;[\u@\h \W\t]\$&apos;\d　　日期\H　　完整主机名\h　　主机名第一个名字\t　　时间24小时制HHMMSS\T　　时间12小时制\A　　时间24小时制HHMM\u　　当前用户账号名\v　　BASH的版本\w　　完整工作目录\W　　利用basename取得工作目录名\#　　下达的第几个命令\$　　提示字符，root为#，普通用户为$PS1 &gt; 变量名$PS1 &gt; 查看变量内容PS1=新内容 重新赋值变量赋值，查看name=&apos;chaoge&apos;echo $namePS1显示ip地址export PS1=&quot;[\u@\h `/sbin/ifconfig ens33 | sed -nr &apos;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p&apos;` \w]\$&quot;</code></pre><h1 id="tar解压命令"><a href="#tar解压命令" class="headerlink" title="tar解压命令"></a>tar解压命令</h1><p>人们发明了各种各样的包，无论是双肩包，或者是装在口袋，都是为了让“文件”更方便携带。linux的文件打包工具最出名的是tar。</p><pre><code>tar 命令：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的</code></pre><p>语法</p><pre><code>tar(选项)(参数)-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件</code></pre><p>实例</p><pre><code>tar -zxvf Python-3.7.0b3.tgz #解压tar -czvf haiyan.txt.tar.gz haiyan.txt #压缩haiyan.txt  上述命令等于 tar -cvf haiyan.tar haiyan.txt　　　　　　  gzip haiyan.tartar -cf all_pic.tar *.jpg #压缩当前目录所有jpg结尾的文件tar -xjf xx.tar.bz2　　#解压缩bz2结尾的文件</code></pre><h1 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h1><pre><code>gzip用来压缩文件，是个使用广泛的压缩程序，被压缩的以&quot;.gz&quot;扩展名gzip可以压缩较大的文件，以60%~70%压缩率来节省磁盘空间</code></pre><p>语法</p><pre><code>-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-v或——verbose：显示指令执行过程；</code></pre><p>实例</p><pre><code>压缩当前目录所有文件为.gz文件gzip * 把上例中每个压缩的文件解压，并列出详细的信息gzip -dv *显示压缩文件的信息，并不解压gzip -l *压缩一个tar备份文件，扩展名是tar.gztar -cf my.tar my_first.pygzip -r my.tar</code></pre><h1 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h1><pre><code>netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</code></pre><p>语法【选项】</p><pre><code>netstat [选项]-t或--tcp：显示TCP传输协议的连线状况；-u或--udp：显示UDP传输协议的连线状况；-n或--numeric：直接使用ip地址，而不通过域名服务器；-l或--listening：显示监控中的服务器的Socket；-p或--programs：显示正在使用Socket的程序识别码和程序名称；-a或--all：显示所有连线中的Socket；</code></pre><p>实例</p><pre><code>[root@haiyan ~ 10:21:59]#netstat -tunlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      814/sshd            tcp6       0      0 :::111                  :::*                    LISTEN      2703/rpcbind        tcp6       0      0 :::3306                 :::*                    LISTEN      29269/mysqld        udp        0      0 0.0.0.0:758             0.0.0.0:*                           2703/rpcbind        udp        0      0 0.0.0.0:111             0.0.0.0:*                           2703/rpcbind        udp        0      0 10.141.32.137:123       0.0.0.0:*                           484/ntpd            udp        0      0 127.0.0.1:123           0.0.0.0:*                           484/ntpd            udp        0      0 0.0.0.0:123             0.0.0.0:*                           484/ntpd            udp6       0      0 :::758                  :::*                                2703/rpcbind        udp6       0      0 :::111                  :::*                                2703/rpcbind        udp6       0      0 :::123                  :::*                                484/ntpd  </code></pre><h1 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h1><p>ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。</p><pre><code>ps　　命令常用参数-a     显示所有进程-u     用户以及其他详细信息-x    显示没有控制终端的进程</code></pre><h1 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h1><pre><code>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。</code></pre><p>选项</p><pre><code>-a：当处理当前进程时，不限制命令名和进程号的对应关系；-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；-s &lt;信息名称或编号&gt;：指定要送出的信息；-u：指定用户。</code></pre><p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，下面是常用的信号：</p><pre><code>HUP     1    终端断线INT     2    中断（同 Ctrl + C）QUIT    3    退出（同 Ctrl + \）TERM   15    终止KILL    9    强制终止CONT   18    继续（与STOP相反， fg/bg命令）STOP   19    暂停（同 Ctrl + Z）</code></pre><p>实例</p><pre><code>先用ps查找进程，然后用kill杀掉：ps -ef | grep vimroot      3268  2884  0 16:21 pts/1    00:00:00 vim install.logroot      3370  2822  0 16:21 pts/0    00:00:00 grep vimkill 3268</code></pre><h1 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h1><pre><code>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这 些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。例如nginx启动后有2个进程killall nginx </code></pre><h1 id="SELinux功能"><a href="#SELinux功能" class="headerlink" title="SELinux功能"></a>SELinux功能</h1><p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，这个功能管理员又爱又恨，大多数生产环境也是关闭的做法，安全手段使用其他方法。</p><pre><code>大多数ssh连接不上虚拟机，都是因为防火墙和selinux阻挡了</code></pre><p>永久关闭方式：</p><pre><code>1.修改配置文件，永久生效关闭selinuxcp /etc/selinux/config /etc/selinux/config.bak #修改前备份2.修改方式可以vim编辑,找到# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX=disabled3.用sed替换sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config4.检查状态grep &quot;SELINUX=disabled&quot; /etc/selinux/config#出现结果即表示修改成功</code></pre><p>临时关闭selinux(命令行修改，重启失效)：</p><pre><code>getenforce #获取selinux状态#修改selinux状态setenforce usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]数字0 表示permissive，给出警告，不会阻止，等同disabled数字1表示enforcing，表示开启</code></pre><p>Tip:</p><pre><code>修改selinux配置后，想要生效还得重启系统，技巧就是（修改配置文件+命令行修改，达到立即生效）生产环境的服务器是禁止随意重启的！！！！</code></pre><h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><pre><code>在学习阶段，关闭防火墙可以更方便的学习，在企业环境中，一般只有配置外网ip的linux服务器才会开启防火墙，但是对于高并发流量的业务服务器仍然是不能开启的，会有很大性能损失，因此需要更nb的硬件防火墙。</code></pre><p>关闭防火墙具体操作如下：</p><pre><code>centos7默认已经使用firewall作为防火墙了1.关闭防火墙systemctl status firewalld #查看防火墙状态systemctl stop firewalld    #关闭防火墙systemctl disable firewalld#关闭防火墙开机启动systemctl is-enabled firewalld.service#检查防火墙是否启动</code></pre><h1 id="Linux中文显示设置（防止中文乱码）"><a href="#Linux中文显示设置（防止中文乱码）" class="headerlink" title="Linux中文显示设置（防止中文乱码）"></a>Linux中文显示设置（防止中文乱码）</h1><p>此项优化为可选项，根据个人情况选择是否调整Linux系统的字符集，字符集就是一套文字符号以及编码。</p><p>Linux下常用字符集有：</p><pre><code>GBK　　实际企业应用较少UTF-8　　广泛支持，MYSQL也使用UTF-8，企业广泛使用#查看系统当前字符集echo $LANG#检查xshell crt的字符集#命令修改字符集export LANG=en_US.utf81.修改配置文件/etc/locale.confLANG=&quot;zh_CN.UTF-8&quot;2.更改后查看系统语言变量locale</code></pre><p>乱码核心解决办法</p><pre><code>1.系统字符集utf82.xshell字符集utf83.文件字符集一致zh_CN.UTF-8</code></pre><p>df命令</p><p>df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获<br>取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><pre><code>语法df(选项)(参数)-h或--human-readable：以可读性较高的方式来显示信息；-k或--kilobytes：指定区块大小为1024字节；-T或--print-type：显示文件系统的类型；--help：显示帮助；--version：显示版本信息。</code></pre><p>示例</p><pre><code>查看系统磁盘设备，默认是KB为单位：df使用-h选项以KB以上的单位来显示，可读性高：df -h</code></pre><h1 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h1><p>tree命令以树状图列出目录的内容。<br>tree参数<br>    -a：显示所有文件和目录；<br>    -A：使用ASNI绘图字符显示树状图而非以ASCII字符组合；<br>    -C：在文件和目录清单加上色彩，便于区分各种类型；<br>    -d：先是目录名称而非内容；<br>    -D：列出文件或目录的更改时间；<br>    -f：在每个文件或目录之前，显示完整的相对路径名称；<br>    -F：在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”，”/“，”@”，”|”号；<br>    -g：列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码；<br>    -i：不以阶梯状列出文件和目录名称；<br>    -l：&lt;范本样式&gt; 不显示符号范本样式的文件或目录名称；<br>    -l：如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录；<br>    -n：不在文件和目录清单加上色彩；<br>    -N：直接列出文件和目录名称，包括控制字符；<br>    -p：列出权限标示；<br>    -P：&lt;范本样式&gt; 只显示符合范本样式的文件和目录名称；<br>    -q：用“？”号取代控制字符，列出文件和目录名称；<br>    -s：列出文件和目录大小；<br>    -t：用文件和目录的更改时间排序；<br>    -u：列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码；<br>    -x：将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该目录予以排除在寻找范围外。</p><h1 id="设置主键名"><a href="#设置主键名" class="headerlink" title="设置主键名"></a>设置主键名</h1><pre><code>[root@haiyan /tmp 11:04:42]#hostnamectl set-hostname ward[root@ward ~ 11:05:12]#hostnameward</code></pre><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</code></pre><h1 id="查看Linux的dns，唯一配置文件"><a href="#查看Linux的dns，唯一配置文件" class="headerlink" title="查看Linux的dns，唯一配置文件"></a>查看Linux的dns，唯一配置文件</h1><pre><code>配置文件cat /etc/resolv.conf#dns服务器地址nameserver 119.29.29.29nameserver 223.5.5.5</code></pre><h1 id="本地强制dns解析文件-etc-hosts"><a href="#本地强制dns解析文件-etc-hosts" class="headerlink" title="本地强制dns解析文件/etc/hosts"></a>本地强制dns解析文件/etc/hosts</h1><pre><code>指定本地解析：/etc/hosts主机IP    主机名    主机别名127.0.0.1        www.xiaoxuedi.top</code></pre><h1 id="nslookuo命令"><a href="#nslookuo命令" class="headerlink" title="nslookuo命令"></a>nslookuo命令</h1><pre><code>nslookup命令是常用域名查询工具，就是查DNS信息用的命令。nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。#解析nslookup www.xiaoxuedi.top</code></pre><h1 id="计划任务crond服务"><a href="#计划任务crond服务" class="headerlink" title="计划任务crond服务"></a>计划任务crond服务</h1><p>你每天是怎么起床的？有的人有女朋友，，或是男朋友，，而我是被穷醒的，，，</p><p>什么是计划任务<br>：<br>    后台运行，到了预定的时间就会自动执行的任务，前提是：事先手动将计划任务设定好。这就用到了crond服务</p><pre><code>crond服务相关的软件包[root@MiWiFi-R3-srv ~]# rpm -qa |grep croncronie-anacron-1.4.11-14.el7.x86_64crontabs-1.11-6.20121102git.el7.noarchcronie-1.4.11-14.el7.x86_64这些包在最小化安装系统时就已经安装了，并且会开机自启动crond服务，并为我们提供好编写计划任务的crontab命令。</code></pre><p>crontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似</p><p>语法</p><pre><code>crontab （选项）（参数）-e：编辑该用户的计时器设置；-l：列出该用户的计时器设置；-r：删除该用户的计时器设置；-u&lt;用户名称&gt;：指定要设定计时器的用户名称。存放定时任务的文件/var/spool/cron注意：1 查看计划任务的执行：tail -f /var/log/cron2 写计划任务时，命令必须加上绝对路径，否则会出现这种情况：从日志中看，确实触    发了计划任务的执行，但是命令却没有执行成功，比如* * * * * reboot就会    出现这种情况，需要将reboot写成/usr/sbin/reboot3.  计划任务执行的命令 是否存在，软件是否安装  4. 确保crontab服务运行      systemctl status cron    ps -ef|grep crond5. 检测crontab是否开机启动    systemctl is-enabled crond</code></pre><p>crontab配置文件</p><pre><code>在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed　分 时  日 月  周crontab任务配置基本格式：*  *　 *　 *　 *　　command分钟(0-59)　小时(0-23)　日期(1-31)　月份(1-12)　星期(0-6,0代表星期天)　 命令第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。30 08 * * *  每天8.30去上班  逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。*/3 * * * * /usr/sbin/ntpdate ntp1.aliyun.com  每隔三分钟执行下时间同步每天8.30上班30 08 * * *  去上班每天12下班回家睡觉00 00 * * *   回家睡觉</code></pre><p>实例</p><pre><code>所有命令一定要用绝对路径来写！#每分钟执行一次命令* * * * * 命令#每小时的3,15分组执行命令3,15 * * * * 命令#在上午8-11点的第3和第15分钟执行3,15 8-11 * * * 命令#每晚21:30执行命令30 21 * * * 命令#没周六、日的1：30执行命令30 1 * * 6,0 命令#每周一到周五的凌晨1点，清空/tmp目录的所有文件0 1 * * 1-5 /usr/bin/rm -rf /tmp/*#每晚的21:30重启nginx30 21 * * * /opt/nginx/sbin/nginx -s reload#每月的1,10,22日的4:45重启nginx45 4 1,1,10,22 * * /opt/nginx/sbin/nginx -s reload#每个星期一的上午8点到11点的第3和15分钟执行命令3,15 8-11 * * 1 command</code></pre><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h2 id="软件包是什么"><a href="#软件包是什么" class="headerlink" title="软件包是什么"></a>软件包是什么</h2><pre><code>程序(软件)组成部分：    二进制程序  可执行命令    库     .so文件    配置文件    .conf    帮助文件    readme    /usr/share/man软件包顾名思义就是将应用程序、配置文件和数据打包的产物，所有的linux发行版都采用了某种形式的软件包系统，这使得linux软件管理和在windows下一样方便，suse、red hat、fedora等发行版都是用rpm包，Debian和Ubuntu则使用.deb格式的软件包。mysql-5-3-4.rpmredis-3-4-3.rpmnginx2-3-2.rpm在早期系统运维中，安装软件是一件非常费事费力的事情。系统管理员不得不下载软件源代码编译软件，并且为了系统做各种调整。尽管源代码编译形式的软件增强了用户定制的自由度，但是在小软件上耗费精力是缺乏效率的，于是软件包应运而生。软件包管理可以将管理员从无休止的兼容问题中释放。yum工具就可以自动搜索依赖关系，并执行安装。</code></pre><h2 id="RPM软件包管理"><a href="#RPM软件包管理" class="headerlink" title="RPM软件包管理"></a>RPM软件包管理</h2><p>软件包管理器核心功能</p><pre><code>1.制作软件包  .rpm2.安装、卸载、升级、查询、校验</code></pre><p>　　在 RPM(红帽软件包管理器)公布之前，要想在 Linux 系统中安装软件只能采取源码<br>包 的方式安装。早期在 Linux 系统中安装程序是一件非常困难、耗费耐心的事情，而且大<br>多数 的服务程序仅仅提供源代码，需要运维人员自行编译代码并解决许多的软件依赖关系，<br>因此 要安装好一个服务程序，运维人员需要具备丰富知识、高超的技能，甚至良好的耐心。<br>而且在 安装、升级、卸载服务程序时还要考虑到其他程序、库的依赖关系，所以在进行校<br>验、安装、 卸载、查询、升级等管理软件操作时难度都非常大。</p><p>RPM 机制则为解决这些问题而设计的。RPM 有点像 Windows 系统中的控制面板，会建 立<br>统一的数据库文件，详细记录软件信息并能够自动分析依赖关系</p><p>实例</p><pre><code>#现在要安装mysql#下载地址https://dev.mysql.com/downloads/mysql/安装软件的命令格式                rpm -ivh filename.rpm     # i表示安装   v显示详细过程  h以进度条显示升级软件的命令格式                rpm -Uvh filename.rpm卸载软件的命令格式                rpm -e filename.rpm查询软件描述信息的命令格式         rpm -qpi filename.rpm列出软件文件信息的命令格式         rpm -qpl filename.rpm查询文件属于哪个 RPM 的命令格式 　 rpm -qf filename</code></pre><h3 id="rpm安装软件"><a href="#rpm安装软件" class="headerlink" title="rpm安装软件"></a>rpm安装软件</h3><pre><code>#下载软件包wget https://rpmfind.net/linux/centos/7.5.1804/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm#安装软件包[root@haiyan /tmp 11:03:42]#rpm -ivh lrzsz-0.12.20-36.el7.x86_64.rpmPreparing...                          ################################# [100%]Updating / installing...1:lrzsz-0.12.20-36.el7             ################################# [100%]</code></pre><h3 id="rpm查询软件"><a href="#rpm查询软件" class="headerlink" title="rpm查询软件"></a>rpm查询软件</h3><pre><code>rpm -q lrzsz  #查询lrzsz是否安装rpm -qi lrzsz #查询lrzsz包的说明信息rpm -ql lrzsz #查询lrzsz包生成的文件列表rpm -qc nginx  #查询nginx安装生成后的配置文件路径rpm -qf /etc/nginx/fastcgi.conf  #查看这个文件由哪个rpm包安装</code></pre><h3 id="rpm升级软件"><a href="#rpm升级软件" class="headerlink" title="rpm升级软件"></a>rpm升级软件</h3><pre><code>rpm -Uvh /PATH/TO/NEW_PACKAGE_FILE: 如果装有老版本的，则升级；否则，则安装；rpm -Fvh /PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出；</code></pre><h3 id="rpm卸载软件"><a href="#rpm卸载软件" class="headerlink" title="rpm卸载软件"></a>rpm卸载软件</h3><pre><code>rpm -e PACKAGE_NAME需要手动解决依赖不如 yum remove</code></pre><h3 id="rpm的依赖问题，因此不太好用"><a href="#rpm的依赖问题，因此不太好用" class="headerlink" title="rpm的依赖问题，因此不太好用"></a>rpm的依赖问题，因此不太好用</h3><p>其一，难以删除</p><pre><code>[root@haiyan /tmp 11:42:01]#rpm -e nginxerror: Failed dependencies:    nginx is needed by (installed) nginx-mod-mail-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-perl-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-xslt-filter-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-image-filter-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-stream-1:1.12.2-2.el7.x86_64    nginx is needed by (installed) nginx-mod-http-geoip-1:1.12.2-2.el7.x86_64</code></pre><p>其二，难以安装</p><pre><code>[root@haiyan /tmp 11:45:07]#rpm -ivh zsh-5.6.2-9.6.2.aarch64.rpmwarning: zsh-5.6.2-9.6.2.aarch64.rpm: Header V3 RSA/SHA256 Signature, key ID 3dbdc284: NOKEYerror: Failed dependencies:    ld-linux-aarch64.so.1()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    ld-linux-aarch64.so.1(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libdl.so.2(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libm.so.6(GLIBC_2.17)(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libncursesw.so.6()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64    libtinfo.so.6()(64bit) is needed by zsh-5.6.2-9.6.2.aarch64</code></pre><h2 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h2><pre><code>yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。尽管 RPM 能够帮助用户查询软件相关的依赖关系，但问题还是要运维人员自己来解决， 而有些大型软件可能与数十个程序都有依赖关系，在这种情况下安装软件会是非常痛苦的。 Yum 软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum 软件仓库可以 根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安 装到系统。Yum 软件仓库中的 RPM 软件包可以是由红帽官方发布的，也可以是第三方发布的，当 然也可以是自己编写的</code></pre><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><pre><code>yum(选项)(参数)-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。</code></pre><p>实例</p><pre><code>部分常用的命令包括：自动搜索最快镜像插件　   yum install yum-fastestmirror</code></pre><h3 id="yum配置"><a href="#yum配置" class="headerlink" title="yum配置"></a>yum配置</h3><p>什么是yum源？</p><pre><code>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。说到yum源就必须说到linux系统中特有的依赖关系问题，yum就是为了解决依赖关系而存在的。yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好。YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题。</code></pre><p>YUM的基本工作机制如下：</p><pre><code>服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。 客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</code></pre><p>yum源的目录</p><pre><code>#进入yum源目录cd /etc/yum.repos.d/#查看yum源文件ls -l</code></pre><h3 id="配置阿里云yum源"><a href="#配置阿里云yum源" class="headerlink" title="配置阿里云yum源"></a>配置阿里云yum源</h3><pre><code>1.好习惯，备份yum源mkdir repo_bakmv *.repo repo_bak/2.下载阿里云repo文件wget http://mirrors.aliyun.com/repo/Centos-7.repo3.清空yum缓存并且生成新的yum缓存yum clean allyum makecache4.安装软件扩展源yum install -y epel-release复制代码复制代码yum repolist all        列出所有仓库yum list all            列出仓库所有软件包yum info 软件包名            查看软件包信息yum install 软件包名        安装软件包yum reinstall 软件包名    重新安装软件包yum update    软件包名        升级软件包yum remove    软件包名        移除软件包yum clean all            清楚所有仓库缓存yum check-update        检查可以更新的软件包yum grouplist            查看系统中已安装的软件包yum groupinstall 软件包组    安装软件包组</code></pre><h1 id="系统服务管理命令"><a href="#系统服务管理命令" class="headerlink" title="系统服务管理命令"></a>系统服务管理命令</h1><p>如果之前学习或者使用过RHEL6系统，应该已经习惯了service、chkconfig等命令来管理系统服务，</p><p>但是在RHEL7系统中改变了systemctl来管理系统服务。</p><img src="/2018/03/18/Linux基本系统优化/3.png"><p>设置开机启动相关</p><img src="/2018/03/18/Linux基本系统优化/4.png"><h1 id="必须掌握的-etc下的linux目录知识"><a href="#必须掌握的-etc下的linux目录知识" class="headerlink" title="必须掌握的/etc下的linux目录知识"></a>必须掌握的/etc下的linux目录知识</h1><h2 id="etc："><a href="#etc：" class="headerlink" title="/etc："></a>/etc：</h2><p>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><pre><code>#网卡配置文件/etc/sysconfig/network-script/ifcfg-eth0#修改机器名以及网卡，网管等配置/etc/sysconfig/network#linux的dns客户端配置文件，实现域名和ip的互相解析/etc/resolv.conf#本地dns解析文件,设定ip和域名的对应解析,开发测试最常用的临时域名解析/etc/hosts/#系统全局环境变量永久生效的配置文件,如PATH等/etc/profile#用户的环境变量~/.bash_profile ~/.bashrc#存放可执行程序的目录，大多是系统管理命令/usr/sbin#存放用户自编译安装软件的目录  &gt; 等同于C:\Program files （windows）/usr/local#关于处理器的信息,还可以top指令查看/proc/cpuinfo#查看内存信息，还可以free -m</code></pre><h2 id="Linux下安装程序的方法"><a href="#Linux下安装程序的方法" class="headerlink" title="Linux下安装程序的方法"></a>Linux下安装程序的方法</h2><pre><code>rpm -ivh 包名.rpm　　需要手动解决依赖关系yum install 包名          yum自动处理依赖关系编译安装（源码安装）</code></pre><h2 id="安装Lrzsz"><a href="#安装Lrzsz" class="headerlink" title="安装Lrzsz"></a>安装Lrzsz</h2><pre><code>#安装此软件，即可拖拽上传下载linux代码到windowsyum install lrzsz</code></pre><h2 id="服务器无法上网错误"><a href="#服务器无法上网错误" class="headerlink" title="服务器无法上网错误"></a>服务器无法上网错误</h2><pre><code>1.yum报错    Error couldn&apos;t resolve host &apos;mirrorlist.centos.org&apos;2.ping www.baidu.com 看是否能上网3.如果百度不通，ping ip通了ping 119.29.29.29  ，说明dns有问题</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;Linux的网络功能相当强悍，一时之间我们无法了解所有的网络命令，
在配置服务器基础环境时，先了解下网络参数设定命令。

ifconfig　　查询、设置网卡和ip等参数
ifup,ifdown    脚本命令，更简单的方式启动关闭网络
ip　　符合指令，直接
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>vim</title>
    <link href="http://yoursite.com/2018/03/17/vim/"/>
    <id>http://yoursite.com/2018/03/17/vim/</id>
    <published>2018-03-17T11:09:09.000Z</published>
    <updated>2018-11-28T11:16:10.829Z</updated>
    
    <content type="html"><![CDATA[<pre><code>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</code></pre><h1 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h1><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><h1 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h1><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p><h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><pre><code>用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令</code></pre><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><pre><code>w(e)　　移动光标到下一个单词b　　　　移动到光标上一个单词数字0　　移动到本行开头$　　　　移动光标到本行结尾H　　　　移动光标到屏幕首行M　　　　移动到光标到屏幕的中间一行L　　　　移动光标到屏幕的尾行gg　　　 移动光标到文档的首行G　　　　移动光标到文档尾行ctrl + f　　下一页ctrl + b　　上一页`.　　移动光标到上一次的修改行</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code>/chaoge     在整篇文档中搜索chaoge字符串,向下查找?chaoge     在整篇文档中搜索chaoge字符串,向上查找*        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处#        查找整个文档，匹配光标所在的所有单词,按下n查找下一处,N上一处gd        找到光标所在单词匹配的单词，并停留在非注释的第一个匹配上%　　　　找到括号的另一半！！</code></pre><h2 id="复制，删除，粘贴"><a href="#复制，删除，粘贴" class="headerlink" title="复制，删除，粘贴"></a>复制，删除，粘贴</h2><pre><code>yy    拷贝光标所在行dd    删除光标所在行D     删除当前光标到行尾的内容dG    删除当前行到文档尾部的内容p     粘贴yy所复制的内容x　　 删除光标所在的字符u     撤销上一步的操作</code></pre><h2 id="数字与命令"><a href="#数字与命令" class="headerlink" title="数字与命令"></a>数字与命令</h2><pre><code>3yy　　　　拷贝光标所在的3行5dd　　　　删除光标所在5行输入模式在命令模式下按下字母i</code></pre><p>即可进入输入模式，可以编写代码啦。。。</p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下输入冒号（英文的:），就进入了底线命令模式，在底线命令模式下可以输入单个或多个字符的命令，常用命令有：</p><pre><code>:q!     强制退出:wq!    强制写入退出:set nu 显示行号:数字　　调到数字那行随时按下esc可以退出底线命令模式</code></pre><h1 id="vim工作模式"><a href="#vim工作模式" class="headerlink" title="vim工作模式"></a>vim工作模式</h1><h2 id="vim按键"><a href="#vim按键" class="headerlink" title="vim按键"></a>vim按键</h2><h2 id="移动光标-1"><a href="#移动光标-1" class="headerlink" title="移动光标"></a>移动光标</h2><pre><code>移动光标的方法h 或 向左箭头键(←)    光标向左移动一个字符j 或 向下箭头键(↓)    光标向下移动一个字符k 或 向上箭头键(↑)    光标向上移动一个字符l 或 向右箭头键(→)    光标向右移动一个字符向下移动5行　　　　　　5j向右移动10字符　　　　10ln(space)　　　　按下数字n,例如10，然后按下空格，光标会向右移动10个字符</code></pre><h2 id="底线命令"><a href="#底线命令" class="headerlink" title="底线命令"></a>底线命令</h2><pre><code>:! command    暂时离开vim指令模式，执行command的结果例如  :!ip a    临时看一下ip信息，然后可以回到vim:set nu　　　　显示vim行号:set nonu　　　　取消行号</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。

但是目前我们使用比较多的是 vim 编辑器。

vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。
&lt;/code&gt;&lt;/pre&gt;&lt;h1
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="http://yoursite.com/2018/03/16/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/16/Linux基本命令/</id>
    <published>2018-03-16T01:29:30.000Z</published>
    <updated>2018-11-28T11:02:16.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统命令操作语法格式"><a href="#Linux系统命令操作语法格式" class="headerlink" title="Linux系统命令操作语法格式"></a>Linux系统命令操作语法格式</h1><pre><code>命令    空格    参数    空格    【文件或路径】需要处理的内容rm         -rf         /tmp/*ls          -la         /home结婚         -没车没房         女的就行结婚         -有车有房         白富美</code></pre><p>1.一般情况下，【参数】是可选的，一些情况下【文件或路径】也是可选的</p><p>2.参数 &gt; 同一个命令，跟上不同的参数执行不同的功能</p><pre><code>执行linux命令，添加参数的目的是让命令更加贴切实际工作的需要！linux命令，参数之间，普遍应该用一个或多个空格分割！</code></pre><h1 id="创建一个目录-haiyan"><a href="#创建一个目录-haiyan" class="headerlink" title="创建一个目录  /haiyan"></a>创建一个目录  /haiyan</h1><pre><code>make directory &gt; mk dir &gt; mkdir-------------------------------mkdir /haiyan-------------------------------cd /mkdir haiyan#递归创建a/b   c/dmkdir -p a/b c/d#递归创建test/a,b,c,d四个目录mkdir -p test/{a,b,c,d}#递归创建文件夹a/b/c/d/emkdir -p a/b/c/d/e</code></pre><h1 id="查看目录-haiyan"><a href="#查看目录-haiyan" class="headerlink" title="查看目录 /haiyan"></a>查看目录 /haiyan</h1><pre><code>#显示/haiyan下的内容ls /haiyan</code></pre><h1 id="改变当前的目录-位置"><a href="#改变当前的目录-位置" class="headerlink" title="改变当前的目录/位置"></a>改变当前的目录/位置</h1><pre><code>cd /homecd ~cd -</code></pre><p>换来换去的，迷路了怎么办？我到底在哪个目录？</p><h1 id="打印当前工作目录"><a href="#打印当前工作目录" class="headerlink" title="打印当前工作目录"></a>打印当前工作目录</h1><pre><code>#打印当前工作目录pwd </code></pre><h1 id="创建文件或者修改文件时间戳-文件属性"><a href="#创建文件或者修改文件时间戳-文件属性" class="headerlink" title="创建文件或者修改文件时间戳(文件属性)"></a>创建文件或者修改文件时间戳(文件属性)</h1><pre><code>创建文本修改文件的修改时间#修改文件的更改时间，很多黑客就会在恶意修改文件之后再修改成之前的时间ls -l echo &apos;sb&apos; &gt;&gt; xxx.pytouch -t&apos;07101530&apos; 1.txt#触摸touch xxx.py</code></pre><h1 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h1><pre><code>显示文件或文件系统的状态。#用法 stat  [参数]  文件参数列表：-L, --dereference     跟随链接-f, --file-system     显示文件系统状态而非文件状态-c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行    --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作                                输出结尾。如果您仍希望使用换行，可以在格式中                                加入&quot;\n&quot;-t, --terse           使用简洁格式输出    --help            显示此帮助信息并退出    --version         显示版本信息并退出格式化输出参数：%a    八进制权限%A   用可读性较好的方式输出权限#实例1[root@master tmp]# stat 1.txtFile: &apos;1.txt&apos;Size: 0             Blocks: 0          IO Block: 4096   regular empty fileDevice: fd00h/64768d    Inode: 17348002    Links: 1(权限)Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)(最近访问)Access: 2018-07-10 15:30:00.000000000 +0800(最近更改)Modify: 2018-07-10 15:30:00.000000000 +0800(最近改动)Change: 2018-11-07 15:38:36.400989868 +0800Birth: -#实例2，显示文件权限[root@master tmp]# stat -c %a 1.txt[root@master tmp]# stat -c %A 1.txt-rw-r--r--</code></pre><h1 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi/vim"></a>vi/vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><pre><code>#方法，命令vivim使用vi打开haiyan.py,默认是命令模式，需要输入a/i/o进入编辑模式,然后输入文本&quot;Life is short,i use python&quot;按下esc键，回到命令模式输入  :wq!  强制保存退出w write 写入q quit 退出! 强制或者  :x 保存退出------:q  不保存退出:q! 不保存强制退出</code></pre><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><p>查看文件内容<br>cat命令用于查看纯文本文件（常用于内容较少的）</p><pre><code>#查看文件，显示行号cat -n xxx.py#猫,查看文件cat xxx.py#在每一行的结尾加上$符[root@master tmp]# cat -E 1.txt#追加文字到文件cat &gt;&gt;/tmp/haiyan.txt &lt;&lt; EOF唧唧复唧唧木兰开飞机开的什么机波音747EOF</code></pre><h1 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h1><p>1.more命令用于查看内容较多的文本，例如要看一个很长的配置文件，cat查看内容屏幕会快速翻滚到结尾。</p><p>2.more命令查看文本会以百分比形式告知已经看到了多少，使用回车键向下读取内容</p><pre><code>more /etc/passwd按下空格space是翻页按下b键是上一页回车键向下读取内容</code></pre><h1 id="linux快捷键"><a href="#linux快捷键" class="headerlink" title="linux快捷键"></a>linux快捷键</h1><pre><code>1.tab键    用于自动补全命令/文件名/目录名2.ctrl + l　　清理终端显示 3.clear/cls  清理终端显示4.ctrl + c 终止当前操作</code></pre><h1 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h1><p>echo命令用于在终端输出字符串或变量提取后的值，格式是“echo 【字符串|$变量】”</p><pre><code>#默认吧内容显示到终端上    echo &quot;666&quot;#把“666”写入到文件里！echo &quot;666&quot; &gt; /tmp/hiayan.txtecho $PATH #取出打印PATH的值</code></pre><h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><pre><code>输入/输出 重定向符号1.&gt;&gt;    追加重定向，把文字追加到文件的结尾2.&gt;     重定向符号，清空原文件所有内容，然后把文字覆盖到文件末尾3.&lt;     输入重定向4.&lt;&lt;    将输入结果输入重定向echo &quot;python666&quot; &gt; /tmp/haiyan.txtecho &quot;go666&quot; &gt;&gt; /tmp/haiyan.txtcat &gt;&gt;/tmp/haiyan.txt &lt;&lt; EOF------------------------------------我想把命令执行的结果信息，写入到文件中ip addr &gt; /tmp/network.txt   #标准输出重定向 把命令执行结果信息，放入到文件中3.通配符  ls -l /etc/us*</code></pre><h1 id="赋值（拷贝）命令"><a href="#赋值（拷贝）命令" class="headerlink" title="赋值（拷贝）命令"></a>赋值（拷贝）命令</h1><pre><code>复制 &gt; copy &gt; cp#移动xxx.py到/tmp目录下cp xxx.py /tmp/#移动xxx.py顺便改名为python.pycp xxx.py /tmp/python.pyLinux下面很多命令，一般没有办法直接处理文件夹,因此需要加上（参数） cp -r 递归,复制目录以及目录的子孙后代cp -p 复制文件，同时保持文件属性不变    可以用statcp -a 相当于-pdr#递归复制test文件夹，为test2cp -r test test2cp是个好命令，操作文件前，先备份cp main.py main.py.bak</code></pre><h1 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h1><pre><code>移动（搬家）命令  &gt; move &gt; mvcd /homemv /home/haiyan /tmp/ward文件/文件夹改名mv x.log xx.log</code></pre><h1 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h1><pre><code>删除  &gt; remove &gt; rm参数  -i  需要删除确认　　　-f  强制删除    -r  递归删除目录和内容cd /tmprm oldboy.py#默认有提示删除，需要输入yrm -f oldboy.py #不需要提示,强制删除#rm默认无法删除目录，需要跟上参数-rrm -rf /tmp/oldboy/--------友情提醒:初学者使用rm命令，随时快照虚拟机</code></pre><h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><pre><code>#Linux里如何找到需要的文件 例如 haiyan.pyfind 在哪里(目录) 什么类型（文件类型） 叫什么名字（文件名）参数-name 按照文件名查找文件-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。s - socket文件find /tmp/ -type f  -name &quot;haiyan.py&quot;#找出/tmp所有以 .txt 结尾的文件find /tmp/ -type f -name &quot;*.txt&quot;#找到/etc下所有名字以host开头的文件find /etc -name &apos;host*&apos;#找到/opt上一个名为settings.pyfind /opt -name &apos;settings.py&apos;</code></pre><h1 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h1><pre><code>Linux提供的管道符“|”讲两条命令隔开，管道符左边命令的输出会作为管道符右边命令的输入。常见用法：#检查python程序是否启动ps -ef|grep &quot;python&quot;#找到/tmp目录下所有txt文件ls /tmp|grep &apos;.txt&apos;#检查nginx的端口是否存活netstat -tunlp |grep nginx</code></pre><p>命令格式： 命令A | 命令B</p><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><pre><code>(global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。语法：grep [参数] [--color=auto] [字符串] filename参数详解:-i : 忽略大小写-n : 输出行号-v : 反向选择--color = auto : 给关键词部分添加颜色grep &quot;我要找什么&quot; /tmp/haiyan.txt#排除 -v，排除我要找的东西grep -v &quot;我要找什么 /tmp/haiyan.txt例题，找出/etc/passwd下root用户所在行，以及行号，显示颜色cat /etc/passwd |grep &apos;^root&apos; --color=auto -n找出/etc/passwd所有不允许登录的用户grep /sbin/nologin /etc/passwd找到/etc/passwd的所有与mysql有关行，行号cat /etc/passwd |grep &apos;mysql&apos; -n</code></pre><h2 id="head、tail命令"><a href="#head、tail命令" class="headerlink" title="head、tail命令"></a>head、tail命令</h2><pre><code>head显示文件前几行，默认前10行tail显示文件后几行，默认后10行#查看前两行head -2 /tmp/haiyan.txt#查看后两行tail -2 /tmp/haiyan.txt#持续刷新显示tail -f xx.log#显示文件10-30行head -30 /tmp/haiyan.txt |tail -21</code></pre><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><pre><code>sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。命令格式sed [options] &apos;command&apos; file(s)sed [options] -f scriptfile file(s)选项-e&lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；-f&lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；-h或--help：显示帮助；-n或--quiet或——silent：仅显示script处理后的结果；-V或--version：显示版本信息。-i ∶插入， i 的后面可以接字串</code></pre><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><pre><code>a\ 在当前行下面插入文本。i\ 在当前行上面插入文本。c\ 把选定的行改为新的文本。d 删除，删除选择的行。D 删除模板块的第一行。s 替换指定字符h 拷贝模板块的内容到内存中的缓冲区。H 追加模板块的内容到内存中的缓冲区。g 获得内存缓冲区的内容，并替代当前模板块中的文本。G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。l 列表不能打印字符的清单。n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。p 打印模板块的行。P(大写) 打印模板块的第一行。q 退出Sed。b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。r file 从file中读行。t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。w file 写并追加模板块到file末尾。  W file 写并追加模板块的第一行到file末尾。  ! 表示后面的命令对所有没有被选定的行发生作用。  = 打印当前行号码。  # 把注释扩展到下一个换行符以前。  </code></pre><h3 id="sed替换标记"><a href="#sed替换标记" class="headerlink" title="sed替换标记"></a>sed替换标记</h3><pre><code>g 表示行内全面替换。  p 表示打印行。  w 表示把行写入一个文件。  x 表示互换模板块中的文本和缓冲区中的文本。  y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）\1 子串匹配标记&amp; 已匹配字符串标记</code></pre><h3 id="sed元字符集"><a href="#sed元字符集" class="headerlink" title="sed元字符集"></a>sed元字符集</h3><pre><code>^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。&amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。\&lt; 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。\&gt; 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。</code></pre><h3 id="sed实际用例"><a href="#sed实际用例" class="headerlink" title="sed实际用例"></a>sed实际用例</h3><pre><code>#替换haiyan.txt中所有的haiyan变为haiyan_python#此时结果输出到屏幕,不会写入到文件sed &apos;s/haiyan/haiyan_python/&apos; /tmp/haiyan.txt#使用选项-i，匹配每一行第一个oldboy替换为haiyan_python,并写入文件sed -i &apos;s/haiyan/haiyan_python/&apos; /tmp/haiyan.txt#使用替换标记g，同样可以替换所有的匹配sed -i &apos;s/book/books/g&apos; /tmp/haiyan.txt#删除文件第二行sed -i &apos;2d&apos; /tmp/haiyan.txt#删除空白行sed -i &apos;/^$/d&apos; /tmop/haiyan.txt#删除文件第二行，到末尾所有行sed &apos;2,$d&apos; /tmp/haiyan.txt#显示10-30行-p --print-n --取消默认输出sed -n &apos;10,30p&apos; /tmp/haiyan.txt</code></pre><h1 id="别名alias命令"><a href="#别名alias命令" class="headerlink" title="别名alias命令"></a>别名alias命令</h1><pre><code>别名alias命令Linux在使用rm（删除）、cp（覆盖）、mv（搬家）等命令的时候，必须非常小心，因为这些命令都是“炸弹”，想必大家都听过“删库到跑路”，一言不合“rm -rf /”，假如你真的这么做了，那么。。。上帝保佑你</code></pre><p> Linux如何提示，在使用这些命令时候，提醒你小心呢？</p><pre><code>#查看系统别名alias默认别名alias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;别名作用是：我们在linux中使用cp时候相当于执行了cp -i-i：删除已有文件或目录之前先询问用户；#别名用比较危险的操作,防止你犯错 </code></pre><h1 id="为rm设置别名"><a href="#为rm设置别名" class="headerlink" title="为rm设置别名"></a>为rm设置别名</h1><pre><code>#让系统显示 do not use rmecho do not use rm#设置rm别名alias rm=&apos;echo do not use rm&apos;#设置别名永久生效,写入到/etc/profile(针对登录用户的合同，设置环境变量)vim /etc/profile #编辑文件G　　快速到达最后一行o　　当前行下一行，创建一个新行，进入编辑模式source /etc/profile #读取文件（合同生效）---------------#取消别名unalias rm</code></pre><h1 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h1><pre><code>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。which pwdwhich python</code></pre><p>实例</p><pre><code>which python       #python命令在哪/usr/bin/python    #命令文件绝对路径</code></pre><h1 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h1><p>Linux scp命令用于Linux之间复制文件和目录。</p><pre><code>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。语法scp 【可选参数】 本地源文件 远程文件标记参数-r :递归复制整个目录-v:详细方式输出-q:不显示传输进度条-C：允许压缩实例复制代码#传输本地文件到远程地址scp 本地文件  远程用户名@远程ip:远程文件夹/scp 本地文件  远程用户名@远程ip:远程文件夹/远程文件名scp /tmp/haiyan.py root@192.168.1.155:/home/scp /tmp/haiyan.py root@192.168.1.155:/home/haiyan_python.pyscp -r  本地文件夹  远程用户名@远程ip:远程文件夹/scp -r /tmp/haiyan root@192.168.1.155:/home/haiyan#复制远程文件到本地scp root@192.168.1.155:/home/haiyan.txt /tmp/haiyan.txtscp -r root@192.168.1.155:/home/haiyan /home/</code></pre><h1 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h1><p>Linux du命令用于显示目录或文件的大小。</p><p>du会显示指定的目录或文件所占用的磁盘空间。</p><pre><code>用法du 【参数】【文件或目录】-s 显示总计-h 以k，M,G为单位显示，可读性强</code></pre><p>实例</p><pre><code>显示目录或文件所占空间#什么都不跟，代表显示当前目录所有文件大小du   #显示/home的总大小du -sh /home</code></pre><h1 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h1><p>top 命令用于动态地监视进程活动与系统负载等信息</p><p>统计信息区</p><pre><code>第一行 (uptime)系统时间 主机运行时间 用户连接数(who) 系统1，5，15分钟的平均负载第二行:进程信息进程总数 正在运行的进程数 睡眠的进程数 停止的进程数 僵尸进程数第三行:cpu信息1.5 us：用户空间所占CPU百分比0.9 sy：内核空间占用CPU百分比0.0 ni：用户进程空间内改变过优先级的进程占用CPU百分比97.5 id：空闲CPU百分比0.2 wa：等待输入输出的CPU时间百分比0.0 hi：硬件CPU中断占用百分比0.0 si：软中断占用百分比0.0 st：虚拟机占用百分比第四行：内存信息（与第五行的信息类似与free命令）8053444 total：物理内存总量7779224 used：已使用的内存总量274220 free：空闲的内存总量（free+used=total）359212 buffers：用作内核缓存的内存量第五行：swap信息8265724 total：交换分区总量33840 used：已使用的交换分区总量8231884 free：空闲交换区总量4358088 cached Mem：缓冲的交换区总量，内存中的内容被换出到交换区，然后又被换入到内存，但是使用过的交换区没有被覆盖，交换区的这些内容已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再对交换区写入。</code></pre><h1 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h1><pre><code>给文件加锁，只能写入数据，无法删除文件chattr +a test.pychattr -a test.py</code></pre><h1 id="lsattr命令"><a href="#lsattr命令" class="headerlink" title="lsattr命令"></a>lsattr命令</h1><pre><code>查看文件隐藏属性lsattr test.py</code></pre><h1 id="linux时间同步"><a href="#linux时间同步" class="headerlink" title="linux时间同步"></a>linux时间同步</h1><p>linux的date命令可以显示当前时间或者设置系统时间</p><p>格式化输出</p><pre><code>-d    --date=string    显示指定的时间，而不是当前时间以年-月-日显示当前时间date +&quot;%Y-%m-%d&quot;以年-月-日 时分秒 显示当前时间date +&quot;%Y-%m-%d %T&quot;在Linux下系统时间和硬件时间不会自动同步，在Linux运行过程中，系统时间和硬件时间以异步的方式运行，互不干扰。硬件时间的运行，是靠Bios电池来运行，而系统时间是用CPU tick来维持的。在系统开机时候，会从Bios中获取硬件时间，设置为系统时间硬件始终的查看[root@python ~ 10:19:04]#hwclock同步系统时间和硬件时间，可以用hwclock命令//以系统时间为基准，修改硬件时间[root@python ~ 10:29:07]#hwclock -w//以硬件时间为基准，修改系统时间[root@python ~ 10:29:21]#hwclock -s</code></pre><h1 id="Ntp时间服务器"><a href="#Ntp时间服务器" class="headerlink" title="Ntp时间服务器"></a>Ntp时间服务器</h1><pre><code>时间对于人类来说是密不可少的，时间就是金钱。因此对于服务器时间的把控非常重要，如果系统的时间不对，那么对于每一个文件的操作都是错误的。关于时间服务器的配置文件，有如下几种/bin/date     用于 Linux 时间 (软件时钟) 的修改与显示的指令；/sbin/hwclock　　用于 BIOS 时钟 (硬件时钟) 的修改与显示的指令。 这是一个 root 才能执行的指令，因为 Linux 系统上面 BIOS 时间与 Linux 系统时间是分开的，所以使用 date 这个指令调整了时间之后，还需要使用 hwclock 才能将修改过后的时间写入 BIOS 当中！/usr/sbin/ntpd： 主要提供 NTP 服务的程序啰！配置文件为 /etc/ntp.conf/usr/sbin/ntpdate： 用于客户端的时间校正，如果你没有要启用 NTP 而仅想要使用 NTP Client 功能的话，那么只会用到这个指令而已啦！由于我们只需要用作客户端更新时间ntpdate -u ntp.aliyun.com</code></pre><h1 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h1><pre><code>wget命令用于在终端下载网络文件参数是 wget [参数] 下载地址wget -r -p http://www.xx.com#递归下载xx所有资源，保存到www.xx.com文件中</code></pre><h1 id="开关机命令"><a href="#开关机命令" class="headerlink" title="开关机命令"></a>开关机命令</h1><pre><code>reboot命令用于重启机器poweroff用于关闭系统</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统命令操作语法格式&quot;&gt;&lt;a href=&quot;#Linux系统命令操作语法格式&quot; class=&quot;headerlink&quot; title=&quot;Linux系统命令操作语法格式&quot;&gt;&lt;/a&gt;Linux系统命令操作语法格式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;命令    空格  
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux文件系统结构</title>
    <link href="http://yoursite.com/2018/03/15/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/15/Linux文件系统结构/</id>
    <published>2018-03-15T08:50:24.000Z</published>
    <updated>2018-11-28T09:28:12.053Z</updated>
    
    <content type="html"><![CDATA[<p>Linux之文档与目录结构</p><h1 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h1><pre><code>Linux目录结构的组织形式和Windows有很大的不同。首先Linux没有“盘(C盘、D盘、E盘)”的概念。已经建立文件系统的硬盘分区被挂载到某一个目录下，用户通过操作目录来实现磁盘读写。Linux不像Windows那样的系统目录，Linux使用正斜杠&quot;/&quot;而不是反斜杠&quot;\&quot;来标识目录。</code></pre><p>Linux首先是建立一个根”/“文件系统，所有的目录也都是由根目录衍生出来。</p><img src="/2018/03/15/Linux文件系统结构/3.png"><p>登录系统后，在当前命令窗口输入命令:</p><p>ls /</p><p>查看结果如下图：</p><img src="/2018/03/15/Linux文件系统结构/4.png"><pre><code>在Linux底下，所有的文件与目录都是由根目录开始，是目录与文件的源头，然后一个个的分支下来，如同树枝状，因此称为这种目录配置为：目录树。目录树的特点是什么呢？目录树的起始点是根目录(/,root);每一个目录不止能使用本地的文件系统，也可以使用网络上的文件系统，可以利用NFS服务器挂载特定目录。每一个文件在此目录树中的文件名，包含完整路径都是独一无二的。</code></pre><h2 id="目录树架构示意图"><a href="#目录树架构示意图" class="headerlink" title="目录树架构示意图"></a>目录树架构示意图</h2><img src="/2018/03/15/Linux文件系统结构/5.png"><p>以下是对这些目录的解释</p><img src="/2018/03/15/Linux文件系统结构/6.png"><pre><code>/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all/root：该目录为系统管理员，也称作超级权限者的用户主目录。/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。/selinux：这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。</code></pre><h1 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h1><pre><code>我们知道切换目录的指令是cd，那么首先得知道如何切换目录，这个得用心记呀！.    当前目录..    上一层目录-    前一个工作目录~    当前【用户】所在的家目录需要注意的是，在所有目录底下都存在两个目录，分别是【.】和【..】，分别代表当前目录，上层目录！那么如何证明它的存在呢？命令： ls -la /查看命令解释：man ls  (Linux下的帮助指令)结论：ls - list directory contens (列出目录内容)ls -la /  以竖状格式化显示列出/目录所有内容</code></pre><img src="/2018/03/15/Linux文件系统结构/7.png"><p>接下来看一下常用的目录处理指令：</p><pre><code>cd : (change directory,更改目录)pwd:(显示当前目录)mkdir:(建立一个新目录)rmdir:（删除一个空目录）</code></pre><h2 id="cd命令，变换目录"><a href="#cd命令，变换目录" class="headerlink" title="cd命令，变换目录"></a>cd命令，变换目录</h2><p>cd是change directory的缩写，这是用来变换工作目录的命令，注意命令和目录之间有一个空格。</p><img src="/2018/03/15/Linux文件系统结构/8.png"><h2 id="mkdir，建立新目录"><a href="#mkdir，建立新目录" class="headerlink" title="mkdir，建立新目录"></a>mkdir，建立新目录</h2><pre><code>mkdir是make directory的缩写，用来建立新目录，在默认情况下，目录得一级一级的建立。例如我要建立/home/haiyan/python目录，我就必须有/home，然后/home/oldboy，最后/home/haiyan/python，如果没有/home/haiyan，则不能建立python目录！可见高效的创建目录用上-p参数，可以直接执行命令【mkdir -p /home/hiayan/python】，系统会自动添加上/home，/home/haiyan，/home/haiyan/python依次建立目录，是不是很方便，^ ^ </code></pre><h2 id="rmdir，删除空目录"><a href="#rmdir，删除空目录" class="headerlink" title="rmdir，删除空目录"></a>rmdir，删除空目录</h2><pre><code>当我想删除一个空目录时，就用rmdir吧，例如我想删除刚才建立的haiyan目录，以及/tmp/haiyan/python,那么可以使用【rmdir haiyan】，但是注意rmdir只能删除空目录。删除命令可以正确使用【rm -rf】</code></pre><h2 id="Linux的路径PATH"><a href="#Linux的路径PATH" class="headerlink" title="Linux的路径PATH"></a>Linux的路径PATH</h2><p>会配置windows下的环境变量（PATH），都知道系统会按照PATH的设定，去每个PATH定义的目录下搜索可执行文件。</p><p>那么如何查看Linux下的PATH环境变量呢？</p><pre><code>执行命令：echo $PATHecho命令是有打印的意思$符号后面跟上PATH,表示输出PATH的变量</code></pre><img src="/2018/03/15/Linux文件系统结构/10.png"><p>PATH(一定是大写的)这个变量是由一堆目录组成，分隔符是”:”号，而不同于windows的”;”号。</p><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><p>Linux下特别注意文件名/路径的写法，可以将所谓的路径(path)定义为绝对路径(absolute)和相对路径(relative)。这两种文件名/路径的写法依据是这样的：</p><p>绝对路径：由根目录(/)为开始写起的文件名或者目录名称，如/home/haiyan/test.py;<br>相对路径：相对于目前路径的文件名写法。例如./home/haiyan/exam.py或../../home/haiyan/exam.py，简单来说只要开头不是/，就是属于相对路径<br>因此你必须了解，相对路径是：以你当前所在路径的相对路径来表示的。</p><img src="/2018/03/15/Linux文件系统结构/11.png"><p>例如你现在在/home 这个目录下，如要进入/var/log这个路径，如何写呢？</p><p>cd /var/log (绝对路径)<br>cd ../var/log(相对路径)<br>结果如图：</p><p>因为你在/home底下，因此你要回到上一层(../)之后，才能继续前往/var，特别注意：</p><pre><code>.   :代表当前的目录，也可以用./ 来表示..  :代表上一层的目录，也可以用../来表示</code></pre><img src="/2018/03/15/Linux文件系统结构/12.png"><p> 分割线—-</p><img src="/2018/03/15/Linux文件系统结构/13.png"><pre><code>这个.与..目录概念非常重要，平时经常会看到cd ..或者python ../home/haiyan/exam.py 就是代表进入上一层与执行相对路径的python代码！1.linux是以 / 开始的树状目录结构,tree查看2.常用文件目录操作命令是ls,cd,mkdir,rmdir3.Linux的PATH查看是 echo $PATH，可以修改/etc/profile文件永久生效,以冒号分割4.绝对路径,相对路径的查看5.文件权限chmod chgrp chown</code></pre><h2 id="Linux的文件系统"><a href="#Linux的文件系统" class="headerlink" title="Linux的文件系统"></a>Linux的文件系统</h2><pre><code>用户在硬件存储设备中执行的文件建立，写入，读取，修改，转存与控制等操作都是依赖文件系统完成的。文件系统的作用是合理规划硬盘，保证用户正常使用。</code></pre><p>Linux系统支持数十种文件系统，常见文件系统如下。</p><pre><code>Ext3    是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能 自动修复数据的不一致与错误。Ext4     Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。另外，Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。XFS     是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。</code></pre><p>/etc/fstab是用来存放文件系统的静态信息的文件<br>cat /etc/fstab #检查linux的文件系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux之文档与目录结构&lt;/p&gt;
&lt;h1 id=&quot;Linux文件系统结构&quot;&gt;&lt;a href=&quot;#Linux文件系统结构&quot; class=&quot;headerlink&quot; title=&quot;Linux文件系统结构&quot;&gt;&lt;/a&gt;Linux文件系统结构&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Linux
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
</feed>
