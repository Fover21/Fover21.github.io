<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海燕的博客</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-13T04:56:37.330Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>海燕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue总结</title>
    <link href="http://yoursite.com/2018/11/13/Vue%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/13/Vue总结/</id>
    <published>2018-11-13T00:30:00.000Z</published>
    <updated>2018-11-13T04:56:37.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue总结"><a href="#vue总结" class="headerlink" title="vue总结"></a>vue总结</h1><blockquote><p>MVC  Model View Controller</p></blockquote><blockquote><p>MVVM Model View ViweMode</p></blockquote><h2 id="ES6常用语法"><a href="#ES6常用语法" class="headerlink" title="ES6常用语法"></a>ES6常用语法</h2><pre><code>1.1 变量的提升1.2 模板字符串 ``${}1.3 数据的结构1.4 类1.5 函数    1.5.1 注意this和普通函数的区别1.6 箭头函数1.7 单体模式</code></pre><h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><pre><code>2.1 v-text  innerText2.2 v-html  innerHtml2.3 v-for  :key2.4 v-if v-else-if v-else  appendChild2.5 v-show  display2.6 v-on  @xxxx=&quot;自己处理的方法&quot;2.7 v-bind  :属性名称=“属性的值”2.8 v-model    2.8.1 input    2.8.2 textarea    2.8.3 select2.9 指令修饰符    2.9.1 .lazy    2.9.2 .number    2.9.3 .trim2.10 计算属性    2.10.1 放入缓存    2.10.2 只有数据改变的时候才会重新计算2.11 数据监听    2.11.1 注意可变类型和不可变2.12 获取DOM    2.12.1 给便签绑定ref属性  ref=“属性值”    2.12.2 this.$refs.属性值2.13 自定义指令    2.13.1 vue.directive(“指令名称”, function(el, binding){        el 绑定指令的便签元素        binding 指令的所有信息    })</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>3.1 数据监听    3.1.1 改变数据        直接赋值    3.1.2 改变数组长度        能够被监听到，新值和旧值一样    3.1.3 改变数组内的值        app = new vue({})        app.$set(this.hobby, 0, &apos;抽烟&apos;)        $set()修改数组中的值可以监听        $delete()</code></pre><h2 id="Vue的组件"><a href="#Vue的组件" class="headerlink" title="Vue的组件"></a>Vue的组件</h2><h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><pre><code>Vue.compontent(“组件名称”, {})</code></pre><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><pre><code>const = app = new Vue({    el: &apos;#app&apos;,    components: {        组件的名称: 组件的配置信息    }})</code></pre><h4 id="子组件的注册"><a href="#子组件的注册" class="headerlink" title="子组件的注册"></a>子组件的注册</h4><pre><code>在父组件中注册components## 注意写组件标签## 每个组件的template只识别一个作用域块</code></pre><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h4 id="父子的通信"><a href="#父子的通信" class="headerlink" title="父子的通信"></a>父子的通信</h4><pre><code>在父组件中给子组件绑定属性子组件通过props=[&quot;属性名称&quot;]</code></pre><h4 id="子父的通信"><a href="#子父的通信" class="headerlink" title="子父的通信"></a>子父的通信</h4><pre><code>子组件先提交事件    this.$emit(&quot;事件名称&quot;, 值)在父组件中给子组件绑定事件    &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt;</code></pre><h4 id="非父子的通信"><a href="#非父子的通信" class="headerlink" title="非父子的通信"></a>非父子的通信</h4><pre><code>其中一个组件向中间调度器提交事件另一个组件监听中间调度器的事件注意this的问题中间调度器  let temp = new Vue();temp.$emit(&quot;say&quot;, value) // 事件名称和值mounted(){    that = this    // 监听中间调度器中的方法    temp.$on(&quot;say&quot;, function(data){        // 这里的this是temp的this        that.xxx = data // 这样改值    })}</code></pre><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><pre><code>&lt;slot&gt;&lt;/slot&gt;命名的插槽</code></pre><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><pre><code>代码重用的mixins = [base] </code></pre><h2 id="Vue的声明周期"><a href="#Vue的声明周期" class="headerlink" title="Vue的声明周期"></a>Vue的声明周期</h2><h3 id="vue生命周期之beforeCreate"><a href="#vue生命周期之beforeCreate" class="headerlink" title="vue生命周期之beforeCreate"></a>vue生命周期之beforeCreate</h3><pre><code>实例创建之前除标签外，所有的vue需要的数据，事件都不存在</code></pre><h3 id="vue生命周期之created"><a href="#vue生命周期之created" class="headerlink" title="vue生命周期之created"></a>vue生命周期之created</h3><pre><code>实例创建之后，data和事件已经被解析到，el还没有找到</code></pre><h3 id="vue生命周期之beforeMount"><a href="#vue生命周期之beforeMount" class="headerlink" title="vue生命周期之beforeMount"></a>vue生命周期之beforeMount</h3><pre><code>开始找标签，数据还没有被渲染，事件也没有被监听</code></pre><h3 id="vue生命周期之mounted"><a href="#vue生命周期之mounted" class="headerlink" title="vue生命周期之mounted"></a>vue生命周期之mounted</h3><pre><code>开始渲染数据，开始监听事件</code></pre><h3 id="vue生命周期之beforeUpdata"><a href="#vue生命周期之beforeUpdata" class="headerlink" title="vue生命周期之beforeUpdata"></a>vue生命周期之beforeUpdata</h3><pre><code>数据已经被修改在虚拟DOM，但没有被渲染到页面上</code></pre><h3 id="vue生命周期之updata"><a href="#vue生命周期之updata" class="headerlink" title="vue生命周期之updata"></a>vue生命周期之updata</h3><pre><code>开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改</code></pre><h3 id="vue生命周期之beforeDestory"><a href="#vue生命周期之beforeDestory" class="headerlink" title="vue生命周期之beforeDestory"></a>vue生命周期之beforeDestory</h3><pre><code>所有的数据都存在</code></pre><h3 id="vue生命周期之destoryed"><a href="#vue生命周期之destoryed" class="headerlink" title="vue生命周期之destoryed"></a>vue生命周期之destoryed</h3><pre><code>所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了&lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签用activated和deactivated取代了beforeUpdate和destory的执行</code></pre><h3 id="最常用的钩子"><a href="#最常用的钩子" class="headerlink" title="最常用的钩子"></a>最常用的钩子</h3><pre><code>beforeMountmounted</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><pre><code>let url = [    {        path: &apos;/&apos;,        name: &quot;home&quot;,        component: {            template: ``,        }    }]let router = nwe VueRouter({    routes: url})const app = new Vue({    el: &apos;app&apos;,    router: router,})&lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt;&lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h3 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h3><pre><code>children: [    {}]append在父路由对应的组件的template里面写router-link router-view</code></pre><h3 id="路由的命名"><a href="#路由的命名" class="headerlink" title="路由的命名"></a>路由的命名</h3><pre><code>name注意to加冒号动态绑定</code></pre><h3 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h3><pre><code>{    path: &quot;/course/:id&quot;,}this.$route.params.idthis.$route.query.xxx$route 是一个对象 存放当前路由的所有信息$router VueRouter实例化对象</code></pre><h3 id="手动路由"><a href="#手动路由" class="headerlink" title="手动路由"></a>手动路由</h3><pre><code>this.$router.push(&apos;/&apos;)this.$router.push({name:&quot;home&quot;})</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>redirect: {name: &apos;xxx&apos;}</code></pre><h3 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h3><pre><code>router.beforeEach(function(to, from next){    // to 你要去哪    // from 你要从哪里来    // next() 你要去做什么 参数可以给路径  必须有，没有就不走})router.afterEach(function(to, from){    // to 你要去哪    // from 你从哪里来})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue总结&quot;&gt;&lt;a href=&quot;#vue总结&quot; class=&quot;headerlink&quot; title=&quot;vue总结&quot;&gt;&lt;/a&gt;vue总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;MVC  Model View Controller&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
