<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django-admin管理工具]]></title>
    <url>%2F2018%2F11%2F15%2FDjango-admin%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[admin组件使用Django提供了基于web的管理工具 Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 settings.py 中的 INSTALLED_APPS 看到它： # Application definition INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &quot;app01&quot; ] django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。 激活管理工具 通常在生成项目的时候会在urls.py中自动设置好 from django.conf.urls import url from django.contrib import admin urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), ] 当这一切配置好后，Django管理工具就可以运行了。 使用管理工具启动开发服务器，然后在浏览器中访问 http://127.0.0.1:8000/admin/，得到登陆界面， 你可以通过命令 python manage.py createsuperuser 来创建超级用户。 为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin from django.db import models # Create your models here. class Author(models.Model): name=models.CharField( max_length=32) age=models.IntegerField() def __str__(self): return self.name class Publish(models.Model): name=models.CharField( max_length=32) email=models.EmailField() def __str__(self): return self.name class Book(models.Model): title = models.CharField( max_length=32) publishDate=models.DateField() price=models.DecimalField(max_digits=5,decimal_places=2) publisher=models.ForeignKey(to=&quot;Publish&quot;) authors=models.ManyToManyField(to=&apos;Author&apos;) def __str__(self): return self.title admin的定制在admin中只需要将Model中的某个类注册，即可在Admin中实现增删改查的功能，如： admin.site.register(models.UserInfo) 但是这种方式比较简单，如果想进行更多的定制操作，需要利用ModelAdmin进行操作， 如： 方式一： class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,) admin.site.register(models.UserInfo, UserAdmin) # 第一个参数可以是列表 方式二： @admin.register(models.UserInfo) # 第一个参数可以是列表 class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,) ModelAdmin中提供了大量的可定制功能，如： 1 list_display，列表时，定制显示的列。 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;) def xxxxx(self, obj): return &quot;xxxxx&quot; 2 list_display_links，列表时，定制列可以点击跳转。 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;) list_display_links = (&apos;pwd&apos;,) 3 list_filter，列表时，定制右侧快速筛选。4 list_select_related，列表时，连表查询是否自动select_related5 list_editable，列表时，可以编辑的列 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,&apos;ug&apos;,) list_editable = (&apos;ug&apos;,) 6 search_fields，列表时，模糊搜索的功能 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): search_fields = (&apos;user&apos;, &apos;pwd&apos;) 7 date_hierarchy，列表时，对Date和DateTime类型进行搜索 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): date_hierarchy = &apos;ctime&apos; 8 inlines，详细页面，如果有其他表和当前表做FK，那么详细页面可以进行动态增加和删除 class UserInfoInline(admin.StackedInline): # TabularInline extra = 0 model = models.UserInfo class GroupAdminMode(admin.ModelAdmin): list_display = (&apos;id&apos;, &apos;title&apos;,) inlines = [UserInfoInline, ] 9 action，列表时，定制action中的操作 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): # 定制Action行为具体方法 def func(self, request, queryset): print(self, request, queryset) print(request.POST.getlist(&apos;_selected_action&apos;)) func.short_description = &quot;中文显示自定义Actions&quot; actions = [func, ] # Action选项都是在页面上方显示 actions_on_top = True # Action选项都是在页面下方显示 actions_on_bottom = False # 是否显示选择个数 actions_selection_counter = True 10 定制HTML模板 add_form_template = None change_form_template = None change_list_template = None delete_confirmation_template = None delete_selected_confirmation_template = None object_history_template = None 11 raw_id_fields，详细页面，针对FK和M2M字段变成以Input框形式 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): raw_id_fields = (&apos;FK字段&apos;, &apos;M2M字段&apos;,) 12 fields，详细页面时，显示字段的字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): fields = (&apos;user&apos;,) 13 exclude，详细页面时，排除的字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): exclude = (&apos;user&apos;,) 14 readonly_fields，详细页面时，只读字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): readonly_fields = (&apos;user&apos;,) 15 fieldsets，详细页面时，使用fieldsets标签对数据进行分割显示 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): fieldsets = ( (&apos;基本数据&apos;, { &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;, &apos;ctime&apos;,) }), (&apos;其他&apos;, { &apos;classes&apos;: (&apos;collapse&apos;, &apos;wide&apos;, &apos;extrapretty&apos;), # &apos;collapse&apos;,&apos;wide&apos;, &apos;extrapretty&apos; &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;), }), ) 16 详细页面时，M2M显示时，数据移动选择（方向：上下和左右） @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): filter_vertical = (&quot;m2m字段&quot;,) # 或filter_horizontal = (&quot;m2m字段&quot;,) 17 ordering，列表时，数据排序规则 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): ordering = (&apos;-id&apos;,) 或 def get_ordering(self, request): return [&apos;-id&apos;, ] 18 radio_fields，详细页面时，使用radio显示选项（FK默认使用select） radio_fields = {&quot;ug&quot;: admin.VERTICAL} # 或admin.HORIZONTAL 19 form = ModelForm，用于定制用户请求时候表单验证 from app01 import models from django.forms import ModelForm from django.forms import fields class MyForm(ModelForm): others = fields.CharField() class Meta: model = models = models.UserInfo fields = &quot;__all__&quot; @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): form = MyForm 20 empty_value_display = “列数据为空时，显示默认值” @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): empty_value_display = &quot;列数据为空时，默认显示&quot; list_display = (&apos;user&apos;,&apos;pwd&apos;,&apos;up&apos;) def up(self,obj): return obj.user up.empty_value_display = &quot;指定列数据为空时，默认显示&quot; 例子： from django.contrib import admin # Register your models here. from .models import * class BookInline(admin.StackedInline): # TabularInline extra = 0 model = Book class BookAdmin(admin.ModelAdmin): list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;,&quot;foo&quot;,&quot;publisher&quot;) list_display_links = (&apos;publishDate&apos;,&quot;price&quot;) list_filter = (&apos;price&apos;,) list_editable=(&quot;title&quot;,&quot;publisher&quot;) search_fields = (&apos;title&apos;,) date_hierarchy = &apos;publishDate&apos; preserve_filters=False def foo(self,obj): return obj.title+str(obj.price) # 定制Action行为具体方法 def func(self, request, queryset): print(self, request, queryset) print(request.POST.getlist(&apos;_selected_action&apos;)) func.short_description = &quot;中文显示自定义Actions&quot; actions = [func, ] # Action选项都是在页面上方显示 actions_on_top = True # Action选项都是在页面下方显示 actions_on_bottom = False # 是否显示选择个数 actions_selection_counter = True change_list_template=&quot;my_change_list_template.html&quot; class PublishAdmin(admin.ModelAdmin): list_display = (&apos;name&apos;, &apos;email&apos;,) inlines = [BookInline, ] admin.site.register(Book, BookAdmin) # 第一个参数可以是列表 admin.site.register(Publish,PublishAdmin) admin.site.register(Author) admin源码解析单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式主要目的是确保 某一个类只有一个实例存在。当我们希望在整个系统中，某个类只能出现一个实例 时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个APPConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方需要使用配置文 件的内容，也就是说，很多地方都需要APPConfig的实例对象，而这样会严重浪费 内存资源，尤其是在配置文件内容很多的情况下。事实上，类似AppConfig这样的 类，我们希望在程序运行期间只存在一个实例对象。 在python中，我们可以用很多种方式来实现单例模式：使用模块（模块的导入）使用new使用装饰器（decorator）使用元类（metaclass）（1）使用new 为了使类只能出现一个实例，我们可以使用new来控制实例的创建过程，代码 如下： class Singleton(object): _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 在上面的代码中，我们将类的实例和一个类变量instance关联起来，如果cls.instance为None则创建实例，否则直接返回cls._instance执行情况： &gt;&gt;&gt; one = MyClass() &gt;&gt;&gt; two = MyClass() &gt;&gt;&gt; one == two True &gt;&gt;&gt; one is two True &gt;&gt;&gt; id(one), id(two) (4303862608, 4303862608) (2)使用模块 其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当 第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的 函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可 以考虑这样做： # mysingleton.py class My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码保存在文件 mysingleton.py 中，然后这样使用： from mysingleton import my_singleton my_singleton.foo() admin执行流程循环加载执行所有已经注册的app中的admin.py文件def autodiscover(): autodiscover_modules(&apos;admin&apos;, register_to=site) 执行代码＃admin.py class BookAdmin(admin.ModelAdmin): list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;) admin.site.register(Book, BookAdmin) admin.site.register(Publish) admin.siteclass AdminSite(object):... # This global object represents the default admin site, for the common case. # You can instantiate AdminSite in your own code to create a custom admin site. site = AdminSite() 这里应用的是一个单例模式，对于AdminSite类的一个单例模式，执行的每一个app中的每一个admin.site 都是一个对象。 执行register方法admin.site.register(Book, BookAdmin) admin.site.register(Publish) class ModelAdmin(BaseModelAdmin):pass def register(self, model_or_iterable, admin_class=None, **options): if not admin_class: admin_class = ModelAdmin # Instantiate the admin class to save in the registry self._registry[model] = admin_class(model, self) # 思考：在每一个app的admin .py中加上 print(admin.site._registry) ＃ 执行结果？ 到这里，注册结束！ admin的URL配置urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), ] class AdminSite(object): def get_urls(self): from django.conf.urls import url, include urlpatterns = [] # Add in each model&apos;s views, and create a list of valid URLS for the # app_index valid_app_labels = [] for model, model_admin in self._registry.items(): urlpatterns += [ url(r&apos;^%s/%s/&apos; % (model._meta.app_label, model._meta.model_name), include(model_admin.urls)), ] if model._meta.app_label not in valid_app_labels: valid_app_labels.append(model._meta.app_label) return urlpatterns @property def urls(self): return self.get_urls(), &apos;admin&apos;, self.name url方法的扩展应用from django.shortcuts import HttpResponse def test01(request): return HttpResponse(&quot;test01&quot;) def test02(request): return HttpResponse(&quot;test02&quot;) urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^ward/&apos;, ([ url(r&apos;^test01/&apos;, test01), url(r&apos;^test02/&apos;, test02), ],None,None)), ] 扩展优化from django.conf.urls import url,include from django.contrib import admin from django.shortcuts import HttpResponse def change_list_view(request): return HttpResponse(&quot;change_list_view&quot;) def add_view(request): return HttpResponse(&quot;add_view&quot;) def delete_view(request): return HttpResponse(&quot;delete_view&quot;) def change_view(request): return HttpResponse(&quot;change_view&quot;) def get_urls(): temp=[ url(r&quot;^$&quot;.format(app_name,model_name),change_list_view), url(r&quot;^add/$&quot;.format(app_name,model_name),add_view), url(r&quot;^\d+/del/$&quot;.format(app_name,model_name),delete_view), url(r&quot;^\d+/change/$&quot;.format(app_name,model_name),change_view), ] return temp url_list=[] for model_class,obj in admin.site._registry.items(): model_name=model_class._meta.model_name app_name=model_class._meta.app_label # temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),(get_urls(),None,None)) temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),include(get_urls())) url_list.append(temp) urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^ward/&apos;, (url_list,None,None)), ]]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的视图和路由]]></title>
    <url>%2F2018%2F11%2F15%2FDRF_view_router%2F</url>
    <content type="text"><![CDATA[Django-Rest-Framework的视图APIViewdjango中写CBV的时候继承的是View，rest_framework继承的是APIView，那么他们两个有什么不同呢 urlpatterns = [ url(r&apos;^book$&apos;, BookView.as_view()), url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), ] 可以看到，不管是View还是APIView最开始调用的都是as_view()方法，那走进源码看看 我们能看到，APIView继承了View, 并且执行了View中的as_view()方法，最后把view返回了，用csrf_exempt()方法包裹后去掉了csrf的认证。 那我们看看View中的as_view()方法做了什么 我们看到了~在View中的as_view方法返回了view函数，而view函数执行了self.dispatch()方法~~但是这里的dispatch方法应该是我们APIView中的 我们去initialize_request中看下把什么赋值给了request，并且赋值给了self.request, 也就是我们在视图中用的request.xxx到底是什么 我们看到，这个方法返回的是Request这个类的实例对象 我们注意我们看下这个Request类中的第一个参数request，是我们走我们django的时候的原来的request~ 我们看到了，这个Request类把原来的request赋值给了self._request, 也就是说以后_request是我们老的request，新的request是我们这个Request类 那我们继承APIView之后请求来的数据都在哪呢~~ 我们用了rest_framework框架以后，我们的request是重新封装的Request类~ request.query_params 存放的是我们get请求的参数 request.data 存放的是我们所有的数据，包括post请求的以及put，patch请求 相比原来的django的request，我们现在的request更加精简，清晰了~~~ 现在我们知道了APIView和View的一些区别~~当然还有~~后面还会说~~ 我们写的视图可能对多个表进行增删改查，就导致我们的视图特别多重复的代码~~ 那么我们尝试着来进行封装一下~~ 第一次封装APIView视图class BookView(APIView): def get(self, request): query_set = Book.objects.all() book_ser = BookSerializer(query_set, many=True) return Response(book_ser.data) def post(self, request): query_set = request.data book_ser = BookSerializer(data=query_set) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) class BookEditView(APIView): def get(self, request, id): query_set = Book.objects.filter(id=id).first() book_ser = BookSerializer(query_set) return Response(book_ser.data) def patch(self, request, id): query_set = Book.objects.filter(id=id).first() book_ser = BookSerializer(query_set, data=request.data, partial=True) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) def delete(self, request, id): query_set = Book.objects.filter(id=id).first() if query_set: query_set.delete() return Response(&quot;&quot;) else: return Response(&quot;删除的书籍不存在&quot;) 第一次封装class GenericAPIView(APIView): queryset = None serializer_class = None def get_queryset(self): return self.queryset.all() def get_serializer(self, *args, **kwargs): return self.serializer_class(*args, **kwargs) class ListModelMixin(object): def list(self, request, *args, **kwargs): queryset = self.get_queryset() serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) class CreateModelMixin(object): def create(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) class RetrieveModelMixin(object): def retrieve(self, request, id, *args, **kwargs): book_obj = self.get_queryset().filter(pk=id).first() book_ser = self.get_serializer(book_obj) return Response(book_ser.data) class UpdateModelMixin(object): def update(self, request, id, *args, **kwargs): book_obj = self.get_queryset().filter(pk=id).first() book_ser = self.get_serializer(book_obj, data=request.data, partial=True) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) class DestroyModelMixin(object): def destroy(self, request, id, *args, **kwargs): queryset = self.get_queryset() try: queryset.get(pk=id).delete() return Response(&quot;&quot;) except Exception as e: return Response(&quot;信息有误&quot;) # 我们把公共的部分抽出来 这样不管写多少表的增删改查都变的很简单 # 这样封装后我们的视图会变成这样 class BookView(GenericAPIView, ListModelMixin, CreateModelMixin): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class BookEditView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, id, *args, **kwargs): return self.retrieve(request, id, *args, **kwargs) def patch(self, request, id, *args, **kwargs): return self.update(request, id, *args, **kwargs) def destroy(self, request, id, *args, **kwargs): return self.delete(request, id, *args, **kwargs) 我们封装的GenericAPIView，包括封装每个方法的类，其实框架都帮我们封装好了~~ 我们可以直接继承这些类来实现上面的视图可是还有没有更简单的方法呢~我们再次封装一下~~ 第二次封装# 上面我们写的继承类太长了~~我们再改改 class ListCreateAPIView(GenericAPIView, ListModelMixin, CreateModelMixin): pass class RetrieveUpdateDestroyAPIView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): pass class BookView(ListCreateAPIView): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class BookEditView(RetrieveUpdateDestroyAPIView): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, id, *args, **kwargs): return self.retrieve(request, id, *args, **kwargs) def patch(self, request, id, *args, **kwargs): return self.update(request, id, *args, **kwargs) def delete(self, request, id, *args, **kwargs): return self.delete(request, id, *args, **kwargs) 这次我们只是让继承变的简单了一点而已，好像并没有什么大的进步我们可不可以把这两个视图合并成一个视图呢~~~框架给我们提供了一个路由传参的方法 我们看下ViewSetMixin action这个默认参数其实就是我们路由可以进行传参了 下面这个循环~可以看出~我们要传的参数是一个字段~key应该是我们的请求方式，value应该对应我们处理的方法~ 这样我们每个视图就不用在写函数了~因为已经和内部实现的函数相对应了~ 第三次封装路由 urls.pyurlpatterns = [ # url(r&apos;^book$&apos;, BookView.as_view()), # url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), url(r&apos;^book$&apos;, BookView.as_view({&quot;get&quot;: &quot;list&quot;, &quot;post&quot;: &quot;create&quot;})), url(r&apos;^book/(?P&lt;pk&gt;\d+)$&apos;, BookView.as_view({&quot;get&quot;: &quot;retrieve&quot;, &quot;patch&quot;: &quot;update&quot;, &quot;delete&quot;: &quot;destroy&quot;})), ] 第三次封装from rest_framework.viewsets import ViewSetMixin # class BookView(ViewSetMixin, ListCreateAPIView, RetrieveUpdateDestroyAPIView): # queryset = Book.objects.all() # serializer_class = BookSerializer # 如果我们再定义一个类 class ModelViewSet(ViewSetMixin, ListCreateAPIView, RetrieveUpdateDestroyAPIView): pass class BookView(ModelViewSet): queryset = Book.objects.all() serializer_class = BookSerializer 我们现在的视图就只要写两行就可以了 其实我们写的所有的视图~框架都帮我们封装好了 注意一点~用框架封装的视图~我们url上的那个关键字参数要用pk~系统默认的 奉献一张图来看下我们的继承顺序 Django-Rest-Framework的路由我们上面的路由传参写的特别多~~框架也帮我们封装好了~ from .views import BookView from rest_framework.routers import DefaultRouter router = DefaultRouter() router.register(r&quot;book&quot;, BookView) urlpatterns = [ # url(r&apos;^book$&apos;, BookView.as_view()), # url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), # url(r&apos;^book$&apos;, BookView.as_view({&quot;get&quot;: &quot;list&quot;, &quot;post&quot;: &quot;create&quot;})), # url(r&apos;^book/(?P&lt;pk&gt;\d+)$&apos;, BookView.as_view({&quot;get&quot;: &quot;retrieve&quot;, &quot;patch&quot;: &quot;update&quot;, &quot;delete&quot;: &quot;destroy&quot;})), ] urlpatterns += router.urls 我们可以看到通过框架我们可以把路由视图都变的非常简单~~ 但是需要自定制的时候还是需要我们自己用APIView写，当不需要那么多路由的时候，也不要用这种路由注册~~ 总之一切按照业务需要去用~~~]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework代码记录]]></title>
    <url>%2F2018%2F11%2F15%2FDjangoRestFramework%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[主要文件代码[TOC] 表结构设计1234567891011121314151617181920212223242526272829303132# models.py 文件from django.db import modelsBOOK_CATEGORIES = ((1, 'Python'), (2, 'Linux'), (3, 'Go'))__all__ = ['Book', 'Author', 'Publisher']class Book(models.Model): title = models.CharField(max_length=32) category = models.IntegerField(choices=BOOK_CATEGORIES) pub_date = models.DateField() authors = models.ManyToManyField(to='Author') publisher = models.ForeignKey(to='Publisher', on_delete=models.CASCADE) def __str__(self): return self.titleclass Author(models.Model): name = models.CharField(max_length=32) def __str__(self): return self.nameclass Publisher(models.Model): title = models.CharField(max_length=32) address = models.CharField(max_length=32) def __str__(self): return self.title 自定义Serializer方式一：继承serializers.Serializer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# serializers.pyfrom rest_framework import serializersfrom appone.models import Bookclass PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32)class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32)SENSITIVE_WORDS = ['极品', '最美', '之王', '之最']def my_validator(value): """ 自定义过滤器，可以传到字段的validators参数中 :param value: :return: """ if value in SENSITIVE_WORDS: raise serializers.ValidationError("含有敏感词汇")class BookSerializer(serializers.Serializer): id = serializers.IntegerField(required=False) # required为False时，反序列化不做校验 title = serializers.CharField(max_length=32, validators=[my_validator,]) pub_date = serializers.DateField() category = serializers.CharField(source="get_category_display", read_only=True) post_category = serializers.IntegerField(write_only=True) # 序列化不做校验，反序列化做校验 # 内部通过外键关系的Id拿到publisher_obj，然后把publisher_obj传入PublisherSerializer序列化器进行序列化 publisher = PublisherSerializer(read_only=True) authors = AuthorSerializer(many=True, read_only=True) publisher_id = serializers.IntegerField(write_only=True) # 反序列化时使用，前端传数据时以此名称作为建 author_list = serializers.ListField(write_only=True) # 反序列化时使用 def create(self, validated_data): book_obj = Book.objects.create( title=validated_data['title'], pub_date=validated_data['pub_date'], category=validated_data['post_category'], publisher_id=validated_data['publisher_id'] ) book_obj.authors.add(*validated_data['author_list']) return book_obj def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.pub_date = validated_data.get('pub_date', instance.pub_date) instance.category = validated_data.get('post_category', instance.category) instance.publisher_id = validated_data.get('publisher_id', instance.publisher_id) if validated_data.get('author_list'): instance.authors.set(validated_data['author_list']) instance.save() return instance def validate_title(self, value): """ 相当于局部钩子 :param value: 具体字段的值 :return: """ for word in SENSITIVE_WORDS: if word in value: raise serializers.ValidationError('标题含有敏感词汇') return value def validate(self, attrs): """ 相当于全局钩子 :param attrs: 所有字段组成的字典 :return: """ print("attrs:", attrs) return attrs"""继承serializers.Serializer自定义的Serializer中，必须定义create和update方法；当前端提交数据时，会在自定义的Serializer中查找create方法，当前端更新数据时，会在自定义的Serializer中查找update方法。添加新书时，前端传输数据示例：# 字段名称根据你创建的Serializer类中，为有外键关系字段定义的用于反序列化的具体名称决定&#123; "title": "自然语言处理", "pub_date": "2017-05-20", "post_category": 1, "publisher_id": 2, "author_list": [1, 2] &#125;""" 方式二：继承serializers.ModelSerializer 1234567891011121314151617181920212223242526272829303132333435363738394041class BookSerializer(serializers.ModelSerializer): # 有外键关系的字段和choices等一些特殊的字段，需要自定义展示效果；此处自定义的字段，在本类中必须有名称"get_字段"的钩子函数与其对应 # 注意：自定义的名字不要与原表中的字段名冲突 publisher_name = serializers.SerializerMethodField(read_only=True) authors_info = serializers.SerializerMethodField(read_only=True) category_name = serializers.SerializerMethodField(read_only=True) # 这是个钩子函数，会自动触发，此方法的返回值会赋值给上方的publisher_name def get_publisher_name(self, obj): return obj.publisher.title def get_authors_info(self, obj): author_queryset = obj.authors.all() return [&#123;'id': author.id, 'name': author.name&#125; for author in author_queryset] def get_category_name(self, obj): return obj.get_category_display() class Meta: model = Book fields = '__all__' # depth = 1 # 有外键关系的向下查找深度 extra_kwargs = &#123; "publisher": &#123;"write_only": True&#125;, "authors": &#123;"write_only": True&#125;, "category": &#123;"write_only": True&#125; &#125;"""继承serializers.ModelSerializer自定义的Serializer中，不用自定义create和update方法read_only=True 只在序列化时（后端传数据给前端浏览器用于展示），对字段进行校验write_only=True 只在反序列化时(后端拿到前端传过来的数据)，对字段进行校验添加新书时，前端传输数据示例：&#123; "publisher": 1, "authors": [1], "category": "1", "title": "Python袖珍指南", "pub_date": "2015-08-25" &#125;""" 路由文件项目的路由 12345678from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^api/', include("appone.urls")), url(r'^rest/', include("apprest.urls"))] 应用的路由 12345678# urls.pyfrom django.conf.urls import urlfrom .views import BookView, BookEditViewurlpatterns = [ url(r'^book$', BookView.as_view()), url(r'^book/(?P&lt;id&gt;\d+)', BookEditView.as_view()),] 视图函数文件1234567891011121314151617181920212223242526272829303132333435363738# views.pyfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom appone.models import Bookfrom .serializers import BookSerializerclass BookView(APIView): def get(self, request): book_queryset = Book.objects.all() ser_obj = BookSerializer(book_queryset, many=True) # 如果传给BookSerializer的第一个参数只是一个对象，many=True可以省略 # print(request.query_params) # &lt;QueryDict: &#123;'format': ['api'], 'name': ['jason']&#125;&gt; return Response(ser_obj.data) def post(self, request): book_data = request.data ser_obj = BookSerializer(data=book_data) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors) # 前端提交过来数据校验未通过，返回错误信息给前端class BookEditView(APIView): def get(self, request, id): book_obj = Book.objects.filter(id=id).first() ser_obj = BookSerializer(book_obj) return Response(ser_obj.data) def put(self, request, id): book_obj = Book.objects.filter(id=id).first() ser_obj = BookSerializer(instance=book_obj, data=request.data, partial=True) # partial=True表示允许校验部分字段，因为更改图书对象时，可能只是更改一个或几个字段；如果不设置partial=True，那么前端传过来的数据必须包含所有必须的字段，即字段要完整 if ser_obj.is_valid(): print(ser_obj.validated_data) ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors)]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-cli目录结构总结的步骤]]></title>
    <url>%2F2018%2F11%2F14%2Fvue-cli%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[main.js这是js的入口文件// The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; import axios from &apos;axios&apos; // 使用element-ui import ElementUI from &apos;element-ui&apos; import &apos;element-ui/lib/theme-chalk/index.css&apos; Vue.use(ElementUI); // 全局的（一个一个比较麻烦） // axios.request({ // url: XXX, // method: &quot;get&quot; // }); // 通过使用原型链 这样所有的组件都可以通过$axios去访问了 Vue.prototype.$axios = axios; Vue.config.productionTip = false; /* eslint-disable no-new */ new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); App.vue页面级App组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;MyHeader&gt;&lt;/MyHeader&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;MyFooter&gt;&lt;/MyFooter&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MyHeader from &quot;./components/MyHeader&quot; import MyFooter from &quot;./components/MyFooter&quot; export default { name: &apos;App&apos;, components: { MyHeader, MyFooter, } } &lt;/script&gt; &lt;style&gt; body { margin: 0; padding: 0; } &lt;/style&gt; router-index.jsimport Vue from &apos;vue&apos; import Router from &apos;vue-router&apos; import Home from &apos;../components/headers/Home&apos; import Course from &apos;../components/headers/Course&apos; Vue.use(Router); export default new Router({ routes: [ { path: &apos;/&apos;, name: &apos;home&apos;, component: Home }, { path: &apos;/course&apos;, name: &apos;course&apos;, component: Course } ] }) Vuex+axios的使用store.jsimport Vue from &quot;vue&quot; import Vuex from &quot;vuex&quot; Vue.use(Vuex); export default new Vuex.Store({ // this.$store.state.name 拿数据 state: { name: &apos;1&apos;, }, // 对state中的数据进行处理 // this.$store.getters.new_name 拿数据 getters: { new_name: function (state) { return state.name + &apos;xxx&apos;; }, new_new_name: function (state, getters) { return getters.new_name + &apos;000&apos;; }, }, mutations: { change_data: function (state, data) { // 自己处理change_data事件的 state.name = data; } } }) Course.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;course&lt;/h1&gt; {{name}} {{new_name}} &lt;hr&gt; {{try_again}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Course&quot;, data(){ return { name : this.$store.state.name, new_name: this.$store.getters.new_new_name, try_again: &apos;&apos;, } }, // 方法执行完会改版数据但是不会刷新 // methods: { // my_click: function () { // this.$store.commit(&quot;change_data&quot;, &apos;到到&apos;) // } // }, // 能够监听到数据的改变能够实时跟新 // computed: { // name: function () { // return this.$store.state.name; // } // } mounted(){ let that = this; this.$axios.request({ url: &quot;http://127.0.0.1:8000/tryagain/&quot;, method: &apos;get&apos;, }).then(function (data) { // success do something~~ that.try_again = data.data }).catch(function (data) { // fail do something~~ }) // 单纯的发get请求 // this.$axios.get(&quot;url&quot;, {}).then() } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git下]]></title>
    <url>%2F2018%2F11%2F14%2Fgit%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[分支管理策略1）master分支 非常稳定的，只用来发布新版本，平时不在上面干活 2）dev分支 不稳定的，主要在上面干活，每个人都有自己的分支，时不时的往dev分支上合并 通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 &gt; git log --graph --pretty=oneline --abbrev-commit Bug分支你目前在dev分支上工作，工作到一半，但突然有一个紧急的bug需要修复，可以先保存你的工作现场，修复完bug后，在切回来。 步骤： 当前在dev分支上： git stash # 把当前工作现场“储藏”起来 切换到要修复bug的分支（假定master）： git checkout master git checkout -b issue-101 .... 修复问题 git add filename git commit filename 把修改合并到修复的分支： git checkout master git merge --no-ff -m &quot;merge fix 101 modification&quot; issue-101 git branch -D issue-101 切换回工作现场： git checkout dev git stash list # 查看之前保存了哪些工作现场 git stash drop 两种恢复方式： 1）git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 git stash apply stash@{0} git stash drop stash@{0} 2）git stash pop，恢复的同时把stash内容也删了 Feature分支与bug分支类似 两条命令： 1）git branch -d dev_name # 已经合并完的分支可以使用此命令删除 2）git branch -d dev_name # 强制删除分支（未合并的也可以） 多人协作多个人在同一分支上工作，如何正确的合并文件？ 两种情况： **1）你和他人同时修改同一个文件，他人修改完成，提前推送到远程，如何提交你的修改** 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull拉取远程最新的版本； 3）如果合并有冲突，则解决冲突，并在本地提交； 4）没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 **2）你和他人操作的不是同一个文件 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，先用git pull拉取远程最新的版本； 3）git add . # 添加本地的全部修改到暂存区 4）git commit -m &quot;说明信息&quot; # 提交更改至本地 5）git push origin &lt;branch-name&gt;推送本地分支至远程 提交更改前，都要先git pull拉取远程最新版本 当从远程克隆时，Git自动把本地的master分支与远程的master分支对应起来，远程仓库的默认名称是origin。 查看远程库信息： git remote -v 推送分支： git push origin master 把本地的mater分支推送到远程对应的master分支上 git push origin dev 把本地的dev分支推送到远程对应的dev分支（远程没有dev分支会自动创建一个dev分支） 创建远程origin的dev分支到本地 git checkout -b dev origin/dev 指定本地dev分支与远程origin/dev分支的链接 git branch --set-upstream-to origin/dev dev 或 git branch --track origin/dev dev 标签tag是一个容易记住的有意义的名字，它跟某个commit绑定在一起。 打标签： git tag tag_name # 默认打在最新提交的commit上,当前HEAD的指向 git tag # 查看标签 git show tag_name # 查看标签详细信息 在指定的commit上打标签： git log --pretty=oneline # 查看commit id git log -a tag_name -m &quot;explain content&quot; commit_id 推送标签： git push origin tag_name # 推送一个指定的标签 git push origin --tags # 推送全部尚未推送到远程的本地标签 删除标签： 1) 标签尚未推送到远程 git tag -d tag_name 2）标签已推送到远程 git tag -d tag_name git push origin :refs/tags/tag_name Rebase解决查看log分支多，混乱的问题；遗留]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的序列化]]></title>
    <url>%2F2018%2F11%2F14%2FDjango-Rest-Framework%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[可以直接看总结 正常的序列化from django.http import HttpResponse, JsonResponse from django.views import View from demo import models import json from django.core import serializers class BookView(View): def get(self, request): book_queryset = models.Book.objects.all().values(&quot;id&quot;, &apos;title&apos;) book_list = list(book_queryset) # 方式一 # ret = json.dumps(book_list, ensure_ascii=False) # return HttpResponse(ret) # 方式二 Django的序列化 # book_list_obj = models.Book.objects.all() # ret = serializers.serialize(&apos;json&apos;, book_list_obj, ensure_ascii=False) # return HttpResponse(ret) # 方式三 return JsonResponse(book_list, safe=False, json_dumps_params={&quot;ensure_ascii&quot;: False}) 为什么要用序列化组件当我们做前后端分离的项目~~我们前后端交互一般都选择JSON数据格式，JSON是一个轻量级的数据交互格式。 那么我们给前端数据的时候都要转成json格式，那就需要对我们从数据库拿到的数据进行序列化。 接下来我们看下django序列化和rest_framework序列化的对比~~ Django的序列化方法.values序列化结果 class BooksView(View): def get(self, request): book_list = Book.objects.values(&quot;id&quot;, &quot;title&quot;, &quot;chapter&quot;, &quot;pub_time&quot;, &quot;publisher&quot;) book_list = list(book_list) # 如果我们需要取外键关联的字段信息 需要循环获取外键 再去数据库查然后拼接成我们想要的 ret = [] for book in book_list: pub_dict = {} pub_obj = Publish.objects.filter(pk=book[&quot;publisher&quot;]).first() pub_dict[&quot;id&quot;] = pub_obj.pk pub_dict[&quot;title&quot;] = pub_obj.title book[&quot;publisher&quot;] = pub_dict ret.append(book) ret = json.dumps(book_list, ensure_ascii=False, cls=MyJson) return HttpResponse(ret) # json.JSONEncoder.default() # 解决json不能序列化时间字段的问题 class MyJson(json.JSONEncoder): def default(self, field): if isinstance(field, datetime.datetime): return field.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) elif isinstance(field, datetime.date): return field.strftime(&apos;%Y-%m-%d&apos;) else: return json.JSONEncoder.default(self, field) django serializers from django.core import serializers # 能够得到我们要的效果 结构有点复杂 class BooksView(View): def get(self, request): book_list = Book.objects.all() ret = serializers.serialize(&quot;json&quot;, book_list) return HttpResponse(ret) DRF序列化的方法首先，我们要用DRF的序列化，就要遵循人家框架的一些标准， – Django我们CBV继承类是View，现在DRF我们要用APIView – Django中返回的时候我们用HTTPResponse，JsonResponse，render ，DRF我们用Response 序列化第一步 声明序列化类class BookSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;) pub_time = serializers.DateField() 第二步 序列化对象from rest_framework.views import APIView from rest_framework.response import Response class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) 外键关系的序列化from rest_framework import serializers from .models import Book class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) class UserSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) name = serializers.CharField(max_length=32) age = serializers.IntegerField() class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) 反序列化当前端给我们发post的请求的时候~前端给我们传过来的数据~我们要进行一些校验然后保存到数据库~ 这些校验以及保存工作，DRF的Serializer也给我们提供了一些方法了~~ 首先~我们要写反序列化用的一些字段~有些字段要跟序列化区分开~~ Serializer提供了.is_valid() 和.save()方法~~ .save()反序列化 serializer.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book 序列化 views.py class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) def post(self, request): # book_obj = request.data print(request.data) serializer = BookSerializer(data=request.data) if serializer.is_valid(): print(12341253) serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 当前端给我们发送patch请求的时候，前端传给我们用户要更新的数据，我们要对数据进行部分验证~~ .is_valid()PATCH请求serializers.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book def update(self, instance, validated_data): instance.title = validated_data.get(&quot;title&quot;, instance.title) instance.chapter = validated_data.get(&quot;w_chapter&quot;, instance.chapter) instance.pub_time = validated_data.get(&quot;pub_time&quot;, instance.pub_time) instance.publisher_id = validated_data.get(&quot;publisher_id&quot;, instance.publisher_id) if validated_data.get(&quot;users&quot;): instance.user.set(validated_data.get(&quot;users&quot;)) instance.save() return instance PATCH请求views.py class BookView(APIView): def patch(self, request): print(request.data) book_id = request.data[&quot;id&quot;] book_info = request.data[&quot;book_info&quot;] book_obj = Book.objects.filter(pk=book_id).first() serializer = BookSerializer(book_obj, data=book_info, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 验证如果需要对一些字段进行自定义的验证—DRF也给我们提供了钩子方法 单个字段的验证 局部钩子class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) # 省略了一些字段 跟上面代码里一样的 # 。。。。。 def validate_title(self, value): if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&quot;标题必须含有Python&quot;) return value 多个字段的验证 全局钩子class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() date_added = serializers.DateField(write_only=True) # 新增了一个上架时间字段 # 省略一些字段。。都是在原基础代码上增加的 # 。。。。。。 # 对多个字段进行验证 要求上架日期不能早于出版日期 上架日期要大 def validate(self, attrs): if attrs[&quot;pub_time&quot;] &gt; attrs[&quot;date_added&quot;]: raise serializers.ValidationError(&quot;上架日期不能早于出版日期&quot;) return attrs 验证器 validatorsdef my_validate(value): if &quot;敏感词汇&quot; in value.lower: raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32, validators=[my_validate]) # 。。。。。。 ModelSerializer已经清楚了Serializer的用法，会发现我们所有的序列化跟我们的模型都紧密相关~ 那么，DRF也给我们提供了跟模型紧密相关的序列化器~~ModelSerializer~~ -- 它会根据模型自动生成一组字段 -- 它简单的默认实现了.update()以及.create()方法 定义一个ModelSerializer序列化器定义ModelSerializer class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 外键关系的序列化注意：当序列化类MATE中定义了depth时，这个序列化类中引用字段（外键）则自动变为只读 外键关系序列化 class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 # depth 代表找嵌套关系的第几层 自定义字段我们可以声明一些字段来覆盖默认字段，来进行自定制~ 比如我们的选择字段，默认显示的是选择的key，我们要给用户展示的是value。 自定义字段 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 Meta中其它关键字参数Meta中参数 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} post以及patch请求由于depth会让我们外键变成只读，所以我们再定义一个序列化的类，其实只要去掉depth就可以了~~ post/patch请求序列化类 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} SerializerMethodField外键关联的对象有很多字段我们是用不到的~都传给前端会有数据冗余~就需要我们自己去定制序列化外键对象的哪些字段~~ SerializerMethodField class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) user = serializers.SerializerMethodField() publisher = serializers.SerializerMethodField() # get_是重写字段的钩子方法 def get_user(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publisher(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} 用ModelSerializer改进上面Serializer的完整版ModelSerializer class BookSerializer(serializers.ModelSerializer): dis_chapter = serializers.SerializerMethodField(read_only=True) users = serializers.SerializerMethodField(read_only=True) publishers = serializers.SerializerMethodField(read_only=True) def get_users(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publishers(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} def get_dis_chapter(self, obj): return obj.get_chapter_display() class Meta: model = Book # fields = &quot;__all__&quot; # 字段是有序的 fields = [&quot;id&quot;, &quot;title&quot;,&quot;dis_chapter&quot;, &quot;pub_time&quot;, &quot;publishers&quot;, &quot;users&quot;,&quot;chapter&quot;, &quot;user&quot;, &quot;publisher&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;, &quot;dis_chapter&quot;, &quot;users&quot;, &quot;publishers&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}, &quot;user&quot;: {&quot;write_only&quot;: True}, &quot;publisher&quot;: {&quot;write_only&quot;: True}, &quot;chapter&quot;: {&quot;write_only&quot;: True}} 总结models.pyclass Book(models.Model): title = models.CharField(max_length=32) CHOICE = ((1, &quot;python&quot;), (2, &quot;Linux&quot;), (3, &apos;Go&apos;)) category = models.IntegerField(choices=CHOICE) pub_time = models.DateField() publisher = models.ForeignKey(to=&apos;Publisher&apos;) authors = models.ManyToManyField(to=&quot;Author&quot;) class Publisher(models.Model): title = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) 同一个views.pyfrom demo import models from rest_framework.views import APIView from rest_framework.response import Response from serdemo import serializers # 展示增加全部数据 class BookView(APIView): def get(self, request): book_queryset = models.Book.objects.all() # many=True代表可以序列化多个数据 ser_obj = serializers.BookSerializer(book_queryset, many=True) return Response(ser_obj.data) def post(self, request): # 确定数据类型已经数据结构 # 对妹子传来的数据进行校验 book_obj = request.data ser_obj = serializers.BookSerializer(data=book_obj) if ser_obj.is_valid(): ser_obj.save() # 校验通过的数据 return Response(ser_obj.validated_data) return Response(ser_obj.errors) # 展示和编辑某条数据 class BookEditView(APIView): def get(self, request, id): book_obj = models.Book.objects.filter(id=id).first() ser_obj = serializers.BookSerializer(book_obj) return Response(ser_obj.data) def put(self, request, id): book_obj = models.Book.objects.filter(id=id).first() # partial=True 代表的是可以改部分数据 ser_obj = serializers.BookSerializer(instance=book_obj, data=request.data, partial=True) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors) 普通版Serializerfrom rest_framework import serializers from demo import models class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32) # 自定义校验 def my_validate(value): if &quot;敏感词汇&quot; in value.lower(): raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.Serializer): # required=False 反序列化的时候可以没有,只序列化用不走校验 id = serializers.IntegerField(required=False) title = serializers.CharField(max_length=32, validators=[my_validate]) pub_time = serializers.DateField() # read_only=True 序列化用，反序列化的时候不要了 category = serializers.CharField(source=&quot;get_category_display&quot;, read_only=True) # write_only=True 反序列化 的时候用 post_category = serializers.IntegerField(write_only=True) publisher = PublisherSerializer(read_only=True) authors = AuthorSerializer(many=True, read_only=True) publisher_id = serializers.IntegerField(write_only=True) author_list = serializers.ListField(write_only=True) # 重写create方法 创建新数据的时候 validated_data就是传来的数据 def create(self, validated_data): # validated_data 校验通过的数据 就是book_obj # 同ORM操作给Book表新增数据 book_obj = models.Book.objects.create( title=validated_data[&apos;title&apos;], pub_time=validated_data[&apos;pub_time&apos;], category=validated_data[&apos;post_category&apos;], publisher_id=validated_data[&apos;publisher_id&apos;] ) book_obj.authors.add(*validated_data[&apos;author_list&apos;]) return book_obj # 重写update方法 更新数据的时候 def update(self, instance, validated_data): # instance 更新的book_obj对象 # validated_data 校验通过的数据 # ORM做更新操作 instance.title = validated_data.get(&apos;title&apos;, instance.title) instance.pub_time = validated_data.get(&apos;pub_time&apos;, instance.pub_time) instance.category = validated_data.get(&apos;post_category&apos;, instance.category) instance.publisher_id = validated_data.get(&apos;publisher_id&apos;, instance.publisher_id) if validated_data.get(&apos;author_list&apos;): instance.authors.set(validated_data[&apos;author_list&apos;]) instance.save() return instance # 局部钩子校验 单个字段 数据校验 def validate_title(self, value): # value 就是title 的值 对value处理 if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&apos;标题必须包含python&apos;) return value # 全局钩子校验 全部字段 数据校验 def validate(self, attrs): # attr 字典有你传过来的所有的字段 if &quot;python&quot; in attrs[&quot;title&quot;].lower(): return attrs else: raise serializers.ValidationError(&quot;分类或标题不合符要求&quot;) 升级版ModelSerializerfrom rest_framework import serializers from demo import models class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32) # 自定义校验 def my_validate(value): if &quot;敏感词汇&quot; in value.lower(): raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.ModelSerializer): # 重写正序 category_info = serializers.SerializerMethodField(read_only=True) publisher_info = serializers.SerializerMethodField(read_only=True) authors_info = serializers.SerializerMethodField(read_only=True) def get_category_info(self, obj): # obj 就是序列化的每一个Book对象 return obj.get_category_display() def get_publisher_info(self, obj): # obj 就是序列化的每一个Book对象 publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} def get_authors_info(self, obj): # obj 就是序列化的每一个Book对象 author_qureryset = obj.authors.all() return [{&quot;id&quot;: author_obj.pk, &quot;name&quot;: author_obj.name} for author_obj in author_qureryset] class Meta: model = models.Book fields = &quot;__all__&quot; # exclude=[&quot;id&quot;] # 会让所有的外键关系变成只读read_only=True # depth = 1 # 向下找几层 # 反序列化的时候不用自己定义的，而是还是用原来的字段 extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate]}, &quot;publisher&quot;: {&quot;write_only&quot;: True}, &quot;authors&quot;: {&quot;write_only&quot;: True}, &quot;category&quot;: {&quot;write_only&quot;: True}} # 验证 # 局部钩子校验 单个字段 def validate_title(self, value): # value 就是title 的值 对value处理 if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&apos;标题必须包含python&apos;) return value # 全局钩子校验 全部字段 def validate(self, attrs): # attr 字典有你传过来的所有的字段 if &quot;python&quot; in attrs[&quot;title&quot;].lower(): return attrs else: raise serializers.ValidationError(&quot;分类或标题不合符要求&quot;)]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令]]></title>
    <url>%2F2018%2F11%2F14%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看 conda 版本号conda -Vconda –version 环境管理 查看当前有哪些环境 conda env list 或conda info -e 实际执行命令示例:➜ ~ conda env list conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 ➜ ~ conda info -e conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 查看环境管理的命令帮助 conda env -h 创建环境 conda create –name your_env_name 创建指定 python 版本的环境 conda create –name your_env_name python=2.7conda create –name your_env_name python=3.6 创建包含某些包的环境 conda create –name your_env_name numpy scrapy 创建指定版本下包含某些包的环境 conda create –name your_env_name python=3.6 numpy scrapy 激活某个环境 source activate target_env_name 关闭激活的环境 source deactivate target_env_name 复制某个环境 conda create –name new_env_name –clone old_env_name 删除某个环境 conda remove –name target_env_name –all 包管理 列举当前活跃环境下的所有包 conda list 列举一个指定环境下的所有包 conda list -n your_env_name 为激活环境安装某个包 conda install package_name 为指定环境安装某个包 conda install –name target_env_name package_name 更新当前环境某个包 conda update package_name 更新指定环境某个包 conda update -n target_env_name package_name 删除当前环境某个包 conda remove package_name注意: 如果是通过pip安装的包,移除时也请使用 pip uninstall package_name 命令移除,如果使用 conda remove 可能会发生异常,导致conda不可用 删除指定环境某个包 conda remove -n target_env_name package_name 搜索某个包信息 conda search package_name 更新anaconda conda update anaconda 更新python至最新版本 conda update python 更新所有包 conda update –all 分享环境把自己的环境分享给别人,方便他人快速建立与你一模一样的环境(同一个版本的python及各种包). 一个分享环境快速的方法就是给他人一个你要分享环境的.yml文件步骤:1) 生成欲分享环境的yml文件 conda env export &gt; environment.yml 2) 他人在自己本地使用yml文件创建文件 conda env create -f environment.yml 参考博客: https://blog.csdn.net/menc15/article/details/71477949/]]></content>
      <categories>
        <category>conda</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RESTful规范]]></title>
    <url>%2F2018%2F11%2F14%2FRESTful%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[web服务交互 我们在浏览器中能看到的每个网站，都是一个web服务。那么我们在提供每个web服务的时候， 都需要前后端交互，前后端交互就一定有一些实现方案，我们通常叫web服务交互方案。 目前主流的三种web服务交互方案： -- REST （ Representational State Transfer）表述性状态转移 -- SOAP （Simple Object Access Protocol） 简单的对象访问协议 -- XML-RPC （XML Remote Procedure Call）基于XML的远程过程调用 XML-RPC是通过XML将调用函数封装，并使用HTTP协议作为传送机制。 后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协定。 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。 SOAP也是基于XML的，但是它不只限于HTTP协议的传输，包括TCP协议，UDP协议都可以传输。 REST是Roy Thomas Fielding博士于2000年在他的博士论文里提出来的。 REST相比SOAP更加简洁，性能和开发效率也有突出的优势。 我们今天主要说一下这个REST，现在越来越多的web服务开始采用REST风格设计和实现。 例如，amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 我们接下来要学的框架也是遵循REST风格的，那么我们来看下它到底是个什么样的风格， 了解了它是什么后，我们看下它的优点是什么，我们为什么用它。 REST风格表述性状态转移 资源 网页中能看到的都是资源 URL 统一资源定位符  URI 统一资源标识符 统一资源接口 对资源的操作根据HTTP请求方式的不同来进行不同的操作 遵循HTTP请求方式的语义 前后端传输的是资源的表述 展现的是资源的状态 通过超链接的指引来告诉用户接下来有哪些资源状态可以进入 凡是遵循TEST风格实现的前后端交互都叫RESTful架构核心思想面向资源去编程 url中尽量名词不要动词 根据HTTP请求方式的不同对资源进行不同的操作 在url中体现的体现版本 https://v3.bootcss.com/ https://.bootcss.com/v3 体现是否是API https://v3.bootcss.com/api 有过滤条件 https://v3.bootcss.com/course?page=1 尽量用https 在返回值中携带状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 返回值 get 返回查看的所有或者单条数据 post 返回新增的这条数据 put/patch 返回更新的这条数据 delete 返回值空 携带错误信息 携带超链接 在不分离的项目用的多 ret = { code: 1000, data:{ id:1, name:&apos;小强&apos;, depart_id:http://www.luffycity.com/api/v1/depart/8/ } }]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vuex+axios]]></title>
    <url>%2F2018%2F11%2F13%2FVuex-axios%2F</url>
    <content type="text"><![CDATA[Vuex 简介vuex是一个专门为Vue.js设计的集中式状态管理架构。 状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。 Vuex和单纯的全局对象有以下不同： 1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候， 若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。 2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的 提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化， 从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。 安装使用vuex– npm install vuex vuex的使用一 // main.js import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import vuex from &apos;vuex&apos; Vue.use(vuex) Vue.config.productionTip = false const store = new vuex.Store({ state: { show: false, } }); new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); vuex的使用二 // 为了方便维护，我们通常把在src下面新建一个store文件夹， // 然后在里面新建一个index.js import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { show: false, }, }); // 那么main.js要改成 import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; Vue.config.productionTip = false; new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); State简而言之~~state是保存我们data中需要共享的数据。 由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。 this.$store.state.count 组件中获取vuex中状态 // 创建一个组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count(){ return this.$store.state.count } } }; Getter有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。 并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。 我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被 缓存起来，只有它的依赖发生改变时，才会重新计算。 Getter会接收state作为其第一个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 } }, }); Getter也可以接收getters为第二个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 }, // 通过 this.$store.getters.my_func_count my_func_count: function (state, getters) { return getters.my_func.length } }, }); Mutatiion更改Vuex中的store中的状态的唯一方法是提交mutation。 每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。 也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。 这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数： Mutation基本使用 import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 需要通过 this.$store.commit(&apos;increment&apos;, 10) mutations: { increment (state, n) { // 变更状态 state.count += n } } }); Mutation需要遵守Vue的响应规则 既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。 这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项： – 1，最好提前在你的store中初始化好所有的所需要的属性 – 2，当对象需要添加属性时，你应该使用 – Vue.set(obj, ‘newProp’, 123) – 以新对象代替老对象 state.obj = { …state.obj, newProp: 123} axios的简单使用基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。 ## 使用npm安装axios – npm install axios -D 基本的配置// main.js import axios from &quot;axios&quot; Vue.prototype.$axios = axios // 组件中 methods: { init () { this.$axios({ method: &quot;get&quot;, url: &quot;/user&quot; }) }, }; 基本的使用get请求 test(){ this.$axios.get(this.$store.state.apiList.course,{ params: { id: 123, } }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } post请求 test(){ this.$axios.post(this.$store.state.apiList.course,{ course_title: &quot;Python&quot;, course_price: &quot;19.88&quot; }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } 发送多个并发请求 function getCourse(){ return this.$axios.get(&apos;/course/12&apos;) } function getCourse_all() { return this.$axios.get(&apos;/course&apos;) } this.$axios.all([getCourse_all(),getCourse()]) .then().catch() axios.request methods: { init(){ var that = this this.$axios.request({ url: that.$store.state.apiList.course, method: &apos;get&apos; }).then(function (data) { if (data.status === 200){ that.courseList = data.data } }).catch(function (reason) { console.log(reason) }) } },]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm+webpack+vue-cli快速上手]]></title>
    <url>%2F2018%2F11%2F13%2Fnpm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Node.js npm什么是Node.js 以及npm简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。 npm 是Node.js 的包管理工具。 npm的安装和更新Node.js下载安装 Node.js 官网下载安装。npm自带的包管理工具。 查看安装版本信息： – node -v 查看Node.js 版本信息 – npm -v 查看npm版本信息 更新npm到指定版本： – npm install npm@5.3.0 -g – npm install npm@latest -g 更新最新的稳定版本 npm 常用操作之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。 有了npm，我们管理自己的依赖包以及版本更加简单。 到自己项目目录下，进行以下命令： – npm init -y 输入-y使用默认配置项 生成package.json文件。 – npm i jquery@0.0.0 简写install 为 i 下载依赖 不写@ 默认最新版本 – npm uninstall jquery 卸载依赖包 – npm update jquery 更新依赖包 – npm list 列出已安装的依赖 – npm install webpack –D 保存为开发环境依赖 – 老版本需要 –save 参数 现在不需要了 我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。 我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。 如果我们删掉 node_modules目录，可以使用 npm i 来下载所有依赖。 npm 常用配置项当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。 在我们的package.json文件中有很多配置项 – name 项目名字 中间不能有空格只能用小写 – version 项目版本 – description 项目描述信息 – main 项目的入口文件 – scripts 指定命令的快捷方式 npm run test test是scripts里的键名 值为具体命令 – author 作者 – license 许可证 – dependencies 生成环境依赖的包以及版本信息 – devDependencies 开发环境的依赖 webpack3webpack是什么webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析， 然后将这些模块按照指定的规则生成静态资源。 那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113##安装和配置 webpack是跑在Node.js环境下的，所以确定自己有node环境。安装方式： -- npm install webpack -g 全局安装 -- webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 全局这种方式进行打包 -- npm install webpack 在自己的项目下 npm init 后在下载webpack 这就是局部安装 -- node_modules/.bin/webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 项目里要打包文件是入口文件 -- 路径太长 太烦 可以自定义命令 在package.json 文件的 scripts下面自定义## entry 和 output entry 入口文件 output 出口文件 上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~ 我们可以把命令写在webpack.config.js文件中~~&gt;webpack.config.jsmodule.export = &#123; // 所有的入口文件 entry: &#123; home: &apos;./main.js&apos;, login: &apos;./login.js&apos;, &#125;, // 出口文件 output: &#123; filename: &apos;[name].bundle.js&apos;, path: __dirname + &apos;/dist&apos;, &#125; &#125;// backage.json 下的scriptsscripts: &#123; &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;&#125;// 运行命令npm run pack# webpack4## webpack的新特性1, webpack不在单独使用，需要webpack-cli -- 全局安装 npm install webpack webpack-cli -g -D -- 局部安装 npm install webpack webpack-cli -D2, 增加了模式区分 （development, production） --webpack --mode development/production 进行模式切换 -- development 开发者模式 打包默认不压缩代码 -- production 生产者模式 上线时使用，压缩代码。 默认是这个模式3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下 -- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js4，多入口以及多出口&gt;webpack.config.js entry: &#123; // 多入口 a: &quot;./src/js/index.js&quot;, b: &quot;./src/js/index2.js&quot;,&#125;output: &#123; // 多出口 path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;./js/[name].bundle.js&apos;&#125;# vue-clivue-cli是官方提供的快速构建这个单页面应用的脚手架。## 根据官方文档中的构件流程： -- 前提是已经安装了node.js 否则npm都用不了 -- 1，使用npm全局安装vue-cli npm install -g vue-cli -- 2, 安装完成后在自己的工作空间里 vue init webpack vue-demo 输入命令后进入安装阶段，需要用户输入一些信息 这里省略了..... -- 3，切换到我们的项目目录下 cd vue-demo npm run dev## 目录结构： -- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件 -- config 配置文件，执行文件需要的配置信息 -- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下 -- node_modules 项目依赖包 -- static 静态资源 -- package.json 依赖包的json文件其实这里面命令很多~我们在后续项目中应用到再说 vue-cli配置JQuery、bootstrap第一步 下载安装 – npm install jquery – npm install bootstrap 第二步 修改build/webpack.base.conf.js const webpack = require(‘webpack’)// 在module.exports里添加插件plugins: [ new webpack.ProvidePlugin({ $: “jquery”, jQuery: “jquery”, “windows.jQuery”: “jquery”, // Popper: [‘popper.js’, ‘default’] })],// ***下面是如果手动下载bootstrap用的***resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘vue$’: ‘vue/dist/vue.esm.js’, ‘@’: resolve(‘src’), // 如果是手动下载的bootstrap需要添加这个配置 // ‘assets’: path.resolve(__dirname, ‘../src/assets’), // ‘jquery’: ‘jquery/src/jquery’ } }, 修改配置文件 第三步 修改主程序的js文件 main.js import $ from ‘jquery’import ‘bootstrap/dist/css/bootstrap.min.css’import ‘bootstrap/dist/js/bootstrap.min.js’ vue-cli 3.0第一步 下载vue-cli 3.0 – npm install -g @vue/cli – 报错 npm error 可以运行下面命令 – npm cache clean –force &amp;&amp; npm cache verify 第二步 创建项目 – vue create xxxx 之后会出现很多选项，我们可以根据自己的习惯去选择~~ 第三步 目录结构以及配置文件 – vue-cli3 目录更加简单 – 我们手动在项目根目录下创建 vue.config.js 里面写vue的配置信息 vue-cli3 配置jQuery、bootstrap – 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git上]]></title>
    <url>%2F2018%2F11%2F13%2Fgit%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[目录： 建立本地版本库 本地版本库与远程关联 修改文件并提交 创建分支,修改文件合并至master git的由来linux系统是很多开发者贡献代码不断完善的,linux的创始人linus起初管理贡献者的代码,是通过手工的方式,但随着代码的增多,很难通过手工方式去管理,于是找了一个商业的版本控制系统BitKeeper管理代码. 开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ 集中式与分布式区别- 集中式： cvs, svn 版本库集中放在中央服务器上,所有人干活时,都要先从中央服务器获取最新版本到本地,然后在本地修改,干完活后,将修改推送到中央服务器. **必须联网**才能工作. - 分布式 每个人的电脑都是一个版本库,工作的时候 **不需要联网**,直接在本地修改,提交就可以.你和同事同时修改一个文件A,修改完成后互相将自己修改的文件推送给对方即可. **安全性高**, 每个人的本地都有一个完整的版本库,某个人的电脑突然崩溃,从其他人那直接copy一份就可以了. 但集中式版本控制系统,一旦中央服务器垮掉,版本库信息就都丢失了. 创建版本库,添加文件命令: - 创建版本库 mkdir studyGit git init - 添加文件 vim readme.txt git add readme.txt git commit -m &quot;注释说明,方便自己或他人查看&quot; 修改文件并提交命令: - vim 编辑修改文件内容 - git status 查看当前仓库状态 - git diff filename 查看文件具体改动内容 - 提交: git add filename git commit -m &quot;本次提交注释说明&quot; 版本回退Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向至你切换的版本. 命令: - 回退到上一个版本 git reset --hard HEAD^ - 回退到上上版本 git reset --hard HEAD^^ - 回退到指定版本 git log 查看你要切换版本的commit id 或 git log --pretty=oneline git reset --hard target_commit_id - 回退之后后悔了,想切换到回退前的版本 1) 通过git log是找不到回退前那次提交的日志的,没办法指定commit id回退切换 2) 通过git reflog查看, git reflog是记录我们的历史命令的,找到你那次提交历史命令前的commit id,即可切换回去 工作区和暂存区工作区: 电脑上直接看到的,你管理的文件夹(使用git init创建的),就是工作区 暂存区: 在工作区下,隐藏的.git文件夹,其中有很多文件,有几个重要的要理解: - 暂存区: stage - 版本信息(master分支) - HEAD指针,指向具体分支 提交工作区的文件修改或新增文件: 1) git add files -&gt; 实际将这些修改先推送到本地暂存区(暂存区中存放了所有待提交的文件) 2) git commit -m &quot;说明&quot; -&gt; 提交暂存区中的所有文件至master或分支版本 管理修改工作区中readme.txt文件 1) 第一次修改, 增加一行内容, git add readme.txt 2) 第二次修改, 又增加了一行内容, 但未执行 git add readme.txt 3) git commit -m &quot;注释&quot;; 那么此次提交的只是第一次修改的内容 git diff HEAD -- readme.txt 查看工作区中与版本库中的不同之处 撤销修改1) 工作区修改,改乱了,还没有提交至暂存区; 可以通过 git checkout -- filename 恢复至与版本库一致的状态 2) 工作区修改,改乱了,但之前已提交至暂存区,撤销修改: git reset HEAD filename 把暂存区的修改撤销掉(unstage) git checkout -- filename 恢复工作区与版本库一致 删除文件git rm filename git commit -m &quot;delete file filename&quot; 远程仓库关联1) 创建ssh key: ssh-keygen -t rsa -C &quot;youremail@example.com&quot; # 一路回车即可 在用户主目录里会生成一个.ssh文件夹,里面有id_rsa和id_rsa.pub, id_rsa是私钥, id_rsa.pub是公钥; 登录github,进入个人账户settings页面,选择ssh key -&gt; add new; 添加, 将id_rsa.pub复制到页面中,完成. 2) 添加远程仓库 - 在github网站新增仓库,与本地要关联的仓库同名 - 进入本地仓库所在的目录, git remote add origin &lt;新增的远程仓库地址&gt; - git push -u origin master # 将本地仓库的master分支推送到远程服务器上,后续提交可以省略参数-u(远程初始仓库为空,所以加-u) - 本地修改文件,提交; 推送至远程 克隆远程仓库进入你想保存仓库的路径,然后执行: git clone &lt;远程仓库地址&gt; 创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突1) 在分支上修改了文件,并commit 2) 在mster上修改了文件,并commit 3) git merge &lt;ranchname&gt;; 报错, 无法实现快速合并, 需先解决冲突, 把冲突文件改成自己想要的内容, 然后 git add filename, git commit -m &quot;注释&quot;.]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue总结]]></title>
    <url>%2F2018%2F11%2F13%2FVue%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue总结 MVC Model View Controller MVVM Model View ViweMode ES6常用语法1.1 变量的提升 1.2 模板字符串 ``${} 1.3 数据的解构 1.4 类 class extends constructor super 1.5 函数 1.5.1 注意this和普通函数的区别 1.6 箭头函数 1.7 单体模式 1.8 import export export default Vue常用指令2.1 v-text innerText 2.2 v-html innerHtml 2.3 v-for :key 2.4 v-if v-else-if v-else appendChild 2.5 v-show display 2.6 v-on @xxxx=&quot;自己处理的方法&quot; 2.7 v-bind :属性名称=“属性的值” 2.8 v-model 2.8.1 input 2.8.2 textarea 2.8.3 select 2.9 指令修饰符 2.9.1 .lazy 2.9.2 .number 2.9.3 .trim 2.10 计算属性 2.10.1 放入缓存 2.10.2 只有数据改变的时候才会重新计算 2.11 数据监听 2.11.1 注意可变类型和不可变 2.11.2 深监听 deep=true 2.12 获取DOM 2.12.1 给便签绑定ref属性 ref=“属性值” 2.12.2 this.$refs.属性值 2.13 自定义指令 2.13.1 vue.directive(“指令名称”, function(el, binding){ el 绑定指令的便签元素 binding 指令的所有信息 }) 注意事项3.1 数据监听 3.1.1 改变数据 直接赋值 3.1.2 改变数组长度 能够被监听到，新值和旧值一样 3.1.3 改变数组内的值 app = new vue({}) app.$set(this.hobby, 0, &apos;抽烟&apos;) $set()修改数组中的值可以监听 $delete() Vue的组件组件的注册全局注册Vue.compontent(“组件名称”, {}) 局部注册const = app = new Vue({ el: &apos;#app&apos;, components: { 组件的名称: 组件的配置信息 } }) 子组件的注册在父组件中注册components ## 注意写组件标签 ## 每个组件的template只识别一个作用域块 通信父子的通信在父组件中给子组件绑定属性 子组件通过props=[&quot;属性名称&quot;] 子父的通信子组件先提交事件 this.$emit(&quot;事件名称&quot;, 值) 在父组件中给子组件绑定事件 &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt; 非父子的通信其中一个组件向中间调度器提交事件 另一个组件监听中间调度器的事件 注意this的问题 中间调度器 let temp = new Vue(); temp.$emit(&quot;say&quot;, value) // 事件名称和值 mounted(){ that = this // 监听中间调度器中的方法 temp.$on(&quot;say&quot;, function(data){ // 这里的this是temp的this that.xxx = data // 这样改值 }) } 插槽&lt;slot&gt;&lt;/slot&gt; 命名的插槽 混合代码重用的 mixins = [base] Vue的生命周期vue生命周期之beforeCreate实例创建之前除标签外，所有的vue需要的数据，事件都不存在 vue生命周期之created实例创建之后，data和事件已经被解析到，el还没有找到 vue生命周期之beforeMount开始找标签，数据还没有被渲染，事件也没有被监听 vue生命周期之mounted开始渲染数据，开始监听事件 vue生命周期之beforeUpdata数据已经被修改在虚拟DOM，但没有被渲染到页面上 vue生命周期之updata开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改 vue生命周期之beforeDestory所有的数据都存在 vue生命周期之destoryed所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了 &lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签 用activated和deactivated取代了beforeUpdate和destory的执行 最常用的钩子beforeMount mounted 路由注册let url = [ { path: &apos;/&apos;, name: &quot;home&quot;, component: { template: ``, } } ] let router = nwe VueRouter({ routes: url }) const app = new Vue({ el: &apos;app&apos;, router: router, }) &lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt; &lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 子路由children: [ {} ] append 在父路由对应的组件的template里面写router-link router-view 路由的命名name 注意to加冒号动态绑定 路由的参数{ path: &quot;/course/:id&quot;, } this.$route.params.id this.$route.query.xxx $route 是一个对象 存放当前路由的所有信息 $router VueRouter实例化对象 手动路由this.$router.push(&apos;/&apos;) this.$router.push({name:&quot;home&quot;}) 重定向redirect: {name: &apos;xxx&apos;, params: {key: value}} 路由的钩子router.beforeEach(function(to, from next){ // to 你要去哪 // from 你要从哪里来 // next() 你要去做什么 参数可以给路径 必须有，没有就不走 }) router.afterEach(function(to, from){ // to 你要去哪 // from 你从哪里来 }) to和from都是$route对象 路由的所有信息  node.js + npm + webpack + vue-cli(自带webpack)node.js / npm - npm 管理工作目录 npm init -y - 下载包 npm i xxx@0.0.0 - 卸载 npm uninstall xxx - 更新 npm updata xxx webpack 4 - 下载 npm i webpack webpack-cli - 打包 webpack --mode development/production - 打包默认的入口文件 src目录下的index.js - 出口文件 dist目录的main.js wue-cli 2 - 帮助我们快速搭建项目的脚手架工具 - 下载 npm i vue-cli - 用vue-cli帮助我们创建项目 vue init webpack xxxx(项目名称) - 启动项目 cd xxxx(项目名称) npm run dev - 打吧包 npm run build Vuex和axiosVuex存放一些公共的东西,是一个仓库 安装 npm i vuex 配置 导入 import vuex from &quot;vuex&quot; vue使用vuex vue.use(vuex) 实例化仓库 new vuex.Store({ state: {}, getters: {}, mutations: {} }) new Vue({ el: &apos;#app&apos;, store, }) 获取残仓库数据 this.$store.state.xxx this.$store.getters.xxx 改变仓库中的数据 组件向仓库提交修改事件 this.$store.commit(&quot;事件名称&quot;, data) 在仓库中的mutations中 mutations: { &quot;事件名称&quot;: function(state, data){ 修改state中的数据 } } 注意计算属性 仓库中的数据建议都放在计算属性中 axios向后端服务器发送请求 实现ajax技术的工具 配置 下载 npm i axios 导入 import axios from “axios” 在vue的原型链中加入方法 Vue.prototype.#axios = axios 发送请求 this.$axios.request({ url: &apos;&apos;, method: &apos;&apos;, }).then(function(){ }).catch(function(){ }) 前后端的接通后端设计一个接口 前端通过axios发送请求拿到数据 跨域问题 element-ui按照文档安装，并研究如何使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue组件系统]]></title>
    <url>%2F2018%2F10%2F14%2Fvue%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Vue组件系统之全局组件的注册 123456789101112131415161718192021222324252627&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; // template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&lt;/script&gt;&gt; 12345678910111213141516171819202122232425262728&gt;&lt;div id='app'&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册组件&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素，包在app这个div中&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; // 根元素会替换div&gt; template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&lt;/script&gt;&gt; 全局组件 12345678910111213141516171819202122232425262728&gt;// 总结&gt;Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素，包在app这个div中&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;,&gt; computed: &#123;&#125;,&gt; watch: &#123;&#125;,&gt; methods: &#123;&#125;,&gt; &#125;&gt; &#125;&gt; );&gt;&gt;new Vue(&#123;&gt; el: '#app',&gt; // 根元素会替换div&gt; template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&gt;// data 必须是函数&gt;// 没有属性&gt; 组件系统之组件的复用 1234567891011121314151617181920212223242526272829&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &gt; &#125;)&gt;&lt;/script&gt;&gt; 组价系统之局部组件的注册 12345678910111213141516171819202122232425&gt;&lt;div id='app'&gt;&gt; &lt;app-header&gt;&lt;/app-header&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; &#125;;&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; template: `&lt;app-header&gt;&lt;/app-header&gt;`,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&lt;div id='app'&gt;&gt; &lt;!--&lt;App&gt;&lt;/App&gt;--&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 在入口组件中注册写的局部组件&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;app-header&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&#125;,&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; 局部组件 1234567891011121314151617181920212223242526&gt;- 总结&gt;&gt;创建组件&gt; 创建局部组件，起始就是创建一个JavaScript object&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; &#125;;&gt;注册组件&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; template: `&lt;app-header&gt;&lt;/app-header&gt;`,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;&gt; &#125;)&gt;&gt;组件可以嵌套使用&gt;&gt; Vue组件系统之父子组件的通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;&lt;div id='app'&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 子&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;h3&gt;&#123;&#123; fData &#125;&#125;&lt;/h3&gt;&lt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; // 接收父亲传来的数据&gt; props:['fData'],&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 在入口组件中注册写的局部组件&gt; // 父&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;app-header v-bind:fData="fatherData"&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&gt; return &#123;fatherData: 0,&#125;&gt; &#125;,&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; Vue组件系统之子父组件的通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&gt;&lt;div id='app'&gt;&gt;&lt;/dic&gt;&gt;&gt;&lt;script&gt;&gt; // 子&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='sonClick'&gt;点击改变字体大小&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; methods: &#123;&gt; sonClick: function()&#123;&gt; // 儿子的的行为传给父亲&gt; this.$emit("change-size", 0.1)&gt; &#125; &gt; &#125;,&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 父&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;span :style="&#123; fontSize: postFontSize + 'em' &#125;"&gt;我是字体&lt;/span&gt;&gt; &lt;app-header v-on:change-size="fatherClick"&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&gt; return &#123;&gt; postFontSize: 1,&gt; &#125;&gt; &#125;,&gt; methods: &#123;&gt; // 自己定义的change-size事件，一直在监听，等着儿子传来的信息&gt; fatherClick: function(value)&#123;&gt; this.postFontSize += value;&gt; &#125;&gt; &#125;&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; Vue组件系统之混入（mixin） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&lt;div id='app'&gt;&gt;&lt;/dic&gt;&gt; &lt;my-header&gt;&lt;/my-header&gt;&gt; &lt;p&gt;&lt;/p&gt;&gt; &lt;my-app&gt;&lt;/my-app&gt;&gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='show('xxx')'&gt;点击显示xxx来了&lt;/button&gt;&gt; &lt;button @click='hide('xxx')'&gt;点击显示xxx去了&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; methods: &#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;,&gt; &#125;;&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;button @mouseenter='show('000')'&gt;点击显示000来了&lt;/button&gt;&gt; &lt;button @mouseleve='hide('000')'&gt;点击显示000去了&lt;/button&gt;&gt; &lt;/div&gt;&gt; `,&gt; methods: &#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; components: &#123;&gt; "my-header": Header,&gt; "my-app": App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&lt;div id='app'&gt;&gt; &lt;my-header&gt;&lt;/my-header&gt;&gt; &lt;p&gt;&lt;/p&gt;&gt; &lt;my-app&gt;&lt;/my-app&gt;&gt;&lt;/dic&gt;&gt;&gt;&lt;script&gt;&gt; let mixs = &#123;&gt; methods:&#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;&gt; &#125;&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='show('xxx')'&gt;点击显示xxx来了&lt;/button&gt;&gt; &lt;button @click='hide('xxx')'&gt;点击显示xxx去了&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; mixins: [mixs],&gt; &#125;;&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;button @mouseenter='show("000")'&gt;点击显示000来了&lt;/button&gt;&gt; &lt;button @mouseleve='hide("000")'&gt;点击显示000去了&lt;/button&gt;&gt; &lt;/div&gt;&gt; `,&gt; mixins: [mixs],&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; components: &#123;&gt; "my-header": Header,&gt; "my-app": App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; Vue组件系统之插槽 123456789101112131415161718192021222324252627&gt;- 内容分发&gt;&lt;style&gt;&gt; .box &#123;&gt; width: 50px;&gt; height: 50px;&gt; float: left;&gt; &#125;&gt;&lt;/style&gt;&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;首页&lt;/global-component&gt;&gt; &lt;global-component&gt;免费&lt;/global-component&gt;&gt; &lt;global-component&gt;收费&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册全局组件&gt; Vue.component(&gt; "global-component", &#123;&gt; template: `&lt;div class="box"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`,&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &#125;)&gt;&lt;/script&gt;&gt; Vue组件系统之具名插槽 1234567891011121314151617181920212223242526272829303132&gt;&lt;style&gt;&gt; .box &#123;&gt; width: 50px;&gt; height: 50px;&gt; float: left;&gt; &#125;&gt;&lt;/style&gt;&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&gt; &lt;div slot='home'&gt;首页&lt;/div&gt;&gt; &lt;div slot='free'&gt;免费&lt;/div&gt;&gt; &lt;div slot='toll'&gt;收费&lt;/div&gt;&gt; &lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册全局组件&gt; Vue.component(&gt; "global-component", &#123;&gt; template: `&lt;div class="box"&gt;&gt; &lt;slot name="home"&gt;&lt;/slot&gt;&gt; &lt;slot name="free"&gt;&lt;/slot&gt;&gt; &lt;slot name="toll"&gt;&lt;/slot&gt;&gt; &lt;/div&gt;`,&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &#125;)&gt;&lt;/script&gt;&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[权限管理的三级菜单的流程]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[权限管理的三级菜单的流程 权限控制 url代表了权限 表结构（6张表，ORM创建4个类，两个many2many会自动再生成两张表） 1234567891011121314151617181920&gt; 用户表&gt; 用户名&gt; 密码&gt; 多对多 roles(角色)&gt; 角色表&gt; 标题 title&gt; 多对多 permission(权限)&gt; 权限表&gt; 标题 title&gt; 权限 url&gt; URL别名 name - 设置唯一(方便为了将权限粒度控制到按钮级别)&gt; 外键 menu(菜单)&gt; 外键 permission(self自己)&gt; 菜单表&gt; 标题 title&gt; 图标 icon&gt; 权重 weight&gt; 用户和角色关系表&gt; 角色和权限的关系表&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt; &gt;from django.db import models&gt; &gt;&gt; &gt;&gt; &gt;class Menu(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 一级菜单&gt; &gt; &quot;&quot;&quot;&gt; &gt; title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;, unique=True) # 一级菜单的名字&gt; &gt; icon = models.CharField(max_length=32, verbose_name=&apos;图标&apos;, null=True, blank=True)&gt; &gt; weight = models.IntegerField(verbose_name=&apos;权重&apos;, default=1)&gt; &gt;&gt; &gt; class Meta:&gt; &gt; verbose_name_plural = &apos;菜单表&apos;&gt; &gt; verbose_name = &apos;菜单表&apos;&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.title&gt; &gt;&gt; &gt;&gt; &gt;class Permission(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 权限表&gt; &gt; 有关联Menu的二级菜单&gt; &gt; 没有关联Menu的不是二级菜单，是不可以做菜单的权限&gt; &gt; &quot;&quot;&quot;&gt; &gt; title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;)&gt; &gt; url = models.CharField(max_length=32, verbose_name=&apos;权限&apos;)&gt; &gt; menu = models.ForeignKey(&apos;Menu&apos;, null=True, blank=True, verbose_name=&apos;菜单&apos;)&gt; &gt; # 该权限关联的其他权限是否也是在当前url上展示&gt; &gt; parent = models.ForeignKey(to=&apos;Permission&apos;, null=True, blank=True, verbose_name=&apos;父权限&apos;)&gt; &gt;&gt; &gt; name = models.CharField(max_length=32, null=True, blank=True, unique=True, verbose_name=&apos;权限的别名&apos;)&gt; &gt;&gt; &gt; class Meta:&gt; &gt; verbose_name_plural = &apos;权限表&apos;&gt; &gt; verbose_name = &apos;权限表&apos;&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.title&gt; &gt;&gt; &gt;&gt; &gt;class Role(models.Model):&gt; &gt; name = models.CharField(max_length=32, verbose_name=&apos;角色名称&apos;)&gt; &gt; permissions = models.ManyToManyField(to=&apos;Permission&apos;, verbose_name=&apos;角色所拥有的权限&apos;, blank=True)&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.name&gt; &gt;&gt; &gt;&gt; &gt;class User(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 用户表&gt; &gt; &quot;&quot;&quot;&gt; &gt; name = models.CharField(max_length=32, verbose_name=&apos;用户名&apos;)&gt; &gt; password = models.CharField(max_length=32, verbose_name=&apos;密码&apos;)&gt; &gt; roles = models.ManyToManyField(to=&apos;Role&apos;, verbose_name=&apos;用户所拥有的角色&apos;, blank=True)&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.name&gt; &gt;&gt; &gt; 流程梳理 12345678910111213&gt; - 当一个url回车发出这个请求后，给到server端先判断这个请求url是不是有访问的权限&gt; 这个时候我们设置了白名单(在中间件这里(因为一开始就要判断身份))，如果是白名单&gt; 谁都可以访问&gt; eg：&gt; PERMISSION_SESSION_KEY = &apos;permissions&apos;&gt; MENU_SESSION_KEY = &apos;menus&apos;&gt; WHITE_URL_LIST = [&gt; r&apos;^/login/$&apos;,&gt; r&apos;^/logout/$&apos;,&gt; r&apos;^/reg/$&apos;,&gt; r&apos;^/admin/.*&apos;,&gt; ]&gt; 123&gt; - 这时用户登录，如果登录成功&gt; 不同的用户对应不同的权限，也就是可以访问不同的url&gt; 1234567891011121314151617181920212223242526272829303132&gt; - 登录成功，(权限信息的初始化)&gt; 我们该做的就是拿到这个用户对应的权限信息 - ORM(用户信息-角色-权限-菜单)&gt; # user = models.User.objects.filter(name=username, password=pwd).first()&gt; permission_query = user.roles.filter(permissions__url__isnull=False).values(&gt; &apos;permissions__url&apos;, # 权限url&gt; &apos;permissions__title&apos;, # 权限的标题&gt; &apos;permissions__id&apos;, # 权限的id&gt; &apos;permissions__name&apos;, # 权限的别名&gt; &apos;permissions__parent_id&apos;, # 此权限对应的父权限的id&gt; &apos;permissions__parent__name&apos;, # 次权限对应的父权限的别名&gt; &apos;permissions__menu_id&apos;, # 此权限对应的菜单id&gt; &apos;permissions__menu__title&apos;, # 此权限对应的菜单标题&gt; &apos;permissions__menu__icon&apos;, # 此权限对应的菜单的图标&gt; &apos;permissions__menu__weight&apos;, # 表单排序用的&gt; ).distinct()&gt; 数据结构(字典)&gt; permission_dict来存储此权限信息&gt; menu_dict来存储菜单信息&gt; permission_dict = &#123;&gt; &apos;URL的别名&apos;：&#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&apos;pid&apos;,&apos;pname&apos; &#125;&gt; &#125;&gt; menu_list = &#123;&gt; &apos;菜单ID&apos;：&#123;&gt; &apos;title&apos;: 一级菜单的标题，&gt; &apos;icon&apos;: 一级菜单的图标，&gt; &apos;weight&apos;: 权重，&gt; &apos;children&apos;: [&gt; &#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&#125;&gt; ]&gt; &#125;&gt; &#125;&gt; 123456789&gt; 权限信息存的就是：&gt; 当前这个权限的是谁，他的id多少，他的标题是什么，他的父权限是谁(id)，他的父权限的别名是什么&gt; 菜单信息存的就是：&gt; 这个权限(url)对应的菜单的标题是什么，菜单的图标是什么，权重是多少，他对应的二级菜单是哪些&gt; 二级菜单(children)也就是，对应的权限信息&gt; 这里面存的也就是他的权限信息(他的title，url，id，parent_id)&gt; 将所有的权限遍历一遍后，将这些信息存入session中&gt; 为什么存入session，是因为session可以配置(放入缓存，访问次数比较多，所有存到缓存比较好)&gt; 123456789101112131415161718192021222324252627282930313233343536&gt; # 遍历此用户对应的权限信息&gt; for item in permission_query:&gt; # 首先是权限信息，以权限的别名为键&gt; permission_dict[item[&apos;permissions__name&apos;]] = (&#123;&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &apos;parent_name&apos;: item[&apos;permissions__parent__name&apos;],&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &#125;)&gt; menu_id = item.get(&apos;permissions__menu_id&apos;)&gt; if not menu_id:&gt; continue&gt; if menu_id not in menu_dict:&gt; menu_dict[menu_id] = &#123;&gt; &apos;title&apos;: item[&apos;permissions__menu__title&apos;],&gt; &apos;icon&apos;: item[&apos;permissions__menu__icon&apos;],&gt; &apos;weight&apos;: item[&apos;permissions__menu__weight&apos;],&gt; &apos;children&apos;: [&gt; &#123;&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &#125;&gt; ]&gt; &#125;&gt; else:&gt; menu_dict[menu_id][&apos;children&apos;].append(&gt; &#123;&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &#125;)&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; - 登录成功后，信息存入session后，这时给服务器发送一个请求，这时就会走中间件进行权限的校验&gt; &gt; - 走中间件process_request(self, request):&gt; - 先获取这个请求的url request.path_info&gt; 刚开始也先判断白名单， 白名单不符合从session中获取这个用户存的权限信息&gt; permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)&gt; - 导航栏可以存这里 - 写了一个inclution_tag来处理&gt; request.breadcrumd_list = [&gt; &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,&gt; ]&gt; @register.inclusion_tag(&apos;rbac/breadcrumbs.html&apos;)&gt; def breadcrumb(request):&gt; return &#123;&quot;breadcrumd_list&quot;: request.breadcrumd_list&#125;&gt; - 遍历这个权限信息&gt; 可以通过正则匹配，匹配他是不是该用户的权限&gt; 如果匹配成功看他是否由parent_id有是子权限没有是父权限&gt; &gt; if parent_id:&gt; # 表示当前权限是子权限，让父权限是展开&gt; request.current_menu_id = parent_id&gt; request.breadcrumd_list.extend([&gt; &#123;&gt; &quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],&gt; &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]&gt; &#125;,&gt; &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,&gt; ])&gt; else:&gt; # 表示当前权限是父权限，要展开的二级菜单&gt; request.current_menu_id = id&gt; # 添加面包屑导航&gt; request.breadcrumd_list.append(&#123;&gt; &quot;title&quot;: item[&apos;title&apos;], &gt; &apos;url&apos;: item[&apos;url&apos;]&gt; &#125;)&gt; &gt; - request.current_menu_id&gt; 这个就是用来展示菜单和展示该权限的子权限为了选中同一个二级菜单的时候用的&gt; -写一个includtion_tag&gt; - &gt; @register.inclusion_tag(&apos;rbac/menu.html&apos;)&gt; def menu(request):&gt; menu_list = request.session.get(settings.MENU_SESSION_KEY)&gt; order_dict = OrderedDict()&gt; for key in sorted(menu_list, key=lambda x: menu_list[x][&apos;weight&apos;], reverse=True):&gt; order_dict[key] = menu_list[key]&gt; item = order_dict[key]&gt; item[&apos;class&apos;] = &apos;hide&apos;&gt; &gt; for i in item[&apos;children&apos;]:&gt; &gt; if i[&apos;id&apos;] == request.current_menu_id:&gt; i[&apos;class&apos;] = &apos;active&apos;&gt; item[&apos;class&apos;] = &apos;&apos;&gt; return &#123;&quot;menu_list&quot;: order_dict&#125;&gt; &gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; from django.utils.deprecation import MiddlewareMixin&gt; from django.conf import settings&gt; from django.shortcuts import HttpResponse&gt; import re&gt; &gt; &gt; class PermissionMiddleware(MiddlewareMixin):&gt; def process_request(self, request):&gt; # 对权限进行校验&gt; # 1. 当前访问的URL&gt; current_url = request.path_info&gt; &gt; # 白名单的判断&gt; for i in settings.WHITE_URL_LIST:&gt; if re.match(i, current_url):&gt; return&gt; &gt; # 2. 获取当前用户的所有权限信息&gt; &gt; permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)&gt; &gt; request.breadcrumd_list = [&gt; &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,&gt; ]&gt; &gt; # 3. 权限的校验&gt; print(current_url)&gt; &gt; for item in permission_dict.values():&gt; print(permission_dict)&gt; url = item[&apos;url&apos;]&gt; if re.match(&quot;^&#123;&#125;$&quot;.format(url), current_url):&gt; parent_id = item[&apos;parent_id&apos;]&gt; id = item[&apos;id&apos;]&gt; parent_name = item[&apos;parent_name&apos;]&gt; if parent_id:&gt; # 表示当前权限是子权限，让父权限是展开&gt; request.current_menu_id = parent_id&gt; request.breadcrumd_list.extend([&gt; &#123;&quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],&gt; &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]&#125;,&gt; &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,&gt; ])&gt; else:&gt; # 表示当前权限是父权限，要展开的二级菜单&gt; request.current_menu_id = id&gt; # 添加面包屑导航&gt; request.breadcrumd_list.append(&#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;)&gt; return&gt; else:&gt; return HttpResponse(&apos;没有权限&apos;)&gt; &gt; 123456789&gt; - 权限力度控制到按钮级别&gt; 一个filter&gt; 一个url的反向解析&gt; @register.filter&gt; def has_permission(request, permission):&gt; # session中存的就是权限的别名，别名就是反向解析的那个字符串&gt; if permission in request.session.get(settings.PERMISSION_SESSION_KEY):&gt; return True&gt; 12345678910&gt; &#123;% if request|has_permission:&apos;web:customer_edit&apos; or request|has_permission:&apos;web:customer_del&apos; %&#125;&gt; &lt;td&gt;&gt; &#123;% if request|has_permission:&apos;web:customer_edit&apos; %&#125;&gt; &lt;a style=&quot;color: #333333;&quot; href=&quot;&#123;% url &apos;web:customer_edit&apos; row.id %&#125;&quot;&gt;&gt; &lt;i class=&quot;fa fa-edit&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; &#123;% if request|has_permission:&apos;web:customer_del&apos; %&#125;&gt; &lt;a style=&quot;color: #d9534f;&quot; href=&quot;&#123;% url &apos;web:customer_del&apos; row.id %&#125;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot;&gt;&lt;/i&gt;&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; 菜单和权限的展示在一个页面 123456789101112131415161718192021222324252627282930313233343536&gt;# 菜单和权限的展示&gt;# 点击每一个菜单出现对应的权限信息&gt;def menu_list(request):&gt; all_menu = models.Menu.objects.all()&gt; # 拿到菜单对应的菜单id&gt; mid = request.GET.get('mid')&gt; # 如果拿到菜单id代表着有子权限&gt; if mid:&gt; # 从子权限出发 拿到 父权限对应的菜单id对应的权限 或者 菜单对应的权限（也就是二级菜单） 因为自己关联自己（从父亲和儿子两方面出发）&gt; permission_query = models.Permission.objects.filter(Q(menu_id=mid) | Q(parent__menu_id=mid))&gt; # 如果没有菜单id则输出所有的权限信息&gt; else:&gt; permission_query = models.Permission.objects.all()&gt; # 拿到查询出的权限对应的信息&gt; all_permission = permission_query.values('id', 'url', 'title', 'name', 'menu_id', 'parent_id', 'menu__title')&gt; all_permission_dict = &#123;&#125;&gt; for item in all_permission:&gt; menu_id = item.get('menu_id')&gt; # 找到有菜单id的权限，将其存入字典，键为权限的id&gt; if menu_id:&gt; all_permission_dict[item['id']] = item&gt; # 可以改都是引用&gt; # 得到所有有菜单的权限后，将每一个权限都设置一个children键值对，用来存储子权限信息&gt; item['children'] = []&gt; for item in all_permission:&gt; pid = item.get('parent_id')&gt; # 如果有父id代表的是子权限&gt; if pid:&gt; # 如果是子权限，就将子权限的信息存入多上一步做的处理（有菜单的父权限）children中&gt; all_permission_dict[pid]['children'].append(item)&gt; return render(request, 'rbac/menu_list.html', &#123;&gt; "mid": mid,&gt; "all_menu": all_menu,&gt; "all_permission_dict": all_permission_dict,&gt; &#125;)&gt; 权限系统的应用 拷贝rbac App到新项目中 注册APP 以及配置信息 12345678910&gt; # ###### 权限相关的配置 ######&gt; PERMISSION_SESSION_KEY = &apos;permissions&apos;&gt; MENU_SESSION_KEY = &apos;menus&apos;&gt; WHITE_URL_LIST = [&gt; r&apos;^/login/$&apos;,&gt; r&apos;^/logout/$&apos;,&gt; r&apos;^/reg/$&apos;,&gt; r&apos;^/admin/.*&apos;,&gt; ]&gt; 数据库迁移命令 删除rbac所有的迁移文件 执行两条命令 路由相关 url(r’rbac/‘,include(‘rbac.urls’,namespace=’rbac’)) 给所有的URL起名字 layout 模板注意 block css js content 权限的管理 添加角色 添加菜单 添加权限 分配权限 用户关联—修改原系统的用户表 跟rbac的UserInfouser = models.OneToOneField(UserInfo,null=True,blank=True) 给用户分角色 给角色分权限 登录应用权限 登录成功后 12345&gt; auth.login(request, obj)&gt; ret = init_permission(request, obj)&gt; if ret:&gt; return ret&gt; 初始化权限信息init_permission函数中修改 user -&gt; user.user permission_query = user.user.roles.filter 应用权限校验中间件 12&gt; &apos;rbac.middleware.rbac.PermissionMiddleware&apos;,&gt; 应用左侧菜单和面包屑导航 在layout模板中，引用CSS和JS 二级菜单 123&gt; &#123;% load rbac %&#125;&gt; &#123;% menu request %&#125;&gt; 应用路径导航 12&gt; &#123;% breadcrumb request %&#125;&gt; 权限控制到按钮级别 12345678&gt; &#123;% load rbac %&#125;&gt; 判断 filter 判断里面只能用filter 只能一个一个判断&gt; &#123;% load rbac %&#125;&gt; &gt; &#123;% if request|has_permission:&apos;add_customer&apos; %&#125;&gt; &lt;a href=&quot;&#123;% url &apos;add_customer&apos; %&#125;?&#123;&#123; query_params &#125;&#125;&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;添加&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; 使用注意事项 用户注册后 对应在rbac中的UserInfo创建用户 和 原系统的用户做一对一关联 菜单 父权限 子权限 的层级关系]]></content>
      <categories>
        <category>RBAC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django之中间件]]></title>
    <url>%2F2018%2F07%2F15%2FDjango%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[中间件 中间件的概念 中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局 上改变django的输入与输出。因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。 Django的中间件的定义： Middleware is` `a framework of hooks into Django’s request/response processing. &lt;br&gt;It’s a light, low-level “plugin” systemforglobally altering Django’s input or output. 应用： 如果想修改请求，例如被传送到view中的HttpRequest对象。 或者想修改view返回的HttpResponse对象，这些都可以通过中间件来实现。 可能还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。 我们可能频繁在view使用request.user吧。 Django想在每个view执行之前把user设置request 的属性，于是就用了一个中间件来实现这个目标。所以Django提供了可以修改request 对象的中间 件 AuthenticationMiddleware。 Django默认的Middleware： 12345678910&gt; MIDDLEWARE = [&gt; 'django.middleware.security.SecurityMiddleware',&gt; 'django.contrib.sessions.middleware.SessionMiddleware',&gt; 'django.middleware.common.CommonMiddleware',&gt; 'django.middleware.csrf.CsrfViewMiddleware',&gt; 'django.contrib.auth.middleware.AuthenticationMiddleware',&gt; 'django.contrib.messages.middleware.MessageMiddleware',&gt; 'django.middleware.clickjacking.XFrameOptionsMiddleware',&gt; ]&gt; 每一个中间件都有具体的功能 自定义中间件 中间件一共有四种方法 12345678&gt; # process_request&gt; &gt; # process_view&gt; &gt; # process_exception&gt; &gt; # process_response&gt; process_request,process_response 当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。 我们也可以自己定义一个中间件，我们可以自己写一个类，但是必须继承MiddlewareMixin 需要导入 12&gt; &gt; from django.utils.deprecation import MiddlewareMixin&gt; &gt; in views: 12345&gt; &gt; &gt;def index(request):&gt; &gt; &gt;&gt; &gt; &gt; print("view函数...")&gt; &gt; &gt; return HttpResponse("OK")&gt; &gt; &gt; in Mymiddlewares.py： 123456789101112131415161718192021&gt; &gt; &gt;from django.utils.deprecation import MiddlewareMixin&gt; &gt; &gt;from django.shortcuts import HttpResponse&gt; &gt; &gt;&gt; &gt; &gt;class Md1(MiddlewareMixin):&gt; &gt; &gt;&gt; &gt; &gt; def process_request(self,request):&gt; &gt; &gt; print("Md1请求")&gt; &gt; &gt; &gt; &gt; &gt; def process_response(self,request,response):&gt; &gt; &gt; print("Md1返回")&gt; &gt; &gt; return response&gt; &gt; &gt;&gt; &gt; &gt;class Md2(MiddlewareMixin):&gt; &gt; &gt;&gt; &gt; &gt; def process_request(self,request):&gt; &gt; &gt; print("Md2请求")&gt; &gt; &gt; #return HttpResponse("Md2中断")&gt; &gt; &gt; def process_response(self,request,response):&gt; &gt; &gt; print("Md2返回")&gt; &gt; &gt; return response&gt; &gt; &gt; 结果： 123456&gt; &gt; &gt;Md1请求&gt; &gt; &gt;Md2请求&gt; &gt; &gt;view函数...&gt; &gt; &gt;Md2返回&gt; &gt; &gt;Md1返回&gt; &gt; &gt; 注意：如果当请求到达请求2的时候直接不符合条件返回，即return HttpResponse(“Md2中断”)，程序将把请求直接发给中间件2返回，然后依次返回到请求者，结果如下： 返回Md2中断的页面，后台打印如下： 12345&gt; &gt; &gt;Md1请求&gt; &gt; &gt;Md2请求&gt; &gt; &gt;Md2返回&gt; &gt; &gt;Md1返回&gt; &gt; &gt; 流程图如下： process_view 12&gt; &gt;process_view(self, request, callback, callback_args, callback_kwargs)&gt; &gt; Mymiddlewares.py修改如下 123456789101112131415161718192021222324252627&gt; &gt;from django.utils.deprecation import MiddlewareMixin&gt; &gt;from django.shortcuts import HttpResponse&gt; &gt;&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("Md1view")&gt; &gt;&gt; &gt;class Md2(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md2请求")&gt; &gt; return HttpResponse("Md2中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md2返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("Md2view")&gt; &gt; 结果如下： 12345678&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;Md1view&gt; &gt;Md2view&gt; &gt;view函数...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 下图进行分析上面的过程： 当最后一个中间的process_request到达路由关系映射之后，返回到中间件1的process_view，然后 依次往下，到达views函数，最后通过process_response依次返回到达用户。 process_view可以用来调用视图函数： 12345678910111213141516&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt;&gt; &gt; # return HttpResponse("hello")&gt; &gt;&gt; &gt; response=callback(request,*callback_args,**callback_kwargs)&gt; &gt; return response&gt; &gt; 结果如下： 123456&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;view函数...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 注意：process_view如果有返回值，会越过其他的process_view以及视图函数，但是所有的 process_response都还会执行。 process_exception 12&gt; &gt;process_exception(self, request, exception)&gt; &gt; 示例修改如下： 123456789101112131415161718192021222324252627282930313233343536&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt;&gt; &gt; # return HttpResponse("hello")&gt; &gt;&gt; &gt; # response=callback(request,*callback_args,**callback_kwargs)&gt; &gt; # return response&gt; &gt; print("md1 process_view...")&gt; &gt;&gt; &gt; def process_exception(self):&gt; &gt; print("md1 process_exception...")&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;class Md2(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md2请求")&gt; &gt; # return HttpResponse("Md2中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md2返回")&gt; &gt; return response&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("md2 process_view...")&gt; &gt;&gt; &gt; def process_exception(self):&gt; &gt; print("md1 process_exception...")&gt; &gt; 结果如下： 123456789&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;md1 process_view...&gt; &gt;md2 process_view...&gt; &gt;view函数...&gt; &gt;&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 流程图如下： 当views出现错误时： 将md2的process_exception修改如下： 12345&gt; &gt; def process_exception(self,request,exception):&gt; &gt;&gt; &gt; print("md2 process_exception...")&gt; &gt; return HttpResponse("error")&gt; &gt; 结果如下： 123456789&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;md1 process_view...&gt; &gt;md2 process_view...&gt; &gt;view函数...&gt; &gt;md2 process_exception...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
</search>
