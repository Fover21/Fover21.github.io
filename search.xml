<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex+axios]]></title>
    <url>%2F2018%2F11%2F13%2FVuex-axios%2F</url>
    <content type="text"><![CDATA[Vuex+axios Vuex 简介vuex是一个专门为Vue.js设计的集中式状态管理架构。 状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。 Vuex和单纯的全局对象有以下不同： 1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候， 若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。 2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的 提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化， 从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。 安装使用vuex– npm install vuex vuex的使用一 // main.js import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import vuex from &apos;vuex&apos; Vue.use(vuex) Vue.config.productionTip = false const store = new vuex.Store({ state: { show: false, } }); new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); vuex的使用二 // 为了方便维护，我们通常把在src下面新建一个store文件夹， // 然后在里面新建一个index.js import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { show: false, }, }); // 那么main.js要改成 import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; Vue.config.productionTip = false; new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); State简而言之~~state是保存我们data中需要共享的数据。 由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。 this.$store.state.count 组件中获取vuex中状态 // 创建一个组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count(){ return this.$store.state.count } } }; Getter有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。 并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。 我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被 缓存起来，只有它的依赖发生改变时，才会重新计算。 Getter会接收state作为其第一个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 } }, }); Getter也可以接收getters为第二个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 }, // 通过 this.$store.getters.my_func_count my_func_count: function (state, getters) { return getters.my_func.length } }, }); Mutatiion更改Vuex中的store中的状态的唯一方法是提交mutation。 每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。 也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。 这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数： Mutation基本使用 import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 需要通过 this.$store.commit(&apos;increment&apos;, 10) mutations: { increment (state, n) { // 变更状态 state.count += n } } }); Mutation需要遵守Vue的响应规则 既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。 这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项： – 1，最好提前在你的store中初始化好所有的所需要的属性 – 2，当对象需要添加属性时，你应该使用 – Vue.set(obj, ‘newProp’, 123) – 以新对象代替老对象 state.obj = { …state.obj, newProp: 123} axios的简单使用基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。 ## 使用npm安装axios – npm install axios -D 基本的配置// main.js import axios from &quot;axios&quot; Vue.prototype.$axios = axios // 组件中 methods: { init () { this.$axios({ method: &quot;get&quot;, url: &quot;/user&quot; }) }, }; 基本的使用get请求 test(){ this.$axios.get(this.$store.state.apiList.course,{ params: { id: 123, } }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } post请求 test(){ this.$axios.post(this.$store.state.apiList.course,{ course_title: &quot;Python&quot;, course_price: &quot;19.88&quot; }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } 发送多个并发请求 function getCourse(){ return this.$axios.get(&apos;/course/12&apos;) } function getCourse_all() { return this.$axios.get(&apos;/course&apos;) } this.$axios.all([getCourse_all(),getCourse()]) .then().catch() axios.request methods: { init(){ var that = this this.$axios.request({ url: that.$store.state.apiList.course, method: &apos;get&apos; }).then(function (data) { if (data.status === 200){ that.courseList = data.data } }).catch(function (reason) { console.log(reason) }) } },]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm+webpack+vue-cli快速上手]]></title>
    <url>%2F2018%2F11%2F13%2Fnpm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[npm+webpack+vue-cli快速上手 Node.js npm什么是Node.js 以及npm简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。 npm 是Node.js 的包管理工具。 npm的安装和更新Node.js下载安装 Node.js 官网下载安装。npm自带的包管理工具。 查看安装版本信息： – node -v 查看Node.js 版本信息 – npm -v 查看npm版本信息 更新npm到指定版本： – npm install npm@5.3.0 -g – npm install npm@latest -g 更新最新的稳定版本 npm 常用操作之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。 有了npm，我们管理自己的依赖包以及版本更加简单。 到自己项目目录下，进行以下命令： – npm init -y 输入-y使用默认配置项 生成package.json文件。 – npm i jquery@0.0.0 简写install 为 i 下载依赖 不写@ 默认最新版本 – npm uninstall jquery 卸载依赖包 – npm update jquery 更新依赖包 – npm list 列出已安装的依赖 – npm install webpack –D 保存为开发环境依赖 – 老版本需要 –save 参数 现在不需要了 我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。 我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。 如果我们删掉 node_modules目录，可以使用 npm i 来下载所有依赖。 npm 常用配置项当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。 在我们的package.json文件中有很多配置项 – name 项目名字 中间不能有空格只能用小写 – version 项目版本 – description 项目描述信息 – main 项目的入口文件 – scripts 指定命令的快捷方式 npm run test test是scripts里的键名 值为具体命令 – author 作者 – license 许可证 – dependencies 生成环境依赖的包以及版本信息 – devDependencies 开发环境的依赖 webpack3webpack是什么webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析， 然后将这些模块按照指定的规则生成静态资源。 那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113##安装和配置 webpack是跑在Node.js环境下的，所以确定自己有node环境。安装方式： -- npm install webpack -g 全局安装 -- webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 全局这种方式进行打包 -- npm install webpack 在自己的项目下 npm init 后在下载webpack 这就是局部安装 -- node_modules/.bin/webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 项目里要打包文件是入口文件 -- 路径太长 太烦 可以自定义命令 在package.json 文件的 scripts下面自定义## entry 和 output entry 入口文件 output 出口文件 上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~ 我们可以把命令写在webpack.config.js文件中~~&gt;webpack.config.jsmodule.export = &#123; // 所有的入口文件 entry: &#123; home: &apos;./main.js&apos;, login: &apos;./login.js&apos;, &#125;, // 出口文件 output: &#123; filename: &apos;[name].bundle.js&apos;, path: __dirname + &apos;/dist&apos;, &#125; &#125;// backage.json 下的scriptsscripts: &#123; &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;&#125;// 运行命令npm run pack# webpack4## webpack的新特性1, webpack不在单独使用，需要webpack-cli -- 全局安装 npm install webpack webpack-cli -g -D -- 局部安装 npm install webpack webpack-cli -D2, 增加了模式区分 （development, production） --webpack --mode development/production 进行模式切换 -- development 开发者模式 打包默认不压缩代码 -- production 生产者模式 上线时使用，压缩代码。 默认是这个模式3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下 -- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js4，多入口以及多出口&gt;webpack.config.js entry: &#123; // 多入口 a: &quot;./src/js/index.js&quot;, b: &quot;./src/js/index2.js&quot;,&#125;output: &#123; // 多出口 path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;./js/[name].bundle.js&apos;&#125;# vue-clivue-cli是官方提供的快速构建这个单页面应用的脚手架。## 根据官方文档中的构件流程： -- 前提是已经安装了node.js 否则npm都用不了 -- 1，使用npm全局安装vue-cli npm install -g vue-cli -- 2, 安装完成后在自己的工作空间里 vue init webpack vue-demo 输入命令后进入安装阶段，需要用户输入一些信息 这里省略了..... -- 3，切换到我们的项目目录下 cd vue-demo npm run dev## 目录结构： -- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件 -- config 配置文件，执行文件需要的配置信息 -- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下 -- node_modules 项目依赖包 -- static 静态资源 -- package.json 依赖包的json文件其实这里面命令很多~我们在后续项目中应用到再说 vue-cli配置JQuery、bootstrap第一步 下载安装 – npm install jquery – npm install bootstrap 第二步 修改build/webpack.base.conf.js const webpack = require(‘webpack’)// 在module.exports里添加插件plugins: [ new webpack.ProvidePlugin({ $: “jquery”, jQuery: “jquery”, “windows.jQuery”: “jquery”, // Popper: [‘popper.js’, ‘default’] })],// ***下面是如果手动下载bootstrap用的***resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘vue$’: ‘vue/dist/vue.esm.js’, ‘@’: resolve(‘src’), // 如果是手动下载的bootstrap需要添加这个配置 // ‘assets’: path.resolve(__dirname, ‘../src/assets’), // ‘jquery’: ‘jquery/src/jquery’ } }, 修改配置文件 第三步 修改主程序的js文件 main.js import $ from ‘jquery’import ‘bootstrap/dist/css/bootstrap.min.css’import ‘bootstrap/dist/js/bootstrap.min.js’ vue-cli 3.0第一步 下载vue-cli 3.0 – npm install -g @vue/cli – 报错 npm error 可以运行下面命令 – npm cache clean –force &amp;&amp; npm cache verify 第二步 创建项目 – vue create xxxx 之后会出现很多选项，我们可以根据自己的习惯去选择~~ 第三步 目录结构以及配置文件 – vue-cli3 目录更加简单 – 我们手动在项目根目录下创建 vue.config.js 里面写vue的配置信息 vue-cli3 配置jQuery、bootstrap – 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[restful_framework(1)]]></title>
    <url>%2F2018%2F11%2F13%2Frestful-framework%2F</url>
    <content type="text"></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue总结]]></title>
    <url>%2F2018%2F11%2F13%2FVue%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue总结 vue总结 MVC Model View Controller MVVM Model View ViweMode ES6常用语法1.1 变量的提升 1.2 模板字符串 ``${} 1.3 数据的解构 1.4 类 class extends constructor super 1.5 函数 1.5.1 注意this和普通函数的区别 1.6 箭头函数 1.7 单体模式 1.8 import export export default Vue常用指令2.1 v-text innerText 2.2 v-html innerHtml 2.3 v-for :key 2.4 v-if v-else-if v-else appendChild 2.5 v-show display 2.6 v-on @xxxx=&quot;自己处理的方法&quot; 2.7 v-bind :属性名称=“属性的值” 2.8 v-model 2.8.1 input 2.8.2 textarea 2.8.3 select 2.9 指令修饰符 2.9.1 .lazy 2.9.2 .number 2.9.3 .trim 2.10 计算属性 2.10.1 放入缓存 2.10.2 只有数据改变的时候才会重新计算 2.11 数据监听 2.11.1 注意可变类型和不可变 2.11.2 深监听 deep=true 2.12 获取DOM 2.12.1 给便签绑定ref属性 ref=“属性值” 2.12.2 this.$refs.属性值 2.13 自定义指令 2.13.1 vue.directive(“指令名称”, function(el, binding){ el 绑定指令的便签元素 binding 指令的所有信息 }) 注意事项3.1 数据监听 3.1.1 改变数据 直接赋值 3.1.2 改变数组长度 能够被监听到，新值和旧值一样 3.1.3 改变数组内的值 app = new vue({}) app.$set(this.hobby, 0, &apos;抽烟&apos;) $set()修改数组中的值可以监听 $delete() Vue的组件组件的注册全局注册Vue.compontent(“组件名称”, {}) 局部注册const = app = new Vue({ el: &apos;#app&apos;, components: { 组件的名称: 组件的配置信息 } }) 子组件的注册在父组件中注册components ## 注意写组件标签 ## 每个组件的template只识别一个作用域块 通信父子的通信在父组件中给子组件绑定属性 子组件通过props=[&quot;属性名称&quot;] 子父的通信子组件先提交事件 this.$emit(&quot;事件名称&quot;, 值) 在父组件中给子组件绑定事件 &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt; 非父子的通信其中一个组件向中间调度器提交事件 另一个组件监听中间调度器的事件 注意this的问题 中间调度器 let temp = new Vue(); temp.$emit(&quot;say&quot;, value) // 事件名称和值 mounted(){ that = this // 监听中间调度器中的方法 temp.$on(&quot;say&quot;, function(data){ // 这里的this是temp的this that.xxx = data // 这样改值 }) } 插槽&lt;slot&gt;&lt;/slot&gt; 命名的插槽 混合代码重用的 mixins = [base] Vue的生命周期vue生命周期之beforeCreate实例创建之前除标签外，所有的vue需要的数据，事件都不存在 vue生命周期之created实例创建之后，data和事件已经被解析到，el还没有找到 vue生命周期之beforeMount开始找标签，数据还没有被渲染，事件也没有被监听 vue生命周期之mounted开始渲染数据，开始监听事件 vue生命周期之beforeUpdata数据已经被修改在虚拟DOM，但没有被渲染到页面上 vue生命周期之updata开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改 vue生命周期之beforeDestory所有的数据都存在 vue生命周期之destoryed所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了 &lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签 用activated和deactivated取代了beforeUpdate和destory的执行 最常用的钩子beforeMount mounted 路由注册let url = [ { path: &apos;/&apos;, name: &quot;home&quot;, component: { template: ``, } } ] let router = nwe VueRouter({ routes: url }) const app = new Vue({ el: &apos;app&apos;, router: router, }) &lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt; &lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 子路由children: [ {} ] append 在父路由对应的组件的template里面写router-link router-view 路由的命名name 注意to加冒号动态绑定 路由的参数{ path: &quot;/course/:id&quot;, } this.$route.params.id this.$route.query.xxx $route 是一个对象 存放当前路由的所有信息 $router VueRouter实例化对象 手动路由this.$router.push(&apos;/&apos;) this.$router.push({name:&quot;home&quot;}) 重定向redirect: {name: &apos;xxx&apos;, params: {key: value}} 路由的钩子router.beforeEach(function(to, from next){ // to 你要去哪 // from 你要从哪里来 // next() 你要去做什么 参数可以给路径 必须有，没有就不走 }) router.afterEach(function(to, from){ // to 你要去哪 // from 你从哪里来 }) to和from都是$route对象 路由的所有信息  node.js + npm + webpack + vue-cli(自带webpack)node.js / npm - npm 管理工作目录 npm init -y - 下载包 npm i xxx@0.0.0 - 卸载 npm uninstall xxx - 更新 npm updata xxx webpack - 下载 npm i webpack webpack-cli - 打包默认的入口文件 src目录下的index.js - 出口文件 dist目录的main.js wue-cli 2 - 帮助我们快速搭建项目的脚手架工具 - 下载 npm i vue-cli - 用vue-cli帮助我们创建项目 vue init webpack xxxx - 启动项目 cd xxxx npm run dev Vuex和axios]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
