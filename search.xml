<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django之用户认证-auth模块]]></title>
    <url>%2F2018%2F11%2F16%2FDjango%E4%B9%8B%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81-auth%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[用户认知———auth模块 一、auth模块 from django.contrib import auth 1、authenticate()：验证用户输入的用户名和密码是否相同 提供了用户认证，即验证用户名以及密码是否正确,一般需要usernamepassword两个关键字参数 如果认证信息有效，会返回一个User对象。authenticate()会在User对象上设置一个属性标识，那 种认证，后端认证了该用户，且信息在后面的登录过程中是需要的。当我们试图登录一个从数据库 中直接取出来不经过authenticate()的User对象会报错的！！！ 2、login(HttpRequest,user):登录 该函数接受一个HttpRequest对象，以及一个认证的User对象 此函数使用django的session框架给每个已认证的用户附加上session id等信息。 1234567891011121314&gt; from django.contrib.auth import authenticate, login&gt; &gt; def my_view(request):&gt; username = request.POST['username']&gt; password = request.POST['password']&gt; user = authenticate(username=username, password=password)&gt; if user:&gt; login(request, user)&gt; # Redirect to a success page.&gt; ...&gt; else:&gt; # Return an 'invalid login' error message.&gt; ...&gt; 3、logout(request):注销用户 该函数接受一个HttpRequest对象，无返回值，当调用该函数是时，当请求的session信息会全部 清除。该用户即使没有登录，使用该函数也不会登录。 123456&gt; from django.contrib.auth import logout&gt; &gt; def logout_view(request):&gt; logout(request)&gt; # Redirect to a success page.&gt; 4、user对象的is_authenticated() 要求 用户登录后才能访问某些页面 如果用户没有登录就访问该页面的话直接跳转登录页面 用户在跳转的登录界面中完成登录后，自动访问跳转到之前访问的地址 方法一 1234&gt; def my_view(request):&gt; if not request.user.is_authenticated():&gt; return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))&gt; 方法二：django已经为我们设计好了一个用于次情况的装饰器：login_request() 123456&gt; from django.contrib.auth.decorators import login_required&gt; &gt; @login_required&gt; def my_view(request):&gt; ...&gt; 若用户没有登录，则会跳转到django默认的登录URL’/account/login’(这个值可以在settings文件中 通过LOGIN_URL进行修改）。并传递当前访问url的绝对路径（登录成功后，会重定向该路径） 二、User对象 User对象属性： username password（必填项）password用哈希算法保存到数据库 is_staff：用户是否拥有网站的管理权限 is_active：是否允许用户登录，设置为‘False’，可以不用删除用户来禁止用户登录 is_authenticated() 如果是真正的User对象，返回值恒为True。用于检测用户是否已经通过认证。 通过认证并不意味着用户拥有任何权限，甚至也不检查该用户是否处于激活状态，这只是表明 用户成功通过了认证。 这个方法很重要，在后台使用 request.user.is_authenticated()判断用户是否已经登录，如果True则可以向前台展示 -request.user.name 创建用户create_user 123&gt; from django.contrib.auth.models import User&gt; user = User.objects.create_user（username='',password='',email=''）&gt; check_passw(passwd):密码检测 用户需要修改密码的时候 首先要让他输入原来的密码 ，如果给定的字符串通过了密码检查，返回 True 修改密码：set_password() 1234&gt; user = User.objects.get(username='')&gt; user.set_password(password='')&gt; user.save &gt; 三、简单实例 登录： 12345678910111213141516&gt;def log_in(request):&gt; print(request.POST)&gt; if request.method =="POST":&gt; username = request.POST.get("username")&gt; password = request.POST.get("password")&gt; print(username,password)&gt; user=auth.authenticate(username=username,password=password)#验证用户名和密码&gt; if user:&gt; #如果认证成功，就让登录，这个login里面包括了session操作和cookie&gt; auth.login(request,user)&gt; return redirect("/chakan/")&gt; else:&gt; s = "用户名和密码输入错误"&gt; return render(request,"login.html",&#123;"s":s&#125;)&gt; return render(request,"login.html")&gt; 修改密码： 1234567891011121314151617&gt;def set_pwd(request):&gt; if request.method=="POST":&gt; oldpassword = request.POST.get("oldpassword")&gt; newpassword = request.POST.get("newpassword")&gt; #得到当前登录的用户，判断旧密码是不是和当前的密码一样&gt; username = request.user #打印的是当前登录的用户名&gt; user = User.objects.get(username=username) #查看用户&gt; ret = user.check_password(oldpassword) #检查密码是否正确&gt; if ret:&gt; user.set_password(newpassword) #如果正确就给设置一个新密码&gt; user.save() #保存&gt; return redirect("/login/")&gt; else:&gt; info = "输入密码有误"&gt; return render(request,"set_pwd.html",&#123;"info":info&#125;)&gt; return render(request,"set_pwd.html")&gt; 注册： 12345678910&gt;def reg(request):&gt; if request.method=="POST":&gt; username = request.POST.get("username")&gt; password = request.POST.get("password")&gt; #得到用户输入的用户名和密码创建一个新用户&gt; User.objects.create_user(username=username,password=password) #User是以个对象&gt; s = "恭喜你注册成功，现在可以登录了"&gt; return redirect("/login/")&gt; return render(request,"reg.html")&gt; 注销： 1234&gt;def log_out(request):&gt; auth.logout(request)&gt; return redirect("/login/")&gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-admin管理工具]]></title>
    <url>%2F2018%2F11%2F15%2FDjango-admin%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[admin组件使用Django提供了基于web的管理工具 Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 settings.py 中的 INSTALLED_APPS 看到它： # Application definition INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &quot;app01&quot; ] django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。 激活管理工具 通常在生成项目的时候会在urls.py中自动设置好 from django.conf.urls import url from django.contrib import admin urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), ] 当这一切配置好后，Django管理工具就可以运行了。 使用管理工具启动开发服务器，然后在浏览器中访问 http://127.0.0.1:8000/admin/，得到登陆界面， 你可以通过命令 python manage.py createsuperuser 来创建超级用户。 为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin from django.db import models # Create your models here. class Author(models.Model): name=models.CharField( max_length=32) age=models.IntegerField() def __str__(self): return self.name class Publish(models.Model): name=models.CharField( max_length=32) email=models.EmailField() def __str__(self): return self.name class Book(models.Model): title = models.CharField( max_length=32) publishDate=models.DateField() price=models.DecimalField(max_digits=5,decimal_places=2) publisher=models.ForeignKey(to=&quot;Publish&quot;) authors=models.ManyToManyField(to=&apos;Author&apos;) def __str__(self): return self.title admin的定制在admin中只需要将Model中的某个类注册，即可在Admin中实现增删改查的功能，如： admin.site.register(models.UserInfo) 但是这种方式比较简单，如果想进行更多的定制操作，需要利用ModelAdmin进行操作， 如： 方式一： class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,) admin.site.register(models.UserInfo, UserAdmin) # 第一个参数可以是列表 方式二： @admin.register(models.UserInfo) # 第一个参数可以是列表 class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,) ModelAdmin中提供了大量的可定制功能，如： 1 list_display，列表时，定制显示的列。 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;) def xxxxx(self, obj): return &quot;xxxxx&quot; 2 list_display_links，列表时，定制列可以点击跳转。 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;, &apos;xxxxx&apos;) list_display_links = (&apos;pwd&apos;,) 3 list_filter，列表时，定制右侧快速筛选。4 list_select_related，列表时，连表查询是否自动select_related5 list_editable，列表时，可以编辑的列 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): list_display = (&apos;user&apos;, &apos;pwd&apos;,&apos;ug&apos;,) list_editable = (&apos;ug&apos;,) 6 search_fields，列表时，模糊搜索的功能 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): search_fields = (&apos;user&apos;, &apos;pwd&apos;) 7 date_hierarchy，列表时，对Date和DateTime类型进行搜索 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): date_hierarchy = &apos;ctime&apos; 8 inlines，详细页面，如果有其他表和当前表做FK，那么详细页面可以进行动态增加和删除 class UserInfoInline(admin.StackedInline): # TabularInline extra = 0 model = models.UserInfo class GroupAdminMode(admin.ModelAdmin): list_display = (&apos;id&apos;, &apos;title&apos;,) inlines = [UserInfoInline, ] 9 action，列表时，定制action中的操作 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): # 定制Action行为具体方法 def func(self, request, queryset): print(self, request, queryset) print(request.POST.getlist(&apos;_selected_action&apos;)) func.short_description = &quot;中文显示自定义Actions&quot; actions = [func, ] # Action选项都是在页面上方显示 actions_on_top = True # Action选项都是在页面下方显示 actions_on_bottom = False # 是否显示选择个数 actions_selection_counter = True 10 定制HTML模板 add_form_template = None change_form_template = None change_list_template = None delete_confirmation_template = None delete_selected_confirmation_template = None object_history_template = None 11 raw_id_fields，详细页面，针对FK和M2M字段变成以Input框形式 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): raw_id_fields = (&apos;FK字段&apos;, &apos;M2M字段&apos;,) 12 fields，详细页面时，显示字段的字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): fields = (&apos;user&apos;,) 13 exclude，详细页面时，排除的字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): exclude = (&apos;user&apos;,) 14 readonly_fields，详细页面时，只读字段 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): readonly_fields = (&apos;user&apos;,) 15 fieldsets，详细页面时，使用fieldsets标签对数据进行分割显示 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): fieldsets = ( (&apos;基本数据&apos;, { &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;, &apos;ctime&apos;,) }), (&apos;其他&apos;, { &apos;classes&apos;: (&apos;collapse&apos;, &apos;wide&apos;, &apos;extrapretty&apos;), # &apos;collapse&apos;,&apos;wide&apos;, &apos;extrapretty&apos; &apos;fields&apos;: (&apos;user&apos;, &apos;pwd&apos;), }), ) 16 详细页面时，M2M显示时，数据移动选择（方向：上下和左右） @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): filter_vertical = (&quot;m2m字段&quot;,) # 或filter_horizontal = (&quot;m2m字段&quot;,) 17 ordering，列表时，数据排序规则 @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): ordering = (&apos;-id&apos;,) 或 def get_ordering(self, request): return [&apos;-id&apos;, ] 18 radio_fields，详细页面时，使用radio显示选项（FK默认使用select） radio_fields = {&quot;ug&quot;: admin.VERTICAL} # 或admin.HORIZONTAL 19 form = ModelForm，用于定制用户请求时候表单验证 from app01 import models from django.forms import ModelForm from django.forms import fields class MyForm(ModelForm): others = fields.CharField() class Meta: model = models = models.UserInfo fields = &quot;__all__&quot; @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): form = MyForm 20 empty_value_display = “列数据为空时，显示默认值” @admin.register(models.UserInfo) class UserAdmin(admin.ModelAdmin): empty_value_display = &quot;列数据为空时，默认显示&quot; list_display = (&apos;user&apos;,&apos;pwd&apos;,&apos;up&apos;) def up(self,obj): return obj.user up.empty_value_display = &quot;指定列数据为空时，默认显示&quot; 例子： from django.contrib import admin # Register your models here. from .models import * class BookInline(admin.StackedInline): # TabularInline extra = 0 model = Book class BookAdmin(admin.ModelAdmin): list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;,&quot;foo&quot;,&quot;publisher&quot;) list_display_links = (&apos;publishDate&apos;,&quot;price&quot;) list_filter = (&apos;price&apos;,) list_editable=(&quot;title&quot;,&quot;publisher&quot;) search_fields = (&apos;title&apos;,) date_hierarchy = &apos;publishDate&apos; preserve_filters=False def foo(self,obj): return obj.title+str(obj.price) # 定制Action行为具体方法 def func(self, request, queryset): print(self, request, queryset) print(request.POST.getlist(&apos;_selected_action&apos;)) func.short_description = &quot;中文显示自定义Actions&quot; actions = [func, ] # Action选项都是在页面上方显示 actions_on_top = True # Action选项都是在页面下方显示 actions_on_bottom = False # 是否显示选择个数 actions_selection_counter = True change_list_template=&quot;my_change_list_template.html&quot; class PublishAdmin(admin.ModelAdmin): list_display = (&apos;name&apos;, &apos;email&apos;,) inlines = [BookInline, ] admin.site.register(Book, BookAdmin) # 第一个参数可以是列表 admin.site.register(Publish,PublishAdmin) admin.site.register(Author) admin源码解析单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式主要目的是确保 某一个类只有一个实例存在。当我们希望在整个系统中，某个类只能出现一个实例 时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个APPConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方需要使用配置文 件的内容，也就是说，很多地方都需要APPConfig的实例对象，而这样会严重浪费 内存资源，尤其是在配置文件内容很多的情况下。事实上，类似AppConfig这样的 类，我们希望在程序运行期间只存在一个实例对象。 在python中，我们可以用很多种方式来实现单例模式：使用模块（模块的导入）使用new使用装饰器（decorator）使用元类（metaclass）（1）使用new 为了使类只能出现一个实例，我们可以使用new来控制实例的创建过程，代码 如下： class Singleton(object): _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 在上面的代码中，我们将类的实例和一个类变量instance关联起来，如果cls.instance为None则创建实例，否则直接返回cls._instance执行情况： &gt;&gt;&gt; one = MyClass() &gt;&gt;&gt; two = MyClass() &gt;&gt;&gt; one == two True &gt;&gt;&gt; one is two True &gt;&gt;&gt; id(one), id(two) (4303862608, 4303862608) (2)使用模块 其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当 第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的 函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可 以考虑这样做： # mysingleton.py class My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码保存在文件 mysingleton.py 中，然后这样使用： from mysingleton import my_singleton my_singleton.foo() admin执行流程循环加载执行所有已经注册的app中的admin.py文件def autodiscover(): autodiscover_modules(&apos;admin&apos;, register_to=site) 执行代码＃admin.py class BookAdmin(admin.ModelAdmin): list_display = (&quot;title&quot;,&apos;publishDate&apos;, &apos;price&apos;) admin.site.register(Book, BookAdmin) admin.site.register(Publish) admin.siteclass AdminSite(object):... # This global object represents the default admin site, for the common case. # You can instantiate AdminSite in your own code to create a custom admin site. site = AdminSite() 这里应用的是一个单例模式，对于AdminSite类的一个单例模式，执行的每一个app中的每一个admin.site 都是一个对象。 执行register方法admin.site.register(Book, BookAdmin) admin.site.register(Publish) class ModelAdmin(BaseModelAdmin):pass def register(self, model_or_iterable, admin_class=None, **options): if not admin_class: admin_class = ModelAdmin # Instantiate the admin class to save in the registry self._registry[model] = admin_class(model, self) # 思考：在每一个app的admin .py中加上 print(admin.site._registry) ＃ 执行结果？ 到这里，注册结束！ admin的URL配置urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), ] class AdminSite(object): def get_urls(self): from django.conf.urls import url, include urlpatterns = [] # Add in each model&apos;s views, and create a list of valid URLS for the # app_index valid_app_labels = [] for model, model_admin in self._registry.items(): urlpatterns += [ url(r&apos;^%s/%s/&apos; % (model._meta.app_label, model._meta.model_name), include(model_admin.urls)), ] if model._meta.app_label not in valid_app_labels: valid_app_labels.append(model._meta.app_label) return urlpatterns @property def urls(self): return self.get_urls(), &apos;admin&apos;, self.name url方法的扩展应用from django.shortcuts import HttpResponse def test01(request): return HttpResponse(&quot;test01&quot;) def test02(request): return HttpResponse(&quot;test02&quot;) urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^ward/&apos;, ([ url(r&apos;^test01/&apos;, test01), url(r&apos;^test02/&apos;, test02), ],None,None)), ] 扩展优化from django.conf.urls import url,include from django.contrib import admin from django.shortcuts import HttpResponse def change_list_view(request): return HttpResponse(&quot;change_list_view&quot;) def add_view(request): return HttpResponse(&quot;add_view&quot;) def delete_view(request): return HttpResponse(&quot;delete_view&quot;) def change_view(request): return HttpResponse(&quot;change_view&quot;) def get_urls(): temp=[ url(r&quot;^$&quot;.format(app_name,model_name),change_list_view), url(r&quot;^add/$&quot;.format(app_name,model_name),add_view), url(r&quot;^\d+/del/$&quot;.format(app_name,model_name),delete_view), url(r&quot;^\d+/change/$&quot;.format(app_name,model_name),change_view), ] return temp url_list=[] for model_class,obj in admin.site._registry.items(): model_name=model_class._meta.model_name app_name=model_class._meta.app_label # temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),(get_urls(),None,None)) temp=url(r&quot;{0}/{1}/&quot;.format(app_name,model_name),include(get_urls())) url_list.append(temp) urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^ward/&apos;, (url_list,None,None)), ]]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-cli目录结构总结的步骤]]></title>
    <url>%2F2018%2F11%2F14%2Fvue-cli%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[main.js这是js的入口文件// The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; import axios from &apos;axios&apos; // 使用element-ui import ElementUI from &apos;element-ui&apos; import &apos;element-ui/lib/theme-chalk/index.css&apos; Vue.use(ElementUI); // 全局的（一个一个比较麻烦） // axios.request({ // url: XXX, // method: &quot;get&quot; // }); // 通过使用原型链 这样所有的组件都可以通过$axios去访问了 Vue.prototype.$axios = axios; Vue.config.productionTip = false; /* eslint-disable no-new */ new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); App.vue页面级App组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;MyHeader&gt;&lt;/MyHeader&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;MyFooter&gt;&lt;/MyFooter&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MyHeader from &quot;./components/MyHeader&quot; import MyFooter from &quot;./components/MyFooter&quot; export default { name: &apos;App&apos;, components: { MyHeader, MyFooter, } } &lt;/script&gt; &lt;style&gt; body { margin: 0; padding: 0; } &lt;/style&gt; router-index.jsimport Vue from &apos;vue&apos; import Router from &apos;vue-router&apos; import Home from &apos;../components/headers/Home&apos; import Course from &apos;../components/headers/Course&apos; Vue.use(Router); export default new Router({ routes: [ { path: &apos;/&apos;, name: &apos;home&apos;, component: Home }, { path: &apos;/course&apos;, name: &apos;course&apos;, component: Course } ] }) Vuex+axios的使用store.jsimport Vue from &quot;vue&quot; import Vuex from &quot;vuex&quot; Vue.use(Vuex); export default new Vuex.Store({ // this.$store.state.name 拿数据 state: { name: &apos;1&apos;, }, // 对state中的数据进行处理 // this.$store.getters.new_name 拿数据 getters: { new_name: function (state) { return state.name + &apos;xxx&apos;; }, new_new_name: function (state, getters) { return getters.new_name + &apos;000&apos;; }, }, mutations: { change_data: function (state, data) { // 自己处理change_data事件的 state.name = data; } } }) Course.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;course&lt;/h1&gt; {{name}} {{new_name}} &lt;hr&gt; {{try_again}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Course&quot;, data(){ return { name : this.$store.state.name, new_name: this.$store.getters.new_new_name, try_again: &apos;&apos;, } }, // 方法执行完会改版数据但是不会刷新 // methods: { // my_click: function () { // this.$store.commit(&quot;change_data&quot;, &apos;到到&apos;) // } // }, // 能够监听到数据的改变能够实时跟新 // computed: { // name: function () { // return this.$store.state.name; // } // } mounted(){ let that = this; this.$axios.request({ url: &quot;http://127.0.0.1:8000/tryagain/&quot;, method: &apos;get&apos;, }).then(function (data) { // success do something~~ that.try_again = data.data }).catch(function (data) { // fail do something~~ }) // 单纯的发get请求 // this.$axios.get(&quot;url&quot;, {}).then() } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git下]]></title>
    <url>%2F2018%2F11%2F14%2Fgit%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[分支管理策略1）master分支 非常稳定的，只用来发布新版本，平时不在上面干活 2）dev分支 不稳定的，主要在上面干活，每个人都有自己的分支，时不时的往dev分支上合并 通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 &gt; git log --graph --pretty=oneline --abbrev-commit Bug分支你目前在dev分支上工作，工作到一半，但突然有一个紧急的bug需要修复，可以先保存你的工作现场，修复完bug后，在切回来。 步骤： 当前在dev分支上： git stash # 把当前工作现场“储藏”起来 切换到要修复bug的分支（假定master）： git checkout master git checkout -b issue-101 .... 修复问题 git add filename git commit filename 把修改合并到修复的分支： git checkout master git merge --no-ff -m &quot;merge fix 101 modification&quot; issue-101 git branch -D issue-101 切换回工作现场： git checkout dev git stash list # 查看之前保存了哪些工作现场 git stash drop 两种恢复方式： 1）git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 git stash apply stash@{0} git stash drop stash@{0} 2）git stash pop，恢复的同时把stash内容也删了 Feature分支与bug分支类似 两条命令： 1）git branch -d dev_name # 已经合并完的分支可以使用此命令删除 2）git branch -d dev_name # 强制删除分支（未合并的也可以） 多人协作多个人在同一分支上工作，如何正确的合并文件？ 两种情况： **1）你和他人同时修改同一个文件，他人修改完成，提前推送到远程，如何提交你的修改** 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull拉取远程最新的版本； 3）如果合并有冲突，则解决冲突，并在本地提交； 4）没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 **2）你和他人操作的不是同一个文件 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，先用git pull拉取远程最新的版本； 3）git add . # 添加本地的全部修改到暂存区 4）git commit -m &quot;说明信息&quot; # 提交更改至本地 5）git push origin &lt;branch-name&gt;推送本地分支至远程 提交更改前，都要先git pull拉取远程最新版本 当从远程克隆时，Git自动把本地的master分支与远程的master分支对应起来，远程仓库的默认名称是origin。 查看远程库信息： git remote -v 推送分支： git push origin master 把本地的mater分支推送到远程对应的master分支上 git push origin dev 把本地的dev分支推送到远程对应的dev分支（远程没有dev分支会自动创建一个dev分支） 创建远程origin的dev分支到本地 git checkout -b dev origin/dev 指定本地dev分支与远程origin/dev分支的链接 git branch --set-upstream-to origin/dev dev 或 git branch --track origin/dev dev 标签tag是一个容易记住的有意义的名字，它跟某个commit绑定在一起。 打标签： git tag tag_name # 默认打在最新提交的commit上,当前HEAD的指向 git tag # 查看标签 git show tag_name # 查看标签详细信息 在指定的commit上打标签： git log --pretty=oneline # 查看commit id git log -a tag_name -m &quot;explain content&quot; commit_id 推送标签： git push origin tag_name # 推送一个指定的标签 git push origin --tags # 推送全部尚未推送到远程的本地标签 删除标签： 1) 标签尚未推送到远程 git tag -d tag_name 2）标签已推送到远程 git tag -d tag_name git push origin :refs/tags/tag_name Rebase解决查看log分支多，混乱的问题；遗留]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令]]></title>
    <url>%2F2018%2F11%2F14%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看 conda 版本号conda -Vconda –version 环境管理 查看当前有哪些环境 conda env list 或conda info -e 实际执行命令示例:➜ ~ conda env list conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 ➜ ~ conda info -e conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 查看环境管理的命令帮助 conda env -h 创建环境 conda create –name your_env_name 创建指定 python 版本的环境 conda create –name your_env_name python=2.7conda create –name your_env_name python=3.6 创建包含某些包的环境 conda create –name your_env_name numpy scrapy 创建指定版本下包含某些包的环境 conda create –name your_env_name python=3.6 numpy scrapy 激活某个环境 source activate target_env_name 关闭激活的环境 source deactivate target_env_name 复制某个环境 conda create –name new_env_name –clone old_env_name 删除某个环境 conda remove –name target_env_name –all 包管理 列举当前活跃环境下的所有包 conda list 列举一个指定环境下的所有包 conda list -n your_env_name 为激活环境安装某个包 conda install package_name 为指定环境安装某个包 conda install –name target_env_name package_name 更新当前环境某个包 conda update package_name 更新指定环境某个包 conda update -n target_env_name package_name 删除当前环境某个包 conda remove package_name注意: 如果是通过pip安装的包,移除时也请使用 pip uninstall package_name 命令移除,如果使用 conda remove 可能会发生异常,导致conda不可用 删除指定环境某个包 conda remove -n target_env_name package_name 搜索某个包信息 conda search package_name 更新anaconda conda update anaconda 更新python至最新版本 conda update python 更新所有包 conda update –all 分享环境把自己的环境分享给别人,方便他人快速建立与你一模一样的环境(同一个版本的python及各种包). 一个分享环境快速的方法就是给他人一个你要分享环境的.yml文件步骤:1) 生成欲分享环境的yml文件 conda env export &gt; environment.yml 2) 他人在自己本地使用yml文件创建文件 conda env create -f environment.yml 参考博客: https://blog.csdn.net/menc15/article/details/71477949/]]></content>
      <categories>
        <category>conda</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vuex+axios]]></title>
    <url>%2F2018%2F11%2F13%2FVuex-axios%2F</url>
    <content type="text"><![CDATA[Vuex 简介vuex是一个专门为Vue.js设计的集中式状态管理架构。 状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。 Vuex和单纯的全局对象有以下不同： 1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候， 若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。 2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的 提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化， 从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。 安装使用vuex– npm install vuex vuex的使用一 // main.js import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import vuex from &apos;vuex&apos; Vue.use(vuex) Vue.config.productionTip = false const store = new vuex.Store({ state: { show: false, } }); new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); vuex的使用二 // 为了方便维护，我们通常把在src下面新建一个store文件夹， // 然后在里面新建一个index.js import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { show: false, }, }); // 那么main.js要改成 import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; Vue.config.productionTip = false; new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); State简而言之~~state是保存我们data中需要共享的数据。 由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。 this.$store.state.count 组件中获取vuex中状态 // 创建一个组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count(){ return this.$store.state.count } } }; Getter有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。 并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。 我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被 缓存起来，只有它的依赖发生改变时，才会重新计算。 Getter会接收state作为其第一个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 } }, }); Getter也可以接收getters为第二个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 }, // 通过 this.$store.getters.my_func_count my_func_count: function (state, getters) { return getters.my_func.length } }, }); Mutatiion更改Vuex中的store中的状态的唯一方法是提交mutation。 每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。 也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。 这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数： Mutation基本使用 import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 需要通过 this.$store.commit(&apos;increment&apos;, 10) mutations: { increment (state, n) { // 变更状态 state.count += n } } }); Mutation需要遵守Vue的响应规则 既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。 这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项： – 1，最好提前在你的store中初始化好所有的所需要的属性 – 2，当对象需要添加属性时，你应该使用 – Vue.set(obj, ‘newProp’, 123) – 以新对象代替老对象 state.obj = { …state.obj, newProp: 123} axios的简单使用基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。 ## 使用npm安装axios – npm install axios -D 基本的配置// main.js import axios from &quot;axios&quot; Vue.prototype.$axios = axios // 组件中 methods: { init () { this.$axios({ method: &quot;get&quot;, url: &quot;/user&quot; }) }, }; 基本的使用get请求 test(){ this.$axios.get(this.$store.state.apiList.course,{ params: { id: 123, } }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } post请求 test(){ this.$axios.post(this.$store.state.apiList.course,{ course_title: &quot;Python&quot;, course_price: &quot;19.88&quot; }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } 发送多个并发请求 function getCourse(){ return this.$axios.get(&apos;/course/12&apos;) } function getCourse_all() { return this.$axios.get(&apos;/course&apos;) } this.$axios.all([getCourse_all(),getCourse()]) .then().catch() axios.request methods: { init(){ var that = this this.$axios.request({ url: that.$store.state.apiList.course, method: &apos;get&apos; }).then(function (data) { if (data.status === 200){ that.courseList = data.data } }).catch(function (reason) { console.log(reason) }) } },]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm+webpack+vue-cli快速上手]]></title>
    <url>%2F2018%2F11%2F13%2Fnpm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Node.js npm什么是Node.js 以及npm简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。 npm 是Node.js 的包管理工具。 npm的安装和更新Node.js下载安装 Node.js 官网下载安装。npm自带的包管理工具。 查看安装版本信息： – node -v 查看Node.js 版本信息 – npm -v 查看npm版本信息 更新npm到指定版本： – npm install npm@5.3.0 -g – npm install npm@latest -g 更新最新的稳定版本 npm 常用操作之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。 有了npm，我们管理自己的依赖包以及版本更加简单。 到自己项目目录下，进行以下命令： – npm init -y 输入-y使用默认配置项 生成package.json文件。 – npm i jquery@0.0.0 简写install 为 i 下载依赖 不写@ 默认最新版本 – npm uninstall jquery 卸载依赖包 – npm update jquery 更新依赖包 – npm list 列出已安装的依赖 – npm install webpack –D 保存为开发环境依赖 – 老版本需要 –save 参数 现在不需要了 我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。 我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。 如果我们删掉 node_modules目录，可以使用 npm i 来下载所有依赖。 npm 常用配置项当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。 在我们的package.json文件中有很多配置项 – name 项目名字 中间不能有空格只能用小写 – version 项目版本 – description 项目描述信息 – main 项目的入口文件 – scripts 指定命令的快捷方式 npm run test test是scripts里的键名 值为具体命令 – author 作者 – license 许可证 – dependencies 生成环境依赖的包以及版本信息 – devDependencies 开发环境的依赖 webpack3webpack是什么webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析， 然后将这些模块按照指定的规则生成静态资源。 那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113##安装和配置 webpack是跑在Node.js环境下的，所以确定自己有node环境。安装方式： -- npm install webpack -g 全局安装 -- webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 全局这种方式进行打包 -- npm install webpack 在自己的项目下 npm init 后在下载webpack 这就是局部安装 -- node_modules/.bin/webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 项目里要打包文件是入口文件 -- 路径太长 太烦 可以自定义命令 在package.json 文件的 scripts下面自定义## entry 和 output entry 入口文件 output 出口文件 上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~ 我们可以把命令写在webpack.config.js文件中~~&gt;webpack.config.jsmodule.export = &#123; // 所有的入口文件 entry: &#123; home: &apos;./main.js&apos;, login: &apos;./login.js&apos;, &#125;, // 出口文件 output: &#123; filename: &apos;[name].bundle.js&apos;, path: __dirname + &apos;/dist&apos;, &#125; &#125;// backage.json 下的scriptsscripts: &#123; &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;&#125;// 运行命令npm run pack# webpack4## webpack的新特性1, webpack不在单独使用，需要webpack-cli -- 全局安装 npm install webpack webpack-cli -g -D -- 局部安装 npm install webpack webpack-cli -D2, 增加了模式区分 （development, production） --webpack --mode development/production 进行模式切换 -- development 开发者模式 打包默认不压缩代码 -- production 生产者模式 上线时使用，压缩代码。 默认是这个模式3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下 -- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js4，多入口以及多出口&gt;webpack.config.js entry: &#123; // 多入口 a: &quot;./src/js/index.js&quot;, b: &quot;./src/js/index2.js&quot;,&#125;output: &#123; // 多出口 path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;./js/[name].bundle.js&apos;&#125;# vue-clivue-cli是官方提供的快速构建这个单页面应用的脚手架。## 根据官方文档中的构件流程： -- 前提是已经安装了node.js 否则npm都用不了 -- 1，使用npm全局安装vue-cli npm install -g vue-cli -- 2, 安装完成后在自己的工作空间里 vue init webpack vue-demo 输入命令后进入安装阶段，需要用户输入一些信息 这里省略了..... -- 3，切换到我们的项目目录下 cd vue-demo npm run dev## 目录结构： -- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件 -- config 配置文件，执行文件需要的配置信息 -- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下 -- node_modules 项目依赖包 -- static 静态资源 -- package.json 依赖包的json文件其实这里面命令很多~我们在后续项目中应用到再说 vue-cli配置JQuery、bootstrap第一步 下载安装 – npm install jquery – npm install bootstrap 第二步 修改build/webpack.base.conf.js const webpack = require(‘webpack’)// 在module.exports里添加插件plugins: [ new webpack.ProvidePlugin({ $: “jquery”, jQuery: “jquery”, “windows.jQuery”: “jquery”, // Popper: [‘popper.js’, ‘default’] })],// ***下面是如果手动下载bootstrap用的***resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘vue$’: ‘vue/dist/vue.esm.js’, ‘@’: resolve(‘src’), // 如果是手动下载的bootstrap需要添加这个配置 // ‘assets’: path.resolve(__dirname, ‘../src/assets’), // ‘jquery’: ‘jquery/src/jquery’ } }, 修改配置文件 第三步 修改主程序的js文件 main.js import $ from ‘jquery’import ‘bootstrap/dist/css/bootstrap.min.css’import ‘bootstrap/dist/js/bootstrap.min.js’ vue-cli 3.0第一步 下载vue-cli 3.0 – npm install -g @vue/cli – 报错 npm error 可以运行下面命令 – npm cache clean –force &amp;&amp; npm cache verify 第二步 创建项目 – vue create xxxx 之后会出现很多选项，我们可以根据自己的习惯去选择~~ 第三步 目录结构以及配置文件 – vue-cli3 目录更加简单 – 我们手动在项目根目录下创建 vue.config.js 里面写vue的配置信息 vue-cli3 配置jQuery、bootstrap – 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git上]]></title>
    <url>%2F2018%2F11%2F13%2Fgit%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[目录： 建立本地版本库 本地版本库与远程关联 修改文件并提交 创建分支,修改文件合并至master git的由来linux系统是很多开发者贡献代码不断完善的,linux的创始人linus起初管理贡献者的代码,是通过手工的方式,但随着代码的增多,很难通过手工方式去管理,于是找了一个商业的版本控制系统BitKeeper管理代码. 开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ 集中式与分布式区别- 集中式： cvs, svn 版本库集中放在中央服务器上,所有人干活时,都要先从中央服务器获取最新版本到本地,然后在本地修改,干完活后,将修改推送到中央服务器. **必须联网**才能工作. - 分布式 每个人的电脑都是一个版本库,工作的时候 **不需要联网**,直接在本地修改,提交就可以.你和同事同时修改一个文件A,修改完成后互相将自己修改的文件推送给对方即可. **安全性高**, 每个人的本地都有一个完整的版本库,某个人的电脑突然崩溃,从其他人那直接copy一份就可以了. 但集中式版本控制系统,一旦中央服务器垮掉,版本库信息就都丢失了. 创建版本库,添加文件命令: - 创建版本库 mkdir studyGit git init - 添加文件 vim readme.txt git add readme.txt git commit -m &quot;注释说明,方便自己或他人查看&quot; 修改文件并提交命令: - vim 编辑修改文件内容 - git status 查看当前仓库状态 - git diff filename 查看文件具体改动内容 - 提交: git add filename git commit -m &quot;本次提交注释说明&quot; 版本回退Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向至你切换的版本. 命令: - 回退到上一个版本 git reset --hard HEAD^ - 回退到上上版本 git reset --hard HEAD^^ - 回退到指定版本 git log 查看你要切换版本的commit id 或 git log --pretty=oneline git reset --hard target_commit_id - 回退之后后悔了,想切换到回退前的版本 1) 通过git log是找不到回退前那次提交的日志的,没办法指定commit id回退切换 2) 通过git reflog查看, git reflog是记录我们的历史命令的,找到你那次提交历史命令前的commit id,即可切换回去 工作区和暂存区工作区: 电脑上直接看到的,你管理的文件夹(使用git init创建的),就是工作区 暂存区: 在工作区下,隐藏的.git文件夹,其中有很多文件,有几个重要的要理解: - 暂存区: stage - 版本信息(master分支) - HEAD指针,指向具体分支 提交工作区的文件修改或新增文件: 1) git add files -&gt; 实际将这些修改先推送到本地暂存区(暂存区中存放了所有待提交的文件) 2) git commit -m &quot;说明&quot; -&gt; 提交暂存区中的所有文件至master或分支版本 管理修改工作区中readme.txt文件 1) 第一次修改, 增加一行内容, git add readme.txt 2) 第二次修改, 又增加了一行内容, 但未执行 git add readme.txt 3) git commit -m &quot;注释&quot;; 那么此次提交的只是第一次修改的内容 git diff HEAD -- readme.txt 查看工作区中与版本库中的不同之处 撤销修改1) 工作区修改,改乱了,还没有提交至暂存区; 可以通过 git checkout -- filename 恢复至与版本库一致的状态 2) 工作区修改,改乱了,但之前已提交至暂存区,撤销修改: git reset HEAD filename 把暂存区的修改撤销掉(unstage) git checkout -- filename 恢复工作区与版本库一致 删除文件git rm filename git commit -m &quot;delete file filename&quot; 远程仓库关联1) 创建ssh key: ssh-keygen -t rsa -C &quot;youremail@example.com&quot; # 一路回车即可 在用户主目录里会生成一个.ssh文件夹,里面有id_rsa和id_rsa.pub, id_rsa是私钥, id_rsa.pub是公钥; 登录github,进入个人账户settings页面,选择ssh key -&gt; add new; 添加, 将id_rsa.pub复制到页面中,完成. 2) 添加远程仓库 - 在github网站新增仓库,与本地要关联的仓库同名 - 进入本地仓库所在的目录, git remote add origin &lt;新增的远程仓库地址&gt; - git push -u origin master # 将本地仓库的master分支推送到远程服务器上,后续提交可以省略参数-u(远程初始仓库为空,所以加-u) - 本地修改文件,提交; 推送至远程 克隆远程仓库进入你想保存仓库的路径,然后执行: git clone &lt;远程仓库地址&gt; 创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突1) 在分支上修改了文件,并commit 2) 在mster上修改了文件,并commit 3) git merge &lt;ranchname&gt;; 报错, 无法实现快速合并, 需先解决冲突, 把冲突文件改成自己想要的内容, 然后 git add filename, git commit -m &quot;注释&quot;.]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue总结]]></title>
    <url>%2F2018%2F11%2F13%2FVue%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue总结 MVC Model View Controller MVVM Model View ViweMode ES6常用语法1.1 变量的提升 1.2 模板字符串 ``${} 1.3 数据的解构 1.4 类 class extends constructor super 1.5 函数 1.5.1 注意this和普通函数的区别 1.6 箭头函数 1.7 单体模式 1.8 import export export default Vue常用指令2.1 v-text innerText 2.2 v-html innerHtml 2.3 v-for :key 2.4 v-if v-else-if v-else appendChild 2.5 v-show display 2.6 v-on @xxxx=&quot;自己处理的方法&quot; 2.7 v-bind :属性名称=“属性的值” 2.8 v-model 2.8.1 input 2.8.2 textarea 2.8.3 select 2.9 指令修饰符 2.9.1 .lazy 2.9.2 .number 2.9.3 .trim 2.10 计算属性 2.10.1 放入缓存 2.10.2 只有数据改变的时候才会重新计算 2.11 数据监听 2.11.1 注意可变类型和不可变 2.11.2 深监听 deep=true 2.12 获取DOM 2.12.1 给便签绑定ref属性 ref=“属性值” 2.12.2 this.$refs.属性值 2.13 自定义指令 2.13.1 vue.directive(“指令名称”, function(el, binding){ el 绑定指令的便签元素 binding 指令的所有信息 }) 注意事项3.1 数据监听 3.1.1 改变数据 直接赋值 3.1.2 改变数组长度 能够被监听到，新值和旧值一样 3.1.3 改变数组内的值 app = new vue({}) app.$set(this.hobby, 0, &apos;抽烟&apos;) $set()修改数组中的值可以监听 $delete() Vue的组件组件的注册全局注册Vue.compontent(“组件名称”, {}) 局部注册const = app = new Vue({ el: &apos;#app&apos;, components: { 组件的名称: 组件的配置信息 } }) 子组件的注册在父组件中注册components ## 注意写组件标签 ## 每个组件的template只识别一个作用域块 通信父子的通信在父组件中给子组件绑定属性 子组件通过props=[&quot;属性名称&quot;] 子父的通信子组件先提交事件 this.$emit(&quot;事件名称&quot;, 值) 在父组件中给子组件绑定事件 &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt; 非父子的通信其中一个组件向中间调度器提交事件 另一个组件监听中间调度器的事件 注意this的问题 中间调度器 let temp = new Vue(); temp.$emit(&quot;say&quot;, value) // 事件名称和值 mounted(){ that = this // 监听中间调度器中的方法 temp.$on(&quot;say&quot;, function(data){ // 这里的this是temp的this that.xxx = data // 这样改值 }) } 插槽&lt;slot&gt;&lt;/slot&gt; 命名的插槽 混合代码重用的 mixins = [base] Vue的生命周期vue生命周期之beforeCreate实例创建之前除标签外，所有的vue需要的数据，事件都不存在 vue生命周期之created实例创建之后，data和事件已经被解析到，el还没有找到 vue生命周期之beforeMount开始找标签，数据还没有被渲染，事件也没有被监听 vue生命周期之mounted开始渲染数据，开始监听事件 vue生命周期之beforeUpdata数据已经被修改在虚拟DOM，但没有被渲染到页面上 vue生命周期之updata开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改 vue生命周期之beforeDestory所有的数据都存在 vue生命周期之destoryed所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了 &lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签 用activated和deactivated取代了beforeUpdate和destory的执行 最常用的钩子beforeMount mounted 路由注册let url = [ { path: &apos;/&apos;, name: &quot;home&quot;, component: { template: ``, } } ] let router = nwe VueRouter({ routes: url }) const app = new Vue({ el: &apos;app&apos;, router: router, }) &lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt; &lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 子路由children: [ {} ] append 在父路由对应的组件的template里面写router-link router-view 路由的命名name 注意to加冒号动态绑定 路由的参数{ path: &quot;/course/:id&quot;, } this.$route.params.id this.$route.query.xxx $route 是一个对象 存放当前路由的所有信息 $router VueRouter实例化对象 手动路由this.$router.push(&apos;/&apos;) this.$router.push({name:&quot;home&quot;}) 重定向redirect: {name: &apos;xxx&apos;, params: {key: value}} 路由的钩子router.beforeEach(function(to, from next){ // to 你要去哪 // from 你要从哪里来 // next() 你要去做什么 参数可以给路径 必须有，没有就不走 }) router.afterEach(function(to, from){ // to 你要去哪 // from 你从哪里来 }) to和from都是$route对象 路由的所有信息  node.js + npm + webpack + vue-cli(自带webpack)node.js / npm - npm 管理工作目录 npm init -y - 下载包 npm i xxx@0.0.0 - 卸载 npm uninstall xxx - 更新 npm updata xxx webpack 4 - 下载 npm i webpack webpack-cli - 打包 webpack --mode development/production - 打包默认的入口文件 src目录下的index.js - 出口文件 dist目录的main.js wue-cli 2 - 帮助我们快速搭建项目的脚手架工具 - 下载 npm i vue-cli - 用vue-cli帮助我们创建项目 vue init webpack xxxx(项目名称) - 启动项目 cd xxxx(项目名称) npm run dev - 打吧包 npm run build Vuex和axiosVuex存放一些公共的东西,是一个仓库 安装 npm i vuex 配置 导入 import vuex from &quot;vuex&quot; vue使用vuex vue.use(vuex) 实例化仓库 new vuex.Store({ state: {}, getters: {}, mutations: {} }) new Vue({ el: &apos;#app&apos;, store, }) 获取残仓库数据 this.$store.state.xxx this.$store.getters.xxx 改变仓库中的数据 组件向仓库提交修改事件 this.$store.commit(&quot;事件名称&quot;, data) 在仓库中的mutations中 mutations: { &quot;事件名称&quot;: function(state, data){ 修改state中的数据 } } 注意计算属性 仓库中的数据建议都放在计算属性中 axios向后端服务器发送请求 实现ajax技术的工具 配置 下载 npm i axios 导入 import axios from “axios” 在vue的原型链中加入方法 Vue.prototype.#axios = axios 发送请求 this.$axios.request({ url: &apos;&apos;, method: &apos;&apos;, }).then(function(){ }).catch(function(){ }) 前后端的接通后端设计一个接口 前端通过axios发送请求拿到数据 跨域问题 element-ui按照文档安装，并研究如何使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue组件系统]]></title>
    <url>%2F2018%2F10%2F14%2Fvue%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Vue组件系统之全局组件的注册 123456789101112131415161718192021222324252627&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; // template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&lt;/script&gt;&gt; 12345678910111213141516171819202122232425262728&gt;&lt;div id='app'&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册组件&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素，包在app这个div中&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; // 根元素会替换div&gt; template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&lt;/script&gt;&gt; 全局组件 12345678910111213141516171819202122232425262728&gt;// 总结&gt;Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素，包在app这个div中&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;,&gt; computed: &#123;&#125;,&gt; watch: &#123;&#125;,&gt; methods: &#123;&#125;,&gt; &#125;&gt; &#125;&gt; );&gt;&gt;new Vue(&#123;&gt; el: '#app',&gt; // 根元素会替换div&gt; template: `&lt;global-component&gt;&lt;/global-component&gt;`&gt; &#125;)&gt;&gt;// data 必须是函数&gt;// 没有属性&gt; 组件系统之组件的复用 1234567891011121314151617181920212223242526272829&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt; &lt;global-component&gt;&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册&gt; Vue.component(&gt; // 第一个是组件名称 第二个object&gt; "global-component", &#123;&gt; // 组件内容 抱一个div-单个根元素&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; // data必须是函数&gt; data()&#123;&gt; // return中写数据&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &gt; &#125;)&gt;&lt;/script&gt;&gt; 组价系统之局部组件的注册 12345678910111213141516171819202122232425&gt;&lt;div id='app'&gt;&gt; &lt;app-header&gt;&lt;/app-header&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; &#125;;&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; template: `&lt;app-header&gt;&lt;/app-header&gt;`,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&lt;div id='app'&gt;&gt; &lt;!--&lt;App&gt;&lt;/App&gt;--&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 在入口组件中注册写的局部组件&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;app-header&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&#125;,&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; 局部组件 1234567891011121314151617181920212223242526&gt;- 总结&gt;&gt;创建组件&gt; 创建局部组件，起始就是创建一个JavaScript object&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; computed: &#123;&#125;,&gt; &#125;;&gt;注册组件&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; template: `&lt;app-header&gt;&lt;/app-header&gt;`,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;&gt; &#125;)&gt;&gt;组件可以嵌套使用&gt;&gt; Vue组件系统之父子组件的通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;&lt;div id='app'&gt;&gt; &gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 子&gt; let Header = &#123;&gt; template: `&lt;div&gt;&lt;h3&gt;&#123;&#123; db &#125;&#125;&lt;/h3&gt;&lt;h3&gt;&#123;&#123; fData &#125;&#125;&lt;/h3&gt;&lt;&lt;/div&gt;`,&gt; data()&#123;&gt; return &#123;&gt; db: 'hello',&gt; &#125;&gt; &#125;,&gt; // 接收父亲传来的数据&gt; props:['fData'],&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 在入口组件中注册写的局部组件&gt; // 父&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;app-header v-bind:fData="fatherData"&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&gt; return &#123;fatherData: 0,&#125;&gt; &#125;,&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt;&lt;/script&gt;&gt; Vue组件系统之子父组件的通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&gt;&lt;div id='app'&gt;&gt;&lt;/dic&gt;&gt;&gt;&lt;script&gt;&gt; // 子&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='sonClick'&gt;点击改变字体大小&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; methods: &#123;&gt; sonClick: function()&#123;&gt; // 儿子的的行为传给父亲&gt; this.$emit("change-size", 0.1)&gt; &#125; &gt; &#125;,&gt; computed: &#123;&#125;,&gt; // ...&gt; &#125;;&gt; // 父&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;span :style="&#123; fontSize: postFontSize + 'em' &#125;"&gt;我是字体&lt;/span&gt;&gt; &lt;app-header v-on:change-size="fatherClick"&gt;&lt;/app-header&gt;&gt; &lt;/div&gt;&gt; `,&gt; components: &#123;&gt; 'app-header': Header&gt; &#125;,&gt; // 组件的私有数据&gt; data()&#123;&gt; return &#123;&gt; postFontSize: 1,&gt; &#125;&gt; &#125;,&gt; methods: &#123;&gt; // 自己定义的change-size事件，一直在监听，等着儿子传来的信息&gt; fatherClick: function(value)&#123;&gt; this.postFontSize += value;&gt; &#125;&gt; &#125;&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; // 作为根被渲染&gt; template: `&lt;App&gt;&lt;/App&gt;`,&gt; components: &#123;&gt; // App:App,&gt; App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; Vue组件系统之混入（mixin） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&lt;div id='app'&gt;&gt;&lt;/dic&gt;&gt; &lt;my-header&gt;&lt;/my-header&gt;&gt; &lt;p&gt;&lt;/p&gt;&gt; &lt;my-app&gt;&lt;/my-app&gt;&gt;&lt;script&gt;&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='show('xxx')'&gt;点击显示xxx来了&lt;/button&gt;&gt; &lt;button @click='hide('xxx')'&gt;点击显示xxx去了&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; methods: &#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;,&gt; &#125;;&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;button @mouseenter='show('000')'&gt;点击显示000来了&lt;/button&gt;&gt; &lt;button @mouseleve='hide('000')'&gt;点击显示000去了&lt;/button&gt;&gt; &lt;/div&gt;&gt; `,&gt; methods: &#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; components: &#123;&gt; "my-header": Header,&gt; "my-app": App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&lt;div id='app'&gt;&gt; &lt;my-header&gt;&lt;/my-header&gt;&gt; &lt;p&gt;&lt;/p&gt;&gt; &lt;my-app&gt;&lt;/my-app&gt;&gt;&lt;/dic&gt;&gt;&gt;&lt;script&gt;&gt; let mixs = &#123;&gt; methods:&#123;&gt; show: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; hide: function(name)&#123;&gt; console.log(name+'来了');&gt; &#125;,&gt; &#125;&gt; &#125;&gt; let Header = &#123;&gt; template: `&lt;div&gt; &gt; &lt;button @click='show('xxx')'&gt;点击显示xxx来了&lt;/button&gt;&gt; &lt;button @click='hide('xxx')'&gt;点击显示xxx去了&lt;/button&gt;&gt; &lt;/div&gt;`,&gt; mixins: [mixs],&gt; &#125;;&gt; let App = &#123;&gt; template: `&gt; &lt;div&gt;&gt; &lt;button @mouseenter='show("000")'&gt;点击显示000来了&lt;/button&gt;&gt; &lt;button @mouseleve='hide("000")'&gt;点击显示000去了&lt;/button&gt;&gt; &lt;/div&gt;&gt; `,&gt; mixins: [mixs],&gt; &#125;;&gt; // 根实例&gt; new Vue(&#123;&gt; el: '#app',&gt; components: &#123;&gt; "my-header": Header,&gt; "my-app": App,&gt; &#125;&gt; &#125;)&gt; &gt;&lt;/script&gt;&gt; Vue组件系统之插槽 123456789101112131415161718192021222324252627&gt;- 内容分发&gt;&lt;style&gt;&gt; .box &#123;&gt; width: 50px;&gt; height: 50px;&gt; float: left;&gt; &#125;&gt;&lt;/style&gt;&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;首页&lt;/global-component&gt;&gt; &lt;global-component&gt;免费&lt;/global-component&gt;&gt; &lt;global-component&gt;收费&lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册全局组件&gt; Vue.component(&gt; "global-component", &#123;&gt; template: `&lt;div class="box"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`,&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &#125;)&gt;&lt;/script&gt;&gt; Vue组件系统之具名插槽 1234567891011121314151617181920212223242526272829303132&gt;&lt;style&gt;&gt; .box &#123;&gt; width: 50px;&gt; height: 50px;&gt; float: left;&gt; &#125;&gt;&lt;/style&gt;&gt;&lt;div id='app'&gt;&gt; &lt;global-component&gt;&gt; &lt;div slot='home'&gt;首页&lt;/div&gt;&gt; &lt;div slot='free'&gt;免费&lt;/div&gt;&gt; &lt;div slot='toll'&gt;收费&lt;/div&gt;&gt; &lt;/global-component&gt;&gt;&lt;/div&gt;&gt; &gt;&lt;script&gt;&gt; // 注册全局组件&gt; Vue.component(&gt; "global-component", &#123;&gt; template: `&lt;div class="box"&gt;&gt; &lt;slot name="home"&gt;&lt;/slot&gt;&gt; &lt;slot name="free"&gt;&lt;/slot&gt;&gt; &lt;slot name="toll"&gt;&lt;/slot&gt;&gt; &lt;/div&gt;`,&gt; &#125;&gt; );&gt; &gt; new Vue(&#123;&gt; el: '#app',&gt; &#125;)&gt;&lt;/script&gt;&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[权限管理的三级菜单的流程]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[权限管理的三级菜单的流程 权限控制 url代表了权限 表结构（6张表，ORM创建4个类，两个many2many会自动再生成两张表） 1234567891011121314151617181920&gt; 用户表&gt; 用户名&gt; 密码&gt; 多对多 roles(角色)&gt; 角色表&gt; 标题 title&gt; 多对多 permission(权限)&gt; 权限表&gt; 标题 title&gt; 权限 url&gt; URL别名 name - 设置唯一(方便为了将权限粒度控制到按钮级别)&gt; 外键 menu(菜单)&gt; 外键 permission(self自己)&gt; 菜单表&gt; 标题 title&gt; 图标 icon&gt; 权重 weight&gt; 用户和角色关系表&gt; 角色和权限的关系表&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt; &gt;from django.db import models&gt; &gt;&gt; &gt;&gt; &gt;class Menu(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 一级菜单&gt; &gt; &quot;&quot;&quot;&gt; &gt; title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;, unique=True) # 一级菜单的名字&gt; &gt; icon = models.CharField(max_length=32, verbose_name=&apos;图标&apos;, null=True, blank=True)&gt; &gt; weight = models.IntegerField(verbose_name=&apos;权重&apos;, default=1)&gt; &gt;&gt; &gt; class Meta:&gt; &gt; verbose_name_plural = &apos;菜单表&apos;&gt; &gt; verbose_name = &apos;菜单表&apos;&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.title&gt; &gt;&gt; &gt;&gt; &gt;class Permission(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 权限表&gt; &gt; 有关联Menu的二级菜单&gt; &gt; 没有关联Menu的不是二级菜单，是不可以做菜单的权限&gt; &gt; &quot;&quot;&quot;&gt; &gt; title = models.CharField(max_length=32, verbose_name=&apos;标题&apos;)&gt; &gt; url = models.CharField(max_length=32, verbose_name=&apos;权限&apos;)&gt; &gt; menu = models.ForeignKey(&apos;Menu&apos;, null=True, blank=True, verbose_name=&apos;菜单&apos;)&gt; &gt; # 该权限关联的其他权限是否也是在当前url上展示&gt; &gt; parent = models.ForeignKey(to=&apos;Permission&apos;, null=True, blank=True, verbose_name=&apos;父权限&apos;)&gt; &gt;&gt; &gt; name = models.CharField(max_length=32, null=True, blank=True, unique=True, verbose_name=&apos;权限的别名&apos;)&gt; &gt;&gt; &gt; class Meta:&gt; &gt; verbose_name_plural = &apos;权限表&apos;&gt; &gt; verbose_name = &apos;权限表&apos;&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.title&gt; &gt;&gt; &gt;&gt; &gt;class Role(models.Model):&gt; &gt; name = models.CharField(max_length=32, verbose_name=&apos;角色名称&apos;)&gt; &gt; permissions = models.ManyToManyField(to=&apos;Permission&apos;, verbose_name=&apos;角色所拥有的权限&apos;, blank=True)&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.name&gt; &gt;&gt; &gt;&gt; &gt;class User(models.Model):&gt; &gt; &quot;&quot;&quot;&gt; &gt; 用户表&gt; &gt; &quot;&quot;&quot;&gt; &gt; name = models.CharField(max_length=32, verbose_name=&apos;用户名&apos;)&gt; &gt; password = models.CharField(max_length=32, verbose_name=&apos;密码&apos;)&gt; &gt; roles = models.ManyToManyField(to=&apos;Role&apos;, verbose_name=&apos;用户所拥有的角色&apos;, blank=True)&gt; &gt;&gt; &gt; def __str__(self):&gt; &gt; return self.name&gt; &gt;&gt; &gt; 流程梳理 12345678910111213&gt; - 当一个url回车发出这个请求后，给到server端先判断这个请求url是不是有访问的权限&gt; 这个时候我们设置了白名单(在中间件这里(因为一开始就要判断身份))，如果是白名单&gt; 谁都可以访问&gt; eg：&gt; PERMISSION_SESSION_KEY = &apos;permissions&apos;&gt; MENU_SESSION_KEY = &apos;menus&apos;&gt; WHITE_URL_LIST = [&gt; r&apos;^/login/$&apos;,&gt; r&apos;^/logout/$&apos;,&gt; r&apos;^/reg/$&apos;,&gt; r&apos;^/admin/.*&apos;,&gt; ]&gt; 123&gt; - 这时用户登录，如果登录成功&gt; 不同的用户对应不同的权限，也就是可以访问不同的url&gt; 1234567891011121314151617181920212223242526272829303132&gt; - 登录成功，(权限信息的初始化)&gt; 我们该做的就是拿到这个用户对应的权限信息 - ORM(用户信息-角色-权限-菜单)&gt; # user = models.User.objects.filter(name=username, password=pwd).first()&gt; permission_query = user.roles.filter(permissions__url__isnull=False).values(&gt; &apos;permissions__url&apos;, # 权限url&gt; &apos;permissions__title&apos;, # 权限的标题&gt; &apos;permissions__id&apos;, # 权限的id&gt; &apos;permissions__name&apos;, # 权限的别名&gt; &apos;permissions__parent_id&apos;, # 此权限对应的父权限的id&gt; &apos;permissions__parent__name&apos;, # 次权限对应的父权限的别名&gt; &apos;permissions__menu_id&apos;, # 此权限对应的菜单id&gt; &apos;permissions__menu__title&apos;, # 此权限对应的菜单标题&gt; &apos;permissions__menu__icon&apos;, # 此权限对应的菜单的图标&gt; &apos;permissions__menu__weight&apos;, # 表单排序用的&gt; ).distinct()&gt; 数据结构(字典)&gt; permission_dict来存储此权限信息&gt; menu_dict来存储菜单信息&gt; permission_dict = &#123;&gt; &apos;URL的别名&apos;：&#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&apos;pid&apos;,&apos;pname&apos; &#125;&gt; &#125;&gt; menu_list = &#123;&gt; &apos;菜单ID&apos;：&#123;&gt; &apos;title&apos;: 一级菜单的标题，&gt; &apos;icon&apos;: 一级菜单的图标，&gt; &apos;weight&apos;: 权重，&gt; &apos;children&apos;: [&gt; &#123;&apos;url&apos;,&apos;title&apos;,&apos;id&apos;,&#125;&gt; ]&gt; &#125;&gt; &#125;&gt; 123456789&gt; 权限信息存的就是：&gt; 当前这个权限的是谁，他的id多少，他的标题是什么，他的父权限是谁(id)，他的父权限的别名是什么&gt; 菜单信息存的就是：&gt; 这个权限(url)对应的菜单的标题是什么，菜单的图标是什么，权重是多少，他对应的二级菜单是哪些&gt; 二级菜单(children)也就是，对应的权限信息&gt; 这里面存的也就是他的权限信息(他的title，url，id，parent_id)&gt; 将所有的权限遍历一遍后，将这些信息存入session中&gt; 为什么存入session，是因为session可以配置(放入缓存，访问次数比较多，所有存到缓存比较好)&gt; 123456789101112131415161718192021222324252627282930313233343536&gt; # 遍历此用户对应的权限信息&gt; for item in permission_query:&gt; # 首先是权限信息，以权限的别名为键&gt; permission_dict[item[&apos;permissions__name&apos;]] = (&#123;&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &apos;parent_name&apos;: item[&apos;permissions__parent__name&apos;],&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &#125;)&gt; menu_id = item.get(&apos;permissions__menu_id&apos;)&gt; if not menu_id:&gt; continue&gt; if menu_id not in menu_dict:&gt; menu_dict[menu_id] = &#123;&gt; &apos;title&apos;: item[&apos;permissions__menu__title&apos;],&gt; &apos;icon&apos;: item[&apos;permissions__menu__icon&apos;],&gt; &apos;weight&apos;: item[&apos;permissions__menu__weight&apos;],&gt; &apos;children&apos;: [&gt; &#123;&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &#125;&gt; ]&gt; &#125;&gt; else:&gt; menu_dict[menu_id][&apos;children&apos;].append(&gt; &#123;&gt; &apos;title&apos;: item[&apos;permissions__title&apos;],&gt; &apos;url&apos;: item[&apos;permissions__url&apos;],&gt; &apos;id&apos;: item[&apos;permissions__id&apos;],&gt; &apos;parent_id&apos;: item[&apos;permissions__parent_id&apos;],&gt; &#125;)&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; - 登录成功后，信息存入session后，这时给服务器发送一个请求，这时就会走中间件进行权限的校验&gt; &gt; - 走中间件process_request(self, request):&gt; - 先获取这个请求的url request.path_info&gt; 刚开始也先判断白名单， 白名单不符合从session中获取这个用户存的权限信息&gt; permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)&gt; - 导航栏可以存这里 - 写了一个inclution_tag来处理&gt; request.breadcrumd_list = [&gt; &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,&gt; ]&gt; @register.inclusion_tag(&apos;rbac/breadcrumbs.html&apos;)&gt; def breadcrumb(request):&gt; return &#123;&quot;breadcrumd_list&quot;: request.breadcrumd_list&#125;&gt; - 遍历这个权限信息&gt; 可以通过正则匹配，匹配他是不是该用户的权限&gt; 如果匹配成功看他是否由parent_id有是子权限没有是父权限&gt; &gt; if parent_id:&gt; # 表示当前权限是子权限，让父权限是展开&gt; request.current_menu_id = parent_id&gt; request.breadcrumd_list.extend([&gt; &#123;&gt; &quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],&gt; &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]&gt; &#125;,&gt; &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,&gt; ])&gt; else:&gt; # 表示当前权限是父权限，要展开的二级菜单&gt; request.current_menu_id = id&gt; # 添加面包屑导航&gt; request.breadcrumd_list.append(&#123;&gt; &quot;title&quot;: item[&apos;title&apos;], &gt; &apos;url&apos;: item[&apos;url&apos;]&gt; &#125;)&gt; &gt; - request.current_menu_id&gt; 这个就是用来展示菜单和展示该权限的子权限为了选中同一个二级菜单的时候用的&gt; -写一个includtion_tag&gt; - &gt; @register.inclusion_tag(&apos;rbac/menu.html&apos;)&gt; def menu(request):&gt; menu_list = request.session.get(settings.MENU_SESSION_KEY)&gt; order_dict = OrderedDict()&gt; for key in sorted(menu_list, key=lambda x: menu_list[x][&apos;weight&apos;], reverse=True):&gt; order_dict[key] = menu_list[key]&gt; item = order_dict[key]&gt; item[&apos;class&apos;] = &apos;hide&apos;&gt; &gt; for i in item[&apos;children&apos;]:&gt; &gt; if i[&apos;id&apos;] == request.current_menu_id:&gt; i[&apos;class&apos;] = &apos;active&apos;&gt; item[&apos;class&apos;] = &apos;&apos;&gt; return &#123;&quot;menu_list&quot;: order_dict&#125;&gt; &gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; from django.utils.deprecation import MiddlewareMixin&gt; from django.conf import settings&gt; from django.shortcuts import HttpResponse&gt; import re&gt; &gt; &gt; class PermissionMiddleware(MiddlewareMixin):&gt; def process_request(self, request):&gt; # 对权限进行校验&gt; # 1. 当前访问的URL&gt; current_url = request.path_info&gt; &gt; # 白名单的判断&gt; for i in settings.WHITE_URL_LIST:&gt; if re.match(i, current_url):&gt; return&gt; &gt; # 2. 获取当前用户的所有权限信息&gt; &gt; permission_dict = request.session.get(settings.PERMISSION_SESSION_KEY)&gt; &gt; request.breadcrumd_list = [&gt; &#123;&quot;title&quot;: &apos;首页&apos;, &apos;url&apos;: &apos;#&apos;&#125;,&gt; ]&gt; &gt; # 3. 权限的校验&gt; print(current_url)&gt; &gt; for item in permission_dict.values():&gt; print(permission_dict)&gt; url = item[&apos;url&apos;]&gt; if re.match(&quot;^&#123;&#125;$&quot;.format(url), current_url):&gt; parent_id = item[&apos;parent_id&apos;]&gt; id = item[&apos;id&apos;]&gt; parent_name = item[&apos;parent_name&apos;]&gt; if parent_id:&gt; # 表示当前权限是子权限，让父权限是展开&gt; request.current_menu_id = parent_id&gt; request.breadcrumd_list.extend([&gt; &#123;&quot;title&quot;: permission_dict[parent_name][&apos;title&apos;],&gt; &apos;url&apos;: permission_dict[parent_name][&apos;url&apos;]&#125;,&gt; &#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;,&gt; ])&gt; else:&gt; # 表示当前权限是父权限，要展开的二级菜单&gt; request.current_menu_id = id&gt; # 添加面包屑导航&gt; request.breadcrumd_list.append(&#123;&quot;title&quot;: item[&apos;title&apos;], &apos;url&apos;: item[&apos;url&apos;]&#125;)&gt; return&gt; else:&gt; return HttpResponse(&apos;没有权限&apos;)&gt; &gt; 123456789&gt; - 权限力度控制到按钮级别&gt; 一个filter&gt; 一个url的反向解析&gt; @register.filter&gt; def has_permission(request, permission):&gt; # session中存的就是权限的别名，别名就是反向解析的那个字符串&gt; if permission in request.session.get(settings.PERMISSION_SESSION_KEY):&gt; return True&gt; 12345678910&gt; &#123;% if request|has_permission:&apos;web:customer_edit&apos; or request|has_permission:&apos;web:customer_del&apos; %&#125;&gt; &lt;td&gt;&gt; &#123;% if request|has_permission:&apos;web:customer_edit&apos; %&#125;&gt; &lt;a style=&quot;color: #333333;&quot; href=&quot;&#123;% url &apos;web:customer_edit&apos; row.id %&#125;&quot;&gt;&gt; &lt;i class=&quot;fa fa-edit&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; &#123;% if request|has_permission:&apos;web:customer_del&apos; %&#125;&gt; &lt;a style=&quot;color: #d9534f;&quot; href=&quot;&#123;% url &apos;web:customer_del&apos; row.id %&#125;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot;&gt;&lt;/i&gt;&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; 菜单和权限的展示在一个页面 123456789101112131415161718192021222324252627282930313233343536&gt;# 菜单和权限的展示&gt;# 点击每一个菜单出现对应的权限信息&gt;def menu_list(request):&gt; all_menu = models.Menu.objects.all()&gt; # 拿到菜单对应的菜单id&gt; mid = request.GET.get('mid')&gt; # 如果拿到菜单id代表着有子权限&gt; if mid:&gt; # 从子权限出发 拿到 父权限对应的菜单id对应的权限 或者 菜单对应的权限（也就是二级菜单） 因为自己关联自己（从父亲和儿子两方面出发）&gt; permission_query = models.Permission.objects.filter(Q(menu_id=mid) | Q(parent__menu_id=mid))&gt; # 如果没有菜单id则输出所有的权限信息&gt; else:&gt; permission_query = models.Permission.objects.all()&gt; # 拿到查询出的权限对应的信息&gt; all_permission = permission_query.values('id', 'url', 'title', 'name', 'menu_id', 'parent_id', 'menu__title')&gt; all_permission_dict = &#123;&#125;&gt; for item in all_permission:&gt; menu_id = item.get('menu_id')&gt; # 找到有菜单id的权限，将其存入字典，键为权限的id&gt; if menu_id:&gt; all_permission_dict[item['id']] = item&gt; # 可以改都是引用&gt; # 得到所有有菜单的权限后，将每一个权限都设置一个children键值对，用来存储子权限信息&gt; item['children'] = []&gt; for item in all_permission:&gt; pid = item.get('parent_id')&gt; # 如果有父id代表的是子权限&gt; if pid:&gt; # 如果是子权限，就将子权限的信息存入多上一步做的处理（有菜单的父权限）children中&gt; all_permission_dict[pid]['children'].append(item)&gt; return render(request, 'rbac/menu_list.html', &#123;&gt; "mid": mid,&gt; "all_menu": all_menu,&gt; "all_permission_dict": all_permission_dict,&gt; &#125;)&gt; 权限系统的应用 拷贝rbac App到新项目中 注册APP 以及配置信息 12345678910&gt; # ###### 权限相关的配置 ######&gt; PERMISSION_SESSION_KEY = &apos;permissions&apos;&gt; MENU_SESSION_KEY = &apos;menus&apos;&gt; WHITE_URL_LIST = [&gt; r&apos;^/login/$&apos;,&gt; r&apos;^/logout/$&apos;,&gt; r&apos;^/reg/$&apos;,&gt; r&apos;^/admin/.*&apos;,&gt; ]&gt; 数据库迁移命令 删除rbac所有的迁移文件 执行两条命令 路由相关 url(r’rbac/‘,include(‘rbac.urls’,namespace=’rbac’)) 给所有的URL起名字 layout 模板注意 block css js content 权限的管理 添加角色 添加菜单 添加权限 分配权限 用户关联—修改原系统的用户表 跟rbac的UserInfouser = models.OneToOneField(UserInfo,null=True,blank=True) 给用户分角色 给角色分权限 登录应用权限 登录成功后 12345&gt; auth.login(request, obj)&gt; ret = init_permission(request, obj)&gt; if ret:&gt; return ret&gt; 初始化权限信息init_permission函数中修改 user -&gt; user.user permission_query = user.user.roles.filter 应用权限校验中间件 12&gt; &apos;rbac.middleware.rbac.PermissionMiddleware&apos;,&gt; 应用左侧菜单和面包屑导航 在layout模板中，引用CSS和JS 二级菜单 123&gt; &#123;% load rbac %&#125;&gt; &#123;% menu request %&#125;&gt; 应用路径导航 12&gt; &#123;% breadcrumb request %&#125;&gt; 权限控制到按钮级别 12345678&gt; &#123;% load rbac %&#125;&gt; 判断 filter 判断里面只能用filter 只能一个一个判断&gt; &#123;% load rbac %&#125;&gt; &gt; &#123;% if request|has_permission:&apos;add_customer&apos; %&#125;&gt; &lt;a href=&quot;&#123;% url &apos;add_customer&apos; %&#125;?&#123;&#123; query_params &#125;&#125;&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;添加&lt;/a&gt;&gt; &#123;% endif %&#125;&gt; 使用注意事项 用户注册后 对应在rbac中的UserInfo创建用户 和 原系统的用户做一对一关联 菜单 父权限 子权限 的层级关系]]></content>
      <categories>
        <category>RBAC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django之中间件]]></title>
    <url>%2F2018%2F07%2F15%2FDjango%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[中间件 中间件的概念 中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局 上改变django的输入与输出。因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。 Django的中间件的定义： Middleware is` `a framework of hooks into Django’s request/response processing. &lt;br&gt;It’s a light, low-level “plugin” systemforglobally altering Django’s input or output. 应用： 如果想修改请求，例如被传送到view中的HttpRequest对象。 或者想修改view返回的HttpResponse对象，这些都可以通过中间件来实现。 可能还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。 我们可能频繁在view使用request.user吧。 Django想在每个view执行之前把user设置request 的属性，于是就用了一个中间件来实现这个目标。所以Django提供了可以修改request 对象的中间 件 AuthenticationMiddleware。 Django默认的Middleware： 12345678910&gt; MIDDLEWARE = [&gt; 'django.middleware.security.SecurityMiddleware',&gt; 'django.contrib.sessions.middleware.SessionMiddleware',&gt; 'django.middleware.common.CommonMiddleware',&gt; 'django.middleware.csrf.CsrfViewMiddleware',&gt; 'django.contrib.auth.middleware.AuthenticationMiddleware',&gt; 'django.contrib.messages.middleware.MessageMiddleware',&gt; 'django.middleware.clickjacking.XFrameOptionsMiddleware',&gt; ]&gt; 每一个中间件都有具体的功能 自定义中间件 中间件一共有四种方法 12345678&gt; # process_request&gt; &gt; # process_view&gt; &gt; # process_exception&gt; &gt; # process_response&gt; process_request,process_response 当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。 我们也可以自己定义一个中间件，我们可以自己写一个类，但是必须继承MiddlewareMixin 需要导入 12&gt; &gt; from django.utils.deprecation import MiddlewareMixin&gt; &gt; in views: 12345&gt; &gt; &gt;def index(request):&gt; &gt; &gt;&gt; &gt; &gt; print("view函数...")&gt; &gt; &gt; return HttpResponse("OK")&gt; &gt; &gt; in Mymiddlewares.py： 123456789101112131415161718192021&gt; &gt; &gt;from django.utils.deprecation import MiddlewareMixin&gt; &gt; &gt;from django.shortcuts import HttpResponse&gt; &gt; &gt;&gt; &gt; &gt;class Md1(MiddlewareMixin):&gt; &gt; &gt;&gt; &gt; &gt; def process_request(self,request):&gt; &gt; &gt; print("Md1请求")&gt; &gt; &gt; &gt; &gt; &gt; def process_response(self,request,response):&gt; &gt; &gt; print("Md1返回")&gt; &gt; &gt; return response&gt; &gt; &gt;&gt; &gt; &gt;class Md2(MiddlewareMixin):&gt; &gt; &gt;&gt; &gt; &gt; def process_request(self,request):&gt; &gt; &gt; print("Md2请求")&gt; &gt; &gt; #return HttpResponse("Md2中断")&gt; &gt; &gt; def process_response(self,request,response):&gt; &gt; &gt; print("Md2返回")&gt; &gt; &gt; return response&gt; &gt; &gt; 结果： 123456&gt; &gt; &gt;Md1请求&gt; &gt; &gt;Md2请求&gt; &gt; &gt;view函数...&gt; &gt; &gt;Md2返回&gt; &gt; &gt;Md1返回&gt; &gt; &gt; 注意：如果当请求到达请求2的时候直接不符合条件返回，即return HttpResponse(“Md2中断”)，程序将把请求直接发给中间件2返回，然后依次返回到请求者，结果如下： 返回Md2中断的页面，后台打印如下： 12345&gt; &gt; &gt;Md1请求&gt; &gt; &gt;Md2请求&gt; &gt; &gt;Md2返回&gt; &gt; &gt;Md1返回&gt; &gt; &gt; 流程图如下： process_view 12&gt; &gt;process_view(self, request, callback, callback_args, callback_kwargs)&gt; &gt; Mymiddlewares.py修改如下 123456789101112131415161718192021222324252627&gt; &gt;from django.utils.deprecation import MiddlewareMixin&gt; &gt;from django.shortcuts import HttpResponse&gt; &gt;&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("Md1view")&gt; &gt;&gt; &gt;class Md2(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md2请求")&gt; &gt; return HttpResponse("Md2中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md2返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("Md2view")&gt; &gt; 结果如下： 12345678&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;Md1view&gt; &gt;Md2view&gt; &gt;view函数...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 下图进行分析上面的过程： 当最后一个中间的process_request到达路由关系映射之后，返回到中间件1的process_view，然后 依次往下，到达views函数，最后通过process_response依次返回到达用户。 process_view可以用来调用视图函数： 12345678910111213141516&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt;&gt; &gt; # return HttpResponse("hello")&gt; &gt;&gt; &gt; response=callback(request,*callback_args,**callback_kwargs)&gt; &gt; return response&gt; &gt; 结果如下： 123456&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;view函数...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 注意：process_view如果有返回值，会越过其他的process_view以及视图函数，但是所有的 process_response都还会执行。 process_exception 12&gt; &gt;process_exception(self, request, exception)&gt; &gt; 示例修改如下： 123456789101112131415161718192021222324252627282930313233343536&gt; &gt;class Md1(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md1请求")&gt; &gt; #return HttpResponse("Md1中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md1返回")&gt; &gt; return response&gt; &gt;&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt;&gt; &gt; # return HttpResponse("hello")&gt; &gt;&gt; &gt; # response=callback(request,*callback_args,**callback_kwargs)&gt; &gt; # return response&gt; &gt; print("md1 process_view...")&gt; &gt;&gt; &gt; def process_exception(self):&gt; &gt; print("md1 process_exception...")&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;class Md2(MiddlewareMixin):&gt; &gt;&gt; &gt; def process_request(self,request):&gt; &gt; print("Md2请求")&gt; &gt; # return HttpResponse("Md2中断")&gt; &gt; def process_response(self,request,response):&gt; &gt; print("Md2返回")&gt; &gt; return response&gt; &gt; def process_view(self, request, callback, callback_args, callback_kwargs):&gt; &gt; print("md2 process_view...")&gt; &gt;&gt; &gt; def process_exception(self):&gt; &gt; print("md1 process_exception...")&gt; &gt; 结果如下： 123456789&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;md1 process_view...&gt; &gt;md2 process_view...&gt; &gt;view函数...&gt; &gt;&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt; 流程图如下： 当views出现错误时： 将md2的process_exception修改如下： 12345&gt; &gt; def process_exception(self,request,exception):&gt; &gt;&gt; &gt; print("md2 process_exception...")&gt; &gt; return HttpResponse("error")&gt; &gt; 结果如下： 123456789&gt; &gt;Md1请求&gt; &gt;Md2请求&gt; &gt;md1 process_view...&gt; &gt;md2 process_view...&gt; &gt;view函数...&gt; &gt;md2 process_exception...&gt; &gt;Md2返回&gt; &gt;Md1返回&gt; &gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django的ContentType组件]]></title>
    <url>%2F2017%2F11%2F30%2FDjango%E7%9A%84ContentType%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求我们商城里有很多的商品，节日要来了，我们要搞活动 那么我们就要设计优惠券，优惠卷都有什么类型嗯，满减的，折扣的，立减的等 我们对应着我们活动类型，对我们的某类商品设计优惠券， 比如： 家电是一类商品 食物是一类商品 那么我们可以设计家电折扣优惠卷，以及食物满减优惠卷等 那么表结构怎么设计 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from django.db import models class Appliance(models.Model): """ 家用电器表 id name 1 冰箱 2 电视 3 洗衣机 """ name = models.CharField(max_length=64) class Food(models.Model): """ 食物表 id name 1 面包 2 牛奶 """ name = models.CharField(max_length=32) class Fruit(models.Model): """ 水果表 id name 1 苹果 2 香蕉 """ name = models.CharField(max_length=32) class Coupon(models.Model): """ 优惠券表 id name appliance_id food_id fruit_id 1 通用优惠券 null null null 2 冰箱折扣券 1 null null 3 电视折扣券 2 null null 4 苹果满减卷 null null 1 我每增加一张表就要多增加一个字段 """ name = models.CharField(max_length=32) appliance = models.ForeignKey(to="Appliance", null=True, blank=True) food = models.ForeignKey(to="Food", null=True, blank=True) fruit = models.ForeignKey(to="Fruit", null=True, blank=True)&lt;br&gt;# 实际上我们商品的种类会特别的多，导致我们这张表外键越来越多 遇到这种一张表要跟多张表进行外键关联的时候，我们的Django提供了ContentType组件 ContentType组件ContentType是Django内置的一个应用，可以追踪项目中所有的APP和model的对应关系，并且记录在ContentType表中。 当我们的项目做数据库迁移后，会有很多DJango自带的表，其中就有dJango_content_type表 ContentType组件应用1，在model中定义ForeignKey字段，并关联到ContentType表，通常这个字段命名为content-type 2，在model中定义PositiveIntergerField字段, 用来存储关联表中的主键，通常我们用object_id 3，在model中定义GenericForeignKey字段，传入上面两个字段的名字 4，方便反向查询可以定义GenericRelation字段 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from django.db import modelsfrom django.contrib.contenttypes.models import ContentTypefrom django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation class Appliance(models.Model): """ 家用电器表 id name 1 冰箱 2 电视 3 洗衣机 """ name = models.CharField(max_length=64) coupons = GenericRelation(to="Coupon") class Food(models.Model): """ 食物表 id name 1 面包 2 牛奶 """ name = models.CharField(max_length=32) class Fruit(models.Model): """ 水果表 id name 1 苹果 2 香蕉 """ name = models.CharField(max_length=32) class Coupon(models.Model): """ 优惠券表 id name appliance_id food_id fruit_id 1 通用优惠券 null null null 2 冰箱折扣券 1 null null 3 电视折扣券 2 null null 4 苹果满减卷 null null 1 我每增加一张表就要多增加一个字段 """ name = models.CharField(max_length=32) # appliance = models.ForeignKey(to="Appliance", null=True, blank=True) # food = models.ForeignKey(to="Food", null=True, blank=True) # fruit = models.ForeignKey(to="Fruit", null=True, blank=True) # 第一步 content_type = models.ForeignKey(to=ContentType) # 第二步 object_id = models.PositiveIntegerField() # 第三步 content_object = GenericForeignKey('content_type', 'object_id') 数据库迁移后，添加数据，再进行增删改操作 基本的使用12345678910111213141516171819202122232425262728293031323334353637from django.http import HttpResponsefrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom django.contrib.contenttypes.models import ContentTypefrom .models import Appliance, Coupon # Create your views here. class Test(APIView): def get(self, request): # 通过ContentType获得表名 content = ContentType.objects.filter(app_label="app01", model="appliance").first() # 获得表model对象 相当于models.Applicance model_class = content.model_class() ret = model_class.objects.all() # 为海尔冰箱创建一条优惠记录 ice_box = Appliance.objects.filter(id=1).first() Coupon.objects.create(name="海尔冰箱折扣券", content_object=ice_box) # 查询优惠券id=1绑定了哪个商品 coupon_obj = Coupon.objects.filter(id=1).first() goods_obj = coupon_obj.content_object print(goods_obj.name) # 查询海尔冰箱的所有优惠券 id=1 # 我们定义了反向查询 results = ice_box.coupons.all() print(results[0].name) # 如果没定义反向查询 content = ContentType.objects.filter(app_label="app01", model="appliance").first() result = Coupon.objects.filter(content_type=content, object_id=1).all() print(result[0].name) return HttpResponse(ret)]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CORS跨域请求]]></title>
    <url>%2F2017%2F11%2F29%2FCORS%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[跨域 CORS跨域请求CORS即Cross Origin Resource Sharing 跨域资源共享 跨域请求分为两种，一种叫简单请求，一种是复杂请求 简单请求HTTP方法是下列方法之一 HEAD，GET，POST HTTP头信息不超出以下几种字段 Accept， Accept-Language， Content-Language， Last-Event-ID Content-Type只能是下列类型中的一个 application/x-www-from-urlencoded multipart/form-data text/plain 任何一个不满足上述要求的请求，即会被认为是复杂请求 复杂请求会先发出一个预请求，我们也叫预检，OPTIONS请求 浏览器的同源策略跨域是因为浏览器的同源策略导致的，也就是说浏览器会阻止非同源的请求 那么什么是非同源的呢？ 即域名不同，端口不同都属于非同源 浏览器只阻止表单以及ajax请求，并不会阻止src请求，所以我们的cnd，图片等src请求都可以发 解决跨域JSONPjsonp的实现原理是根据浏览器不组织src请求入手来实现的 JsonP实现的后端代码123456class Test(APIView): def get(self, request): callback = request.query_params.get("callback", "") ret = callback + "(" + "'success'" + ")" return HttpResponse(ret) JsonP测试前端代码123456789101112131415161718192021222324252627&lt;button id="btn_one"&gt;点击我向JsonP1发送请求&lt;/button&gt;&lt;script&gt; // 测试发送请求失败 跨域不能得到数据 $('#btn_one').click(function () &#123; $.ajax(&#123; url: "http://127.0.0.1:8000/jsonp1", type: "get", success: function (response) &#123; console.log(response) &#125; &#125;) &#125;); function handlerResponse(response) &#123; alert(response) &#125;; window.onload = function () &#123; $("#btn_one").click(function () &#123; let script_ele = document.createElement("script"); script_ele.src = "http://127.0.0.1:8000/jsonp1?callback=handlerResponse"; document.body.insertBefore(script_ele, document.body.firstChild); &#125;) &#125;&lt;/script&gt; JsonP解决跨域问题只能发送get请求，并且实现起来需要前后端交互比较多 添加响应头中间件响应头12345678910from django.utils.deprecation import MiddlewareMixinclass MyCors(MiddlewareMixin): def process_response(self, request, response): response["Access-Control-Allow-Origin"] = "*" if request.method == "OPTIONS": response["Access-Control-Allow-Headers"] = "Content-Type" response["Access-Control-Allow-Methods"] = "DELETE, PUT, POST" return response]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RESTful_API]]></title>
    <url>%2F2017%2F11%2F27%2FRESTful-API%2F</url>
    <content type="text"><![CDATA[什么是RESTful REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移” REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态 所有的数据，不管是通过网络获取的还是操作数据库获得（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性 对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture） 对互联网上的任意东西都视为资源，他认为一个url就是一个资源 比如：http://www.xxx.com/get_user/ 什么是APIAPI就是接口，提供的url。接口有两个用途： 为别人提供服务 前后端分离，一个写vue，一个写后端，他们之间都是通过ajax请求 基于Django实现的API网络应用程序，分为前端和后端两个部分。 当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。 这导致API构架的流行，甚至出现&quot;API First&quot;的设计思想。 RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 那么先来简单了解一下 协议API与用户的通信协议，总是使用HTTPs协议 域名有两种方式 方式一： 尽量将API部署在专用域名（会存在跨域问题） https://api.example.com 方式二：如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ 版本(Versioning)应该将API的版本号放入URL。 https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径(Endpoint)路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。即获取数据 POST（CREATE）：在服务器新建一个资源。 即添加数据 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。即更新数据 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。即更新数据 DELETE（DELETE）：从服务器删除资源 。即删除数据 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子： GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息(Filtering)如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如， GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码(status codes)服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 错误处理(Error handing)如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 { error: &quot;Invalid API key&quot; } 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 Hypermedia API 超媒体APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 {&quot;link&quot;: { &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, #表示这个API与当前网址的关系（collection关系，并给出该collection的网址） &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, #API路径 &quot;title&quot;: &quot;List of zoos&quot;, #API的标题 &quot;type&quot;: &quot;application/vnd.yourformat+json&quot; #返回类型 }} Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 { &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, // ... } 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 { &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot; } 基于Django实现API方式一：FBV模式全局url1234567891011from django.contrib import adminfrom django.conf.urls import url, includefrom app01 import viewsfrom app02 import viewsurlpatterns = [ url('admin/', admin.site.urls), # path('hosts/',views.HostView.as_view()), url('app02/', include('app02.urls'))] app02/url123456789from app02 import viewsfrom django.conf.urls import urlurlpatterns = [ url('^users/', views.users), url('^user/(\d+)', views.user), url('^users/', views.UsersView.as_view()), url('^user/', views.UserView.as_view()),] views1234567891011121314151617181920212223from django.shortcuts import render,HttpResponse# Create your views here.import jsondef users(request): response = &#123;'code':1000,'data':None&#125; #code用来表示状态，比如1000代表成功，1001代表 response['data'] = [ &#123;'name':'haiyan','age':22&#125;, &#123;'name':'haidong','age':10&#125;, &#123;'name':'haixiyu','age':11&#125;, ] return HttpResponse(json.dumps(response)) #返回多条数据def user(request,pk): if request.method =='GET': return HttpResponse(json.dumps(&#123;'name':'haiyan','age':11&#125;)) #返回一条数据 elif request.method =='POST': return HttpResponse(json.dumps(&#123;'code':1111&#125;)) #返回一条数据 elif request.method =='PUT': pass elif request.method =='DELETE': pass 方式二：CBV模式app02/url123456from app02 import viewsfrom django.conf.urls import url urlpatterns = [ url('^users/', views.UsersView.as_view()), url('^user/', views.UserView.as_view()),] 基于django实现的API许多功能都需要我们自己开发， 这时候djangorestframework就给我们提供了方便， 直接基于它来返回数据，总之原理都是一样的， 就是给一个接口也就是url， 让前端的人去请求这个url去获取数据， 在页面上显示出来。 这样也就达到了前后端分离的效果。 下面我们来看看基于Django Rest Framework框架实现 views基于Django Rest Framework框架的实现自定义认证12345678910111213class MyAuthtication(BasicAuthentication): def authenticate(self, request): token = request.query_params.get('token') #注意是没有GET的，用query_params表示 if token == 'zxxzzxzc': return ('uuuuuu','afsdsgdf') #返回user，auth raise APIException('认证错误')class UserView(APIView): authentication_classes = [MyAuthtication,] def get(self,request,*args,**kwargs): print(request.user) print(request.auth) return Response('用户列表') 应用主要是做Token验证 url中as_view里面调用了dispatch方法。 可以有两种方式 局部使用urls.py1234567from app01 import viewsfrom django.conf.urls import urlurlpatterns = [ # django rest framework url('^hosts/', views.HostView.as_view()), url(r'^auth/', views.AuthView.as_view()),] views.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from django.shortcuts import render,HttpResponse# Create your views here.from rest_framework.views import APIViewfrom rest_framework.views import Requestfrom rest_framework.authentication import SessionAuthenticationfrom rest_framework.authentication import BaseAuthentication, BasicAuthenticationfrom rest_framework.parsers import JSONParserfrom rest_framework.negotiation import DefaultContentNegotiationfrom rest_framework.exceptions import APIExceptionfrom app01 import modelsfrom rest_framework.response import Response #友好的显示返回结果class AuthView(APIView): #auth登录页面不需要验证，可设置 authentication_classes = [] #登录页面不需要认证 def get(self,request): ''' 接收用户名和密码 :param request: :return: ''' ret = &#123;'code':1000,'msg':None&#125; user = request.query_params.get('username') pwd = request.query_params.get('password') print(user,pwd) obj = models.UserInfo.objects.filter(username=user,password=pwd).first() print(obj) if not obj : ret['code'] = 1001 ret['msg'] = '用户名或者密码错误' return Response(ret) #创建随机字符串 import time import hashlib ctime = time.time() key = '%s|%s'%(user,ctime) m = hashlib.md5() m.update(key.encode('utf-8')) token = m.hexdigest() #保存数据 obj.token = token obj.save() ret['token'] = token return Response(ret)class HostView(APIView): def dispatch(self, request, *args, **kwargs): return super().dispatch(request, *args, **kwargs) # authentication_classes = [MyAuthtication] def get(self,request,*args,**kwargs): print(request.user,'dddddddddddffffff') print(request.auth,'dddddddddd') #原来的request，django.core.handlers.wsgi.WSGIRequest #现在的request ,rest_framework.request.Request # print(request) authentication_classes = [SessionAuthentication,BaseAuthentication] # print(self.authentication_classes) # [&lt;class 'rest_framework.authentication.SessionAuthentication'&gt;, # &lt;class 'rest_framework.authentication.BasicAuthentication'&gt;] return HttpResponse('GET请求的响应内容') def post(self,request,*args,**kwargs): pass # try: # try : # current_page = request.POST.get("page") # # current_page = int(current_page) # int("asd") # except ValueError as e: # print(e) # raise #如果有raise说明自己处理不了了，就交给下面的一个去捕捉了 # except Exception as e: # print("OK") return HttpResponse('post请求的响应内容') def put(self, request, *args, **kwargs): return HttpResponse('put请求的响应内容') 全局使用settings12345678#注册认证类REST_FRAMEWORK = &#123; 'UNAUTHENTICATED_USER': None, 'UNAUTHENTICATED_TOKEN': None, #将匿名用户设置为None "DEFAULT_AUTHENTICATION_CLASSES": [ "app01.utils.MyAuthentication", ],&#125; 全局验证1234567891011121314from rest_framework.authentication import BaseAuthenticationfrom rest_framework.exceptions import APIExceptionfrom app02 import modelsclass MyAuthentication(BaseAuthentication): def authenticate(self, request): token=request.query_params.get('token') print(token) obj=models.UserInfo.objects.filter(token=token).first() print(obj) if obj: return (obj.username,obj) raise APIException('没有通过验证') 注：rest_framewor是一个app需要settings里面设置。]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework源码流程]]></title>
    <url>%2F2017%2F11%2F25%2FDjango-Rest-Framework%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一请求到来之后，都要先执行dispatch方法，dispatch方法方法根据请求方式的不同触发get/post/put/delete等方法 注意：APIView中的dispatch方法有很多功能 123456789101112131415161718192021222324252627282930313233343536def dispatch(self, request, *args, **kwargs): """ `.dispatch()` is pretty much the same as Django's regular dispatch, but with extra hooks for startup, finalize, and exception handling. """ self.args = args self.kwargs = kwargs 第一步：对request进行加工（添加数据） request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: #第二步： #处理版权信息 #认证 #权限 #请求用户进行访问频率的限制 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 第三步、执行：get/post/put/delete函数 response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) #第四步、 对返回结果再次进行加工 self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 二上面是大致步骤，下面我们来具体分析一下，看每个步骤中都具体干了什么事 对request进行加工（添加数据）我们看看request里面都添加了那些数据 a首先 request = self.initialize_request(request, *args, **kwargs) 点进去，会发现：在Request里面多加了四个，如下 123456789101112131415def initialize_request(self, request, *args, **kwargs): """ Returns the initial request object. """ #吧请求弄成一个字典返回了 parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), #解析数据，默认的有三种方式，可点进去看 #self.get_authenticator优先找自己的，没有就找父类的 authenticators=self.get_authenticators(), #获取认证相关的所有类并实例化，传入request对象供Request使用 negotiator=self.get_content_negotiator(), parser_context=parser_context ) b获取认证相关的类的具体 authenticators=self.get_authenticators() 123456def get_authenticators(self): """ Instantiates and returns the list of authenticators that this view can use. """ #返回的是对象列表 return [auth() for auth in self.authentication_classes] #[SessionAuthentication,BaseAuthentication] c查看认证的类：self.authentication_classes 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES #默认的，如果自己有会优先执行自己的 d接着走进api_settings 1api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS) #点击继承的DEFAULTS类 123456DEFAULTS = &#123; # Base API policies 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.SessionAuthentication', #这时候就找到了他默认认证的类了，可以导入看看 'rest_framework.authentication.BasicAuthentication' ), e导入了类看看类里面具体干了什么 12from rest_framework.authentication import SessionAuthenticationfrom rest_framework.authentication import BaseAuthentication f看到里面有个authenticate方法和authenticate_header方法 12345678910111213141516171819class BaseAuthentication(object): """ All authentication classes should extend BaseAuthentication. """ def authenticate(self, request): """ Authenticate the request and return a two-tuple of (user, token). """ raise NotImplementedError(".authenticate() must be overridden.") def authenticate_header(self, request): """ Return a string to be used as the value of the `WWW-Authenticate` header in a `401 Unauthenticated` response, or `None` if the authentication scheme should return `403 Permission Denied` responses. """ pass 具体处理认证，从headers里面能获取用户名和密码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BasicAuthentication(BaseAuthentication): """ HTTP Basic authentication against username/password. """ www_authenticate_realm = 'api' def authenticate(self, request): """ Returns a `User` if a correct username and password have been supplied using HTTP Basic authentication. Otherwise returns `None`. """ auth = get_authorization_header(request).split() if not auth or auth[0].lower() != b'basic': return None #返回none不处理。让下一个处理 if len(auth) == 1: msg = _('Invalid basic header. No credentials provided.') raise exceptions.AuthenticationFailed(msg) elif len(auth) &gt; 2: msg = _('Invalid basic header. Credentials string should not contain spaces.') raise exceptions.AuthenticationFailed(msg) try: auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(':') #用partition切割冒号也包括 except (TypeError, UnicodeDecodeError, binascii.Error): msg = _('Invalid basic header. Credentials not correctly base64 encoded.') raise exceptions.AuthenticationFailed(msg) userid, password = auth_parts[0], auth_parts[2] # 返回用户和密码 return self.authenticate_credentials(userid, password, request) def authenticate_credentials(self, userid, password, request=None): """ Authenticate the userid and password against username and password with optional request for context. """ credentials = &#123; get_user_model().USERNAME_FIELD: userid, 'password': password &#125; user = authenticate(request=request, **credentials) if user is None: raise exceptions.AuthenticationFailed(_('Invalid username/password.')) if not user.is_active: raise exceptions.AuthenticationFailed(_('User inactive or deleted.')) return (user, None) def authenticate_header(self, request): return 'Basic realm="%s"' % self.www_authenticate_realm g当然restfulframework默认定义了两个类。我们也可以自定制类， 自己有就用自己的了，自己没有就去找父类的了， 但是里面必须实现authenticate方法，不然会报错。 进行以下操作 处理版权信息 认证 权限 请求用户进行访问频率的限制 我们主要来看一下认证流程： a首先 self.initial(request, *args, **kwargs)可以看到做了以下操作 12345678910111213141516171819202122def initial(self, request, *args, **kwargs): """ Runs anything that needs to occur prior to calling the method handler. """ self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. #2.1 处理版本信息 version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted #2.2 认证 self.perform_authentication(request) # 2.3 权限 self.check_permissions(request) # 2.4 请求用户进行访问频率的限制 self.check_throttles(request) b我们先来看认证，self.perform_authentication(request) 具体干了什么，按住ctrl点击进去 123456789def perform_authentication(self, request): """ Perform authentication on the incoming request. Note that if you override this and simply 'pass', then authentication will instead be performed lazily, the first time either `request.user` or `request.auth` is accessed. """ request.user #执行request的user，这是的request已经是加工后的request了 c那么我们可以从视图里面导入一下Request，找到request对象的user方法 1from rest_framework.views import Request 12345678910@property def user(self): """ Returns the user associated with the current request, as authenticated by the authentication classes provided to the request. """ if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() # return self._user #返回user d执行self._authenticate() 开始用户认证， 如果验证成功后返回元组： (用户,用户Token) 123456789101112131415161718192021def _authenticate(self): """ Attempt to authenticate the request using each authentication instance in turn. """ #循环对象列表 for authenticator in self.authenticators: try: #执行每一个对象的authenticate 方法 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple #返回一个元组，user，和auth，赋给了self, # 只要实例化Request，就会有一个request对象，就可以request.user,request.auth了 return self._not_authenticated() e在user_auth_tuple = authenticator.authenticate(self) 进行验证， 如果验证成功，执行类里的authenticatie方法 f如果用户没有认证成功：self._not_authenticated() 12345678910111213141516171819202122def _not_authenticated(self): """ Set authenticator, user &amp; authtoken representing an unauthenticated request. Defaults are None, AnonymousUser &amp; None. """ #如果跳过了所有认证，默认用户和Token和使用配置文件进行设置 self._authenticator = None # if api_settings.UNAUTHENTICATED_USER: self.user = api_settings.UNAUTHENTICATED_USER() # 默认值为：匿名用户AnonymousUser else: self.user = None # None 表示跳过该认证 if api_settings.UNAUTHENTICATED_TOKEN: self.auth = api_settings.UNAUTHENTICATED_TOKEN() # 默认值为：None else: self.auth = None # (user, token) # 表示验证通过并设置用户名和Token； # AuthenticationFailed异常 执行get/post/delete等方法对返回结果在进行加工]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的分页]]></title>
    <url>%2F2017%2F11%2F23%2FDjango-Rest-Framework%E7%9A%84%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[DRF的分页为什么要使用分页其实这个不说大家都知道，大家写项目的时候也是一定会用的， 我们数据库有几千万条数据，这些数据需要展示，我们不可能直接从数据库把数据全部读取出来， 这样会给内存造成特别大的压力，有可能还会内存溢出，所以我们希望一点一点的取， 那展示的时候也是一样的，总是要进行分页显示，我们之前自己都写过分页。 那么大家想一个问题，在数据量特别大的时候，我们的分页会越往后读取速度越慢， 当有一千万条数据，我要看最后一页的内容的时候，怎么能让我的查询速度变快。 DRF给我们提供了三种分页方式，我们看下他们都是什么样的 DRF提供的三种分页1from rest_framework.pagination import PageNumberPagination, LimitOffsetPagination, CursorPagination 全局配置 123REST_FRAMEWORK = &#123; 'PAGE_SIZE': 2&#125; 第一种PageNumberPagination 看第n页，每页显示n条数据http://127.0.0.1:8000/book?page=2&amp;size=1 自定义分页类12345class MyPageNumber(PageNumberPagination): page_size = 2 # 每页显示多少条 page_size_query_param = 'size' # URL中每页显示条数的参数 page_query_param = 'page' # URL中页码的参数 max_page_size = None # 最大页码数限制 视图123456789class BookView(APIView): def get(self, request): book_list = Book.objects.all() # 分页 page_obj = MyPageNumber() page_article = page_obj.paginate_queryset(queryset=book_list, request=request, view=self) ret = BookSerializer(page_article, many=True) return Response(ret.data) 返回带页码链接的响应1234567891011class BookView(APIView): def get(self, request): book_list = Book.objects.all() # 分页 page_obj = MyPageNumber() page_article = page_obj.paginate_queryset(queryset=book_list, request=request, view=self) ret = BookSerializer(page_article, many=True) # return Response(ret.data) # 返回带超链接 需返回的时候用内置的响应方法 return page_obj.get_paginated_response(ret.data) 第二中LimitOffsetPagination 在第n个位置 向后查看n条数据http://127.0.0.1:8000/book?offset=2&amp;limit=1 自定义的分页类12345class MyLimitOffset(LimitOffsetPagination): default_limit = 1 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 999 视图123456789101112# 只有用的分页类不同，其他都相同class BookView(APIView): def get(self, request): book_list = Book.objects.all() # 分页 page_obj = MyLimitOffset() page_article = page_obj.paginate_queryset(queryset=book_list, request=request, view=self) ret = BookSerializer(page_article, many=True) # return Response(ret.data) # 返回带超链接 需返回的时候用内置的响应方法 return page_obj.get_paginated_response(ret.data) 第三种CursorPagination 加密游标的分页 把上一页和下一页的id记住 自定义分页类1234class MyCursorPagination(CursorPagination): cursor_query_param = 'cursor' page_size = 1 ordering = '-id' 视图1234567891011class BookView(APIView): def get(self, request): book_list = Book.objects.all() # 分页 page_obj = MyCursorPagination() page_article = page_obj.paginate_queryset(queryset=book_list, request=request, view=self) ret = BookSerializer(page_article, many=True) # return Response(ret.data) # 返回带超链接 需返回的时候用内置的响应方法 return page_obj.get_paginated_response(ret.data) 总结pagination.py123456789101112131415161718192021222324from rest_framework import paginationclass MyPaginator(pagination.PageNumberPagination): # 每页限制数量 page_size = 2 # 参数 page_query_param = 'page_num' page_size_query_param = 'size' # 限制 max_page_size = 3class MyLimitOffset(pagination.LimitOffsetPagination): default_limit = 1 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 999class MyCursorPagination(pagination.CursorPagination): cursor_query_param = 'cursor' page_size = 1 ordering = '-id' view.py普通版12345678910111213class PageBookView(APIView): def get(self, request): queryset = models.Book.objects.all() # 先实例化分页器对象 # page_obj = MyPaginator() # page_obj = MyLimitOffset() page_obj = MyCursorPagination() # 用自己的分页器调用分页方法进行分页 page_data = page_obj.paginate_queryset(queryset, request) # 序列化分页好的数据 ser_obj = serializers.BookSerializer(page_data, many=True) # 给响应添加上一页下一页的链接 return page_obj.get_paginated_response(ser_obj.data) ModelViewSet版12345678from rest_framework import viewsetsclass BookModelView(viewsets.ModelViewSet): queryset = models.Book.objects.all() serializer_class = serializers.BookSerializer # pagination_class = MyPaginator # pagination_class = MyLimitOffset pagination_class = MyCursorPagination]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的解析器和渲染器]]></title>
    <url>%2F2017%2F11%2F22%2FDjango-Rest-Framework%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E6%B8%B2%E6%9F%93%E5%99%A8%2F</url>
    <content type="text"><![CDATA[解析器解析器的作用就是服务端接收客户端传来的数据，把数据解析成自己想要的数据类型的过程 本质就是对请求体中的数据进行解析 Django的解析器我们请求进来的请求体中的数据在request.body中，那也证明，解析器会把解析好的数据放入request.body 我们在视图中可以打印request的类型，能够知道request是WSGIRequest这个类 看源码，我么怎么拿到request.POST数据的 application/x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件， multipart/form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传 一个解析到request.POST, request.FILES中。 也就是说我们之前能在request中能到的各种数据是因为用了不同格式的数据解析器~ 那么我们的DRF能够解析什么样的数据类型呢  DRF的解析器什么时候我们的解析器会被调用，是不是在request.data拿数据的时候 我们说请求数据都在request.data中，那我们看Request类中的data 得到解析器后，调用解析器的parse方法 到这里，DRF配置的默认的解析器的类都有哪些 也就是说，我们的DRF支持Json，Form表单的请求，包括多种文件类型的数据 可以在视图中配置视图级别的解析器 这就是DRF的解析器 渲染器渲染器就是友好的展示数据 DRF提供的渲染器有 在浏览器中展示的DRF测试的那个页面，就是通过浏览器的渲染来做到的 当然我们可以展示Json数据类型]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的权限和频率]]></title>
    <url>%2F2017%2F11%2F21%2FDjango-Rest-Framework%E7%9A%84%E6%9D%83%E9%99%90%E5%92%8C%E9%A2%91%E7%8E%87%2F</url>
    <content type="text"><![CDATA[DRF的权限权限是什么权限到底是是干什么用的 比如，我们申请博客的时候，一定要向管理员申请，也就是说管理员会有一些特殊的权利，我们作为用户是没有的 这些对某些事情决策的范围和程度，我们叫做权限，权限是我们在项目开发中非常常用的 那么看DRF框架给我们提供的权限组件有哪些方法 权限组件源码我们之前有DRF的版本和认证，也就知道了权限和频率跟版本认证都是在initial方法里初始化的 其实我们版本，认证，权限，频率控制走的源码流程大致相同 我们的权限类一定要有has_permission方法，否则会抛出异常，这就是框架为我们提供的钩子 我们先看到在rest_framework.permissions这个文件红中，存放了框架为我们提供的所有权限的方法 这里主要说一下BasePermission这个我们写权限继承的一个基础权限类 权限的详细用法在这里我们一定要清楚一点，我们的python代码是一行一行执行的，那么执行intial方法初始化这些组件的时候 也就是顺序的，我们的版本在前面，然后是认证，然后是权限，最后是频率 我们的权限执行的时候，我们的认证已经执行结束了 前提是在model中的UserInfo表中加了一个字段，用户类型的字段，做好数据库迁移 第一步 写权限类1234567891011121314class MyPermission(BasePermission): message = "VIP用户才能访问" def has_permission(self, request, view): """ 自定义权限只有vip用户能访问， 注意我们初始化时候的顺序是认证在权限前面的，所以只要认证通过~ 我们这里就可以通过request.user,拿到我们用户信息 request.auth就能拿到用户对象 """ if request.user and request.auth.type == 2: return True else: return False 第二部 局部视图注册123456789class TestAuthView(APIView): authentication_classes = [MyAuth, ] permission_classes = [MyPermission, ] def get(self, request, *args, **kwargs): print(request.user) print(request.auth) username = request.user return Response(username) 第三步 全局注册 settings.py1234567891011121314REST_FRAMEWORK = &#123; # 默认使用的版本控制类 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # 允许的版本 'ALLOWED_VERSIONS': ['v1', 'v2'], # 版本使用的参数名称 'VERSION_PARAM': 'version', # 默认使用的版本 'DEFAULT_VERSION': 'v1', # 配置全局认证 # 'DEFAULT_AUTHENTICATION_CLASSES': ["BRQP.utils.MyAuth", ] # 配置全局权限 "DEFAULT_PERMISSION_CLASSES": ["BROP.utils.MyPermission"]&#125; DEF的频率频率限制是做什么的开放平台的API接口调用需要限制其频率，以节约服务器资源和避免恶意的频繁调用 那我们的DRF提供了一些什么样的频率限制的方法 频率组件源码版本，认证，权限，频率这几个组件的源码是一个流程 可以突破一下自己，这个自己看 频率组件原理DRF中的频率控制基本原理是基于访问次数和时间的，当然我们可以通过自己定义的方法来实现。 当我们请求进来时，走到我们的频率组件的时候，DRF内部会有一个字典来记录访问者的IP 以这个访问者的IP为key，value为一个列表，存放访问者每次访问的时间 {IP1: [第三次访问的时间， 第二次访问的时间， 第一次访问的时间]} 把每次访问最新时间放入到列表的最前面，记录这样一个数据结构，通过什么方式限流呢： 如果我们设置的时间是10秒内只能访问5次 1，判断访问者的IP是否在这个请求IP的字典里 2，保证这个列表里都是最近10秒内的访问的时间 判断当前请求时间和列表里最早的（也就是最后的）请求时间的查 如果差大于10秒，说明请求以及不是最近10秒内的，删除掉 继续判断倒数第二个值，知道差值小于10秒 3，判断列表的长度（即访问次数），是否大于我们设置的5次 如果大于就限流，否则放行，并把时间放入了列表的最前面 频率组件的详细用法频率组件的配置方式其实就是跟上面的组件都一样 第一步1234567891011121314151617181920212223242526272829303132VISIT_RECORD = &#123;&#125;class MyThrottle(object): def __init__(self): self.history = None def allow_request(self, request, view): """ 自定义频率限制60秒内只能访问三次 """ # 获取用户IP ip = request.META.get("REMOTE_ADDR") timestamp = time.time() if ip not in VISIT_RECORD: VISIT_RECORD[ip] = [timestamp, ] return True history = VISIT_RECORD[ip] self.history = history history.insert(0, timestamp) while history and history[-1] &lt; timestamp - 60: history.pop() if len(history) &gt; 3: return False else: return True def wait(self): """ 限制时间还剩多少 """ timestamp = time.time() return 60 - (timestamp - self.history[-1]) 第二步123456REST_FRAMEWORK = &#123; # ...... # 频率限制的配置 "DEFAULT_THROTTLE_CLASSES": ["Throttle.throttle.MyThrottle"], &#125;&#125; 第三步12345678from rest_framework.throttling import SimpleRateThrottleclass MyVisitThrottle(SimpleRateThrottle): scope = "WD" def get_cache_key(self, request, view): return self.get_ident(request) 第四步123456789REST_FRAMEWORK = &#123; # 频率限制的配置 # "DEFAULT_THROTTLE_CLASSES": ["Throttle.throttle.MyVisitThrottle"], "DEFAULT_THROTTLE_CLASSES": ["Throttle.throttle.MyThrottle"], "DEFAULT_THROTTLE_RATES":&#123; 'WD':'5/m', #速率配置每分钟不能超过5次访问，WD是scope定义的值， &#125;&#125; 可以在postman或者DRF自带的页面进行测试]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的版本和认证]]></title>
    <url>%2F2017%2F11%2F20%2FDjango-Rest-Framework%E7%9A%84%E7%89%88%E6%9C%AC%E5%92%8C%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[DRF的版本版本控制是做什么用的，我们为什么要用首先要知道版本是干嘛用的，我们知道开发项目的时候有多个版本 当项目一直更新，版本就越来越多，以前的旧版本就不维护了 那这时，就需要对版本进行控制，这个DRF也给我们提供了一些封装好的版本控制方法 版本控制怎么用之前视图篇介绍了APIView，也只带APIView返回View中的view函数然后调用的dispach方法 那看一下dispatch方法，看下它都做了些什么 执行self.initial方法之前是各种赋值，包括request的重新封装，下面是路由分发，那我们看这个方法辽做了什么。 可以看到，version版本信息赋值给了request.version 版本控制方案赋值给了request.versioning_scheme 这个版本控制方案就是配置的版本控制的类 也就是说，APIView通过这个方法初始化自己提供的组件 接下来看一下框架提供了那些版本的控制方法 ---- 在rest_framework.versioning 框架一共给我们提供了这几个版本的控制方法，这里只给出一个，其他配置相同 详细用法第一步 settings.py12345678910REST_FRAMEWORK = &#123; # 默认使用的版本控制类 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # 允许的版本 'ALLOWED_VERSIONS': ['v1', 'v2'], # 版本使用的参数名称 'VERSION_PARAM': 'version', # 默认使用的版本 'DEFAULT_VERSION': 'v1',&#125; 第二步 urls.py1234urlpatterns = [ url(r"^versions", MyView.as_view()), url(r"^(?P&lt;version&gt;[v1|v2]+)/test01", TestView.as_view()),] 测试视图12345678910class TestView(APIView): def get(self, request, *args, **kwargs): print(request.versioning_scheme) ret = request.version if ret == "v1": return Response("版本v1的信息") elif ret == "v2": return Response("版本v2的信息") else: return Response("根本就匹配不到这个路由") 其他版本控制的类，配置方法差不多都一样 DRF的认证认证是干什么用的我们都知道，我们可以在网站上登录，然后可以有个人中心，对自己信息进行修改 但是我们每次给服务器发请求，由于Http的无状态，导致我们每次都是新的请求 那么服务端需要对每次来的请求进行认证，看用户是否登录，以及登录用户是谁 那么我们服务器对每个请求进行认证的时候，不可能在每个视图函数中都写认证 一定是把认证逻辑抽离出来，以前我们可能会加装饰器，或者中间件，来看看DRF框架提供了什么 认证怎么用上面版本控制的时候我们可以知道，在dispatch 方法里，执行了initial方法，那初始化了我们的版本 如果认证读的话，可以看到，版本的下面就是我们的认证，权限，频率组件。 认证组件 我们进去认证看 我们这个权限组件返回的是request.user，那么我们这里的request是新的还是旧的呢 我们的initial是我们request重新赋值之后的，所所以这里的request是新的，也就是Request类实例对象 那这个user一定是一个静态方法，进去一探究竟 这里没有给出反复的跳转截图，自行仔细跳转 通过上面基本可以知道，我们的认证类一定要实现的方法，以及返回值类型， 以及配置的参数authentication_classes 请看具体用法 认证的详细用法写一个认证demo，先建一张用户表，字段为为用户名以及对应的token值 models.py1234567# 先在model中注册模型类# 并且进行数据迁移# 测试我就简写了~class UserInfo(models.Model): username = models.CharField(max_length=32) token = models.UUIDField() views.py1234567# 写视图类并且用post请求注册一个用户class UserView(APIView): def post(self, request, *args, **kwargs): username = request.data["username"] UserInfo.objects.create(username=username, token=uuid.uuid4()) return Response("注册成功") 认证开始写一个认证的类1234567891011# 注意我们这个认证的类必须实现的方法以及返回值class MyAuth(BaseAuthentication): def authenticate(self, request): request_token = request.query_params.get("token", None) if not request_token: raise AuthenticationFailed(&#123;"code": 1001, "error": "缺少token"&#125;) token_obj = UserInfo.objects.filter(token=request_token).first() if not token_obj: raise AuthenticationFailed(&#123;"code": 1001, "error": "无效的token"&#125;) return token_obj.username, token_obj 视图级别认证12345class TestAuthView(APIView): authentication_classes = [MyAuth, ] def get(self, request, *args, **kwargs): return Response("测试认证") 全局配置认证123456789101112REST_FRAMEWORK = &#123; # 默认使用的版本控制类 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # 允许的版本 'ALLOWED_VERSIONS': ['v1', 'v2'], # 版本使用的参数名称 'VERSION_PARAM': 'version', # 默认使用的版本 'DEFAULT_VERSION': 'v1', # 配置全局认证 'DEFAULT_AUTHENTICATION_CLASSES': ["BRQP.utils.MyAuth", ]&#125;]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework代码记录]]></title>
    <url>%2F2017%2F11%2F19%2FDjangoRestFramework%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[主要文件代码[TOC] 表结构设计1234567891011121314151617181920212223242526272829303132# models.py 文件from django.db import modelsBOOK_CATEGORIES = ((1, 'Python'), (2, 'Linux'), (3, 'Go'))__all__ = ['Book', 'Author', 'Publisher']class Book(models.Model): title = models.CharField(max_length=32) category = models.IntegerField(choices=BOOK_CATEGORIES) pub_date = models.DateField() authors = models.ManyToManyField(to='Author') publisher = models.ForeignKey(to='Publisher', on_delete=models.CASCADE) def __str__(self): return self.titleclass Author(models.Model): name = models.CharField(max_length=32) def __str__(self): return self.nameclass Publisher(models.Model): title = models.CharField(max_length=32) address = models.CharField(max_length=32) def __str__(self): return self.title 自定义Serializer方式一：继承serializers.Serializer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# serializers.pyfrom rest_framework import serializersfrom appone.models import Bookclass PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32)class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32)SENSITIVE_WORDS = ['极品', '最美', '之王', '之最']def my_validator(value): """ 自定义过滤器，可以传到字段的validators参数中 :param value: :return: """ if value in SENSITIVE_WORDS: raise serializers.ValidationError("含有敏感词汇")class BookSerializer(serializers.Serializer): id = serializers.IntegerField(required=False) # required为False时，反序列化不做校验 title = serializers.CharField(max_length=32, validators=[my_validator,]) pub_date = serializers.DateField() category = serializers.CharField(source="get_category_display", read_only=True) post_category = serializers.IntegerField(write_only=True) # 序列化不做校验，反序列化做校验 # 内部通过外键关系的Id拿到publisher_obj，然后把publisher_obj传入PublisherSerializer序列化器进行序列化 publisher = PublisherSerializer(read_only=True) authors = AuthorSerializer(many=True, read_only=True) publisher_id = serializers.IntegerField(write_only=True) # 反序列化时使用，前端传数据时以此名称作为建 author_list = serializers.ListField(write_only=True) # 反序列化时使用 def create(self, validated_data): book_obj = Book.objects.create( title=validated_data['title'], pub_date=validated_data['pub_date'], category=validated_data['post_category'], publisher_id=validated_data['publisher_id'] ) book_obj.authors.add(*validated_data['author_list']) return book_obj def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.pub_date = validated_data.get('pub_date', instance.pub_date) instance.category = validated_data.get('post_category', instance.category) instance.publisher_id = validated_data.get('publisher_id', instance.publisher_id) if validated_data.get('author_list'): instance.authors.set(validated_data['author_list']) instance.save() return instance def validate_title(self, value): """ 相当于局部钩子 :param value: 具体字段的值 :return: """ for word in SENSITIVE_WORDS: if word in value: raise serializers.ValidationError('标题含有敏感词汇') return value def validate(self, attrs): """ 相当于全局钩子 :param attrs: 所有字段组成的字典 :return: """ print("attrs:", attrs) return attrs"""继承serializers.Serializer自定义的Serializer中，必须定义create和update方法；当前端提交数据时，会在自定义的Serializer中查找create方法，当前端更新数据时，会在自定义的Serializer中查找update方法。添加新书时，前端传输数据示例：# 字段名称根据你创建的Serializer类中，为有外键关系字段定义的用于反序列化的具体名称决定&#123; "title": "自然语言处理", "pub_date": "2017-05-20", "post_category": 1, "publisher_id": 2, "author_list": [1, 2] &#125;""" 方式二：继承serializers.ModelSerializer 1234567891011121314151617181920212223242526272829303132333435363738394041class BookSerializer(serializers.ModelSerializer): # 有外键关系的字段和choices等一些特殊的字段，需要自定义展示效果；此处自定义的字段，在本类中必须有名称"get_字段"的钩子函数与其对应 # 注意：自定义的名字不要与原表中的字段名冲突 publisher_name = serializers.SerializerMethodField(read_only=True) authors_info = serializers.SerializerMethodField(read_only=True) category_name = serializers.SerializerMethodField(read_only=True) # 这是个钩子函数，会自动触发，此方法的返回值会赋值给上方的publisher_name def get_publisher_name(self, obj): return obj.publisher.title def get_authors_info(self, obj): author_queryset = obj.authors.all() return [&#123;'id': author.id, 'name': author.name&#125; for author in author_queryset] def get_category_name(self, obj): return obj.get_category_display() class Meta: model = Book fields = '__all__' # depth = 1 # 有外键关系的向下查找深度 extra_kwargs = &#123; "publisher": &#123;"write_only": True&#125;, "authors": &#123;"write_only": True&#125;, "category": &#123;"write_only": True&#125; &#125;"""继承serializers.ModelSerializer自定义的Serializer中，不用自定义create和update方法read_only=True 只在序列化时（后端传数据给前端浏览器用于展示），对字段进行校验write_only=True 只在反序列化时(后端拿到前端传过来的数据)，对字段进行校验添加新书时，前端传输数据示例：&#123; "publisher": 1, "authors": [1], "category": "1", "title": "Python袖珍指南", "pub_date": "2015-08-25" &#125;""" 路由文件项目的路由 12345678from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^api/', include("appone.urls")), url(r'^rest/', include("apprest.urls"))] 应用的路由 12345678# urls.pyfrom django.conf.urls import urlfrom .views import BookView, BookEditViewurlpatterns = [ url(r'^book$', BookView.as_view()), url(r'^book/(?P&lt;id&gt;\d+)', BookEditView.as_view()),] 视图函数文件1234567891011121314151617181920212223242526272829303132333435363738# views.pyfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom appone.models import Bookfrom .serializers import BookSerializerclass BookView(APIView): def get(self, request): book_queryset = Book.objects.all() ser_obj = BookSerializer(book_queryset, many=True) # 如果传给BookSerializer的第一个参数只是一个对象，many=True可以省略 # print(request.query_params) # &lt;QueryDict: &#123;'format': ['api'], 'name': ['jason']&#125;&gt; return Response(ser_obj.data) def post(self, request): book_data = request.data ser_obj = BookSerializer(data=book_data) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors) # 前端提交过来数据校验未通过，返回错误信息给前端class BookEditView(APIView): def get(self, request, id): book_obj = Book.objects.filter(id=id).first() ser_obj = BookSerializer(book_obj) return Response(ser_obj.data) def put(self, request, id): book_obj = Book.objects.filter(id=id).first() ser_obj = BookSerializer(instance=book_obj, data=request.data, partial=True) # partial=True表示允许校验部分字段，因为更改图书对象时，可能只是更改一个或几个字段；如果不设置partial=True，那么前端传过来的数据必须包含所有必须的字段，即字段要完整 if ser_obj.is_valid(): print(ser_obj.validated_data) ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors)]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的视图和路由]]></title>
    <url>%2F2017%2F11%2F18%2FDRF_view_router%2F</url>
    <content type="text"><![CDATA[Django-Rest-Framework的视图APIViewdjango中写CBV的时候继承的是View，rest_framework继承的是APIView，那么他们两个有什么不同呢 urlpatterns = [ url(r&apos;^book$&apos;, BookView.as_view()), url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), ] 可以看到，不管是View还是APIView最开始调用的都是as_view()方法，那走进源码看看 我们能看到，APIView继承了View, 并且执行了View中的as_view()方法，最后把view返回了，用csrf_exempt()方法包裹后去掉了csrf的认证。 那我们看看View中的as_view()方法做了什么 我们看到了~在View中的as_view方法返回了view函数，而view函数执行了self.dispatch()方法~~但是这里的dispatch方法应该是我们APIView中的 我们去initialize_request中看下把什么赋值给了request，并且赋值给了self.request, 也就是我们在视图中用的request.xxx到底是什么 我们看到，这个方法返回的是Request这个类的实例对象 我们注意我们看下这个Request类中的第一个参数request，是我们走我们django的时候的原来的request~ 我们看到了，这个Request类把原来的request赋值给了self._request, 也就是说以后_request是我们老的request，新的request是我们这个Request类 那我们继承APIView之后请求来的数据都在哪呢~~ 我们用了rest_framework框架以后，我们的request是重新封装的Request类~ request.query_params 存放的是我们get请求的参数 request.data 存放的是我们所有的数据，包括post请求的以及put，patch请求 相比原来的django的request，我们现在的request更加精简，清晰了~~~ 现在我们知道了APIView和View的一些区别~~当然还有~~后面还会说~~ 我们写的视图可能对多个表进行增删改查，就导致我们的视图特别多重复的代码~~ 那么我们尝试着来进行封装一下~~ 第一次封装APIView视图class BookView(APIView): def get(self, request): query_set = Book.objects.all() book_ser = BookSerializer(query_set, many=True) return Response(book_ser.data) def post(self, request): query_set = request.data book_ser = BookSerializer(data=query_set) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) class BookEditView(APIView): def get(self, request, id): query_set = Book.objects.filter(id=id).first() book_ser = BookSerializer(query_set) return Response(book_ser.data) def patch(self, request, id): query_set = Book.objects.filter(id=id).first() book_ser = BookSerializer(query_set, data=request.data, partial=True) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) def delete(self, request, id): query_set = Book.objects.filter(id=id).first() if query_set: query_set.delete() return Response(&quot;&quot;) else: return Response(&quot;删除的书籍不存在&quot;) 第一次封装class GenericAPIView(APIView): queryset = None serializer_class = None def get_queryset(self): return self.queryset.all() def get_serializer(self, *args, **kwargs): return self.serializer_class(*args, **kwargs) class ListModelMixin(object): def list(self, request, *args, **kwargs): queryset = self.get_queryset() serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) class CreateModelMixin(object): def create(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) class RetrieveModelMixin(object): def retrieve(self, request, id, *args, **kwargs): book_obj = self.get_queryset().filter(pk=id).first() book_ser = self.get_serializer(book_obj) return Response(book_ser.data) class UpdateModelMixin(object): def update(self, request, id, *args, **kwargs): book_obj = self.get_queryset().filter(pk=id).first() book_ser = self.get_serializer(book_obj, data=request.data, partial=True) if book_ser.is_valid(): book_ser.save() return Response(book_ser.validated_data) else: return Response(book_ser.errors) class DestroyModelMixin(object): def destroy(self, request, id, *args, **kwargs): queryset = self.get_queryset() try: queryset.get(pk=id).delete() return Response(&quot;&quot;) except Exception as e: return Response(&quot;信息有误&quot;) # 我们把公共的部分抽出来 这样不管写多少表的增删改查都变的很简单 # 这样封装后我们的视图会变成这样 class BookView(GenericAPIView, ListModelMixin, CreateModelMixin): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class BookEditView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, id, *args, **kwargs): return self.retrieve(request, id, *args, **kwargs) def patch(self, request, id, *args, **kwargs): return self.update(request, id, *args, **kwargs) def destroy(self, request, id, *args, **kwargs): return self.delete(request, id, *args, **kwargs) 我们封装的GenericAPIView，包括封装每个方法的类，其实框架都帮我们封装好了~~ 我们可以直接继承这些类来实现上面的视图可是还有没有更简单的方法呢~我们再次封装一下~~ 第二次封装# 上面我们写的继承类太长了~~我们再改改 class ListCreateAPIView(GenericAPIView, ListModelMixin, CreateModelMixin): pass class RetrieveUpdateDestroyAPIView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): pass class BookView(ListCreateAPIView): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class BookEditView(RetrieveUpdateDestroyAPIView): queryset = Book.objects.all() serializer_class = BookSerializer def get(self, request, id, *args, **kwargs): return self.retrieve(request, id, *args, **kwargs) def patch(self, request, id, *args, **kwargs): return self.update(request, id, *args, **kwargs) def delete(self, request, id, *args, **kwargs): return self.delete(request, id, *args, **kwargs) 这次我们只是让继承变的简单了一点而已，好像并没有什么大的进步我们可不可以把这两个视图合并成一个视图呢~~~框架给我们提供了一个路由传参的方法 我们看下ViewSetMixin action这个默认参数其实就是我们路由可以进行传参了 下面这个循环~可以看出~我们要传的参数是一个字段~key应该是我们的请求方式，value应该对应我们处理的方法~ 这样我们每个视图就不用在写函数了~因为已经和内部实现的函数相对应了~ 第三次封装路由 urls.pyurlpatterns = [ # url(r&apos;^book$&apos;, BookView.as_view()), # url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), url(r&apos;^book$&apos;, BookView.as_view({&quot;get&quot;: &quot;list&quot;, &quot;post&quot;: &quot;create&quot;})), url(r&apos;^book/(?P&lt;pk&gt;\d+)$&apos;, BookView.as_view({&quot;get&quot;: &quot;retrieve&quot;, &quot;patch&quot;: &quot;update&quot;, &quot;delete&quot;: &quot;destroy&quot;})), ] 第三次封装from rest_framework.viewsets import ViewSetMixin # class BookView(ViewSetMixin, ListCreateAPIView, RetrieveUpdateDestroyAPIView): # queryset = Book.objects.all() # serializer_class = BookSerializer # 如果我们再定义一个类 class ModelViewSet(ViewSetMixin, ListCreateAPIView, RetrieveUpdateDestroyAPIView): pass class BookView(ModelViewSet): queryset = Book.objects.all() serializer_class = BookSerializer 我们现在的视图就只要写两行就可以了 其实我们写的所有的视图~框架都帮我们封装好了 注意一点~用框架封装的视图~我们url上的那个关键字参数要用pk~系统默认的 奉献一张图来看下我们的继承顺序 Django-Rest-Framework的路由我们上面的路由传参写的特别多~~框架也帮我们封装好了~ from .views import BookView from rest_framework.routers import DefaultRouter router = DefaultRouter() router.register(r&quot;book&quot;, BookView) urlpatterns = [ # url(r&apos;^book$&apos;, BookView.as_view()), # url(r&apos;^book/(?P&lt;id&gt;\d+)$&apos;, BookEditView.as_view()), # url(r&apos;^book$&apos;, BookView.as_view({&quot;get&quot;: &quot;list&quot;, &quot;post&quot;: &quot;create&quot;})), # url(r&apos;^book/(?P&lt;pk&gt;\d+)$&apos;, BookView.as_view({&quot;get&quot;: &quot;retrieve&quot;, &quot;patch&quot;: &quot;update&quot;, &quot;delete&quot;: &quot;destroy&quot;})), ] urlpatterns += router.urls 我们可以看到通过框架我们可以把路由视图都变的非常简单~~ 但是需要自定制的时候还是需要我们自己用APIView写，当不需要那么多路由的时候，也不要用这种路由注册~~ 总之一切按照业务需要去用~~~ 总结urls.py12345678910111213141516171819202122232425from serdemo import viewsfrom rest_framework.routers import DefaultRouterrouter = DefaultRouter()router.register(r'book', views.BookModelView)urlpatterns = [ # 第一次 # url(r'^book/$', views.BookView.as_view()), # url(r'^book/(?P&lt;id&gt;\d+)', views.BookEditView.as_view()), # 第二次 # url(r'^book/$', views.BookView.as_view()), # url(r'^book/(?P&lt;id&gt;\d+)', views.BookEditView.as_view()), # 第三次 # url(r'^book/$', views.BookModelView.as_view(&#123;"get": "list", "post": "create"&#125;)), # url(r'^book/(?P&lt;id&gt;\d+)', views.BookModelView.as_view(&#123;"get": "retrieve", "put": "update", "delete": "destroy"&#125;)), # url(r'book_page$', views.PageBookView.as_view())]# 第三次urlpatterns += router.urls views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149from demo import modelsfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom serdemo import serializersfrom rest_framework.viewsets import ViewSetMixinfrom rest_framework import views # APIViewfrom rest_framework import viewsetsfrom rest_framework import genericsfrom rest_framework import mixinsfrom .pagination import MyPaginator, MyCursorPagination, MyLimitOffset# queryset不同 序列化器不同# def get:pass# def post:passclass GenericAPIView(APIView): queryset = None serializer_class = None def get_queryset(self): return self.queryset.all() def get_serializer(self, *args, **kwargs): return self.serializer_class(*args, **kwargs)class ListModelMixin(object): def list(self, request): queryset = self.get_queryset() ser_obj = self.get_serializer(queryset, many=True) return Response(ser_obj.data)class CreateModelMixin(object): def create(self, request): ser_obj = self.get_serializer(data=request.data) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.data) return Response(ser_obj.errors)class RetrieveModelMixin(object): def retrieve(self, request, id): book_obj = self.get_queryset().filter(id=id).first() ser_obj = serializers.BookSerializer(book_obj) return Response(ser_obj.data)class UpdateModelMixin(object): def update(self, request, id): book_obj = self.get_queryset().filter(id=id).first() ser_obj = self.get_serializer(instance=book_obj, data=request.data, partial=True) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.data) return Response(ser_obj.errors)class DestroyModelMixin(object): def destroy(self, request, id): book_obj = self.get_queryset().filter(id=id).first() if not book_obj: return Response("删除的对象不存在") book_obj.delete() return Response("")class ListCreateAPIView(GenericAPIView, ListModelMixin, CreateModelMixin): passclass RetrieveUpdateDestroyAPIView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): passclass ModelViewSet(ViewSetMixin, ListModelMixin, RetrieveUpdateDestroyAPIView): pass# get post# 封装一# class BookView(GenericAPIView, ListModelMixin, CreateModelMixin):# queryset = models.Book.objects.all()# serializer_class = serializers.BookSerializer## def get(self, request):# return self.list(request)## def post(self, request):# return self.create(request)# get put delete# 封装一# class BookEditView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):# queryset = models.Book.objects.all()# serializer_class = serializers.BookSerializer## def get(self, request, id):# return self.retrieve(request, id)## def put(self, request, id):# return self.update(request, id)## def delete(self, request, id):# return self.destroy(request, id)# # 分装二# class BookView(ListCreateAPIView):# queryset = models.Book.objects.all()# serializer_class = serializers.BookSerializer## def get(self, request):# return self.list(request)## def post(self, request):# return self.create(request)### # 封装二# class BookEditView(RetrieveUpdateDestroyAPIView):# queryset = models.Book.objects.all()# serializer_class = serializers.BookSerializer## def get(self, request, id):# return self.retrieve(request, id)## def put(self, request, id):# return self.update(request, id)## def delete(self, request, id):# return self.destroy(request, id)# 分装三 BookModelViewclass BookModelView(viewsets.ModelViewSet): # 只需要在路由中指定字典就可以 queryset = models.Book.objects.all() serializer_class = serializers.BookSerializer # 分页一 pagination_class = MyPaginator # 分页二 # pagination_class = MyLimitOffset # 分页三 # pagination_class = MyCursorPagination serializers.py123456789101112131415161718192021222324252627282930313233343536373839404142434445class BookSerializer(serializers.ModelSerializer): # 重写正序 category_info = serializers.SerializerMethodField(read_only=True) publisher_info = serializers.SerializerMethodField(read_only=True) authors_info = serializers.SerializerMethodField(read_only=True) def get_category_info(self, obj): # obj 就是序列化的每一个Book对象 return obj.get_category_display() def get_publisher_info(self, obj): # obj 就是序列化的每一个Book对象 publisher_obj = obj.publisher return &#123;"id": publisher_obj.pk, "title": publisher_obj.title&#125; def get_authors_info(self, obj): # obj 就是序列化的每一个Book对象 author_qureryset = obj.authors.all() return [&#123;"id": author_obj.pk, "name": author_obj.name&#125; for author_obj in author_qureryset] class Meta: model = models.Book fields = "__all__" # exclude=["id"] # 会让所有的外键关系变成只读read_only=True # depth = 1 # 向下找几层 # 反序列化的时候不用自己定义的，而是还是用原来的字段 extra_kwargs = &#123;"title": &#123;"validators": [my_validate]&#125;, "publisher": &#123;"write_only": True&#125;, "authors": &#123;"write_only": True&#125;, "category": &#123;"write_only": True&#125;&#125; # 验证 # 局部钩子校验 单个字段 def validate_title(self, value): # value 就是title 的值 对value处理 if "python" not in value.lower(): raise serializers.ValidationError('标题必须包含python') return value # 全局钩子校验 全部字段 def validate(self, attrs): # attr 字典有你传过来的所有的字段 if "python1" in attrs["title"].lower(): return attrs else: raise serializers.ValidationError("分类或标题不合符要求")]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的序列化]]></title>
    <url>%2F2017%2F11%2F16%2FDjango-Rest-Framework%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[可以直接看总结 正常的序列化from django.http import HttpResponse, JsonResponse from django.views import View from demo import models import json from django.core import serializers class BookView(View): def get(self, request): book_queryset = models.Book.objects.all().values(&quot;id&quot;, &apos;title&apos;) book_list = list(book_queryset) # 方式一 # ret = json.dumps(book_list, ensure_ascii=False) # return HttpResponse(ret) # 方式二 Django的序列化 # book_list_obj = models.Book.objects.all() # ret = serializers.serialize(&apos;json&apos;, book_list_obj, ensure_ascii=False) # return HttpResponse(ret) # 方式三 return JsonResponse(book_list, safe=False, json_dumps_params={&quot;ensure_ascii&quot;: False}) 为什么要用序列化组件当我们做前后端分离的项目~~我们前后端交互一般都选择JSON数据格式，JSON是一个轻量级的数据交互格式。 那么我们给前端数据的时候都要转成json格式，那就需要对我们从数据库拿到的数据进行序列化。 接下来我们看下django序列化和rest_framework序列化的对比~~ Django的序列化方法.values序列化结果 class BooksView(View): def get(self, request): book_list = Book.objects.values(&quot;id&quot;, &quot;title&quot;, &quot;chapter&quot;, &quot;pub_time&quot;, &quot;publisher&quot;) book_list = list(book_list) # 如果我们需要取外键关联的字段信息 需要循环获取外键 再去数据库查然后拼接成我们想要的 ret = [] for book in book_list: pub_dict = {} pub_obj = Publish.objects.filter(pk=book[&quot;publisher&quot;]).first() pub_dict[&quot;id&quot;] = pub_obj.pk pub_dict[&quot;title&quot;] = pub_obj.title book[&quot;publisher&quot;] = pub_dict ret.append(book) ret = json.dumps(book_list, ensure_ascii=False, cls=MyJson) return HttpResponse(ret) # json.JSONEncoder.default() # 解决json不能序列化时间字段的问题 class MyJson(json.JSONEncoder): def default(self, field): if isinstance(field, datetime.datetime): return field.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) elif isinstance(field, datetime.date): return field.strftime(&apos;%Y-%m-%d&apos;) else: return json.JSONEncoder.default(self, field) django serializers from django.core import serializers # 能够得到我们要的效果 结构有点复杂 class BooksView(View): def get(self, request): book_list = Book.objects.all() ret = serializers.serialize(&quot;json&quot;, book_list) return HttpResponse(ret) DRF序列化的方法首先，我们要用DRF的序列化，就要遵循人家框架的一些标准， – Django我们CBV继承类是View，现在DRF我们要用APIView – Django中返回的时候我们用HTTPResponse，JsonResponse，render ，DRF我们用Response 序列化第一步 声明序列化类class BookSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;) pub_time = serializers.DateField() 第二步 序列化对象from rest_framework.views import APIView from rest_framework.response import Response class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) 外键关系的序列化from rest_framework import serializers from .models import Book class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) class UserSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) name = serializers.CharField(max_length=32) age = serializers.IntegerField() class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) 反序列化当前端给我们发post的请求的时候~前端给我们传过来的数据~我们要进行一些校验然后保存到数据库~ 这些校验以及保存工作，DRF的Serializer也给我们提供了一些方法了~~ 首先~我们要写反序列化用的一些字段~有些字段要跟序列化区分开~~ Serializer提供了.is_valid() 和.save()方法~~ .save()反序列化 serializer.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book 序列化 views.py class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) def post(self, request): # book_obj = request.data print(request.data) serializer = BookSerializer(data=request.data) if serializer.is_valid(): print(12341253) serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 当前端给我们发送patch请求的时候，前端传给我们用户要更新的数据，我们要对数据进行部分验证~~ .is_valid()PATCH请求serializers.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book def update(self, instance, validated_data): instance.title = validated_data.get(&quot;title&quot;, instance.title) instance.chapter = validated_data.get(&quot;w_chapter&quot;, instance.chapter) instance.pub_time = validated_data.get(&quot;pub_time&quot;, instance.pub_time) instance.publisher_id = validated_data.get(&quot;publisher_id&quot;, instance.publisher_id) if validated_data.get(&quot;users&quot;): instance.user.set(validated_data.get(&quot;users&quot;)) instance.save() return instance PATCH请求views.py class BookView(APIView): def patch(self, request): print(request.data) book_id = request.data[&quot;id&quot;] book_info = request.data[&quot;book_info&quot;] book_obj = Book.objects.filter(pk=book_id).first() serializer = BookSerializer(book_obj, data=book_info, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 验证如果需要对一些字段进行自定义的验证—DRF也给我们提供了钩子方法 单个字段的验证 局部钩子class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) # 省略了一些字段 跟上面代码里一样的 # 。。。。。 def validate_title(self, value): if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&quot;标题必须含有Python&quot;) return value 多个字段的验证 全局钩子class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() date_added = serializers.DateField(write_only=True) # 新增了一个上架时间字段 # 省略一些字段。。都是在原基础代码上增加的 # 。。。。。。 # 对多个字段进行验证 要求上架日期不能早于出版日期 上架日期要大 def validate(self, attrs): if attrs[&quot;pub_time&quot;] &gt; attrs[&quot;date_added&quot;]: raise serializers.ValidationError(&quot;上架日期不能早于出版日期&quot;) return attrs 验证器 validatorsdef my_validate(value): if &quot;敏感词汇&quot; in value.lower: raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32, validators=[my_validate]) # 。。。。。。 ModelSerializer已经清楚了Serializer的用法，会发现我们所有的序列化跟我们的模型都紧密相关~ 那么，DRF也给我们提供了跟模型紧密相关的序列化器~~ModelSerializer~~ -- 它会根据模型自动生成一组字段 -- 它简单的默认实现了.update()以及.create()方法 定义一个ModelSerializer序列化器定义ModelSerializer class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 外键关系的序列化注意：当序列化类MATE中定义了depth时，这个序列化类中引用字段（外键）则自动变为只读 外键关系序列化 class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 # depth 代表找嵌套关系的第几层 自定义字段我们可以声明一些字段来覆盖默认字段，来进行自定制~ 比如我们的选择字段，默认显示的是选择的key，我们要给用户展示的是value。 自定义字段 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 Meta中其它关键字参数Meta中参数 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} post以及patch请求由于depth会让我们外键变成只读，所以我们再定义一个序列化的类，其实只要去掉depth就可以了~~ post/patch请求序列化类 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} SerializerMethodField外键关联的对象有很多字段我们是用不到的~都传给前端会有数据冗余~就需要我们自己去定制序列化外键对象的哪些字段~~ SerializerMethodField class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) user = serializers.SerializerMethodField() publisher = serializers.SerializerMethodField() # get_是重写字段的钩子方法 def get_user(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publisher(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} 用ModelSerializer改进上面Serializer的完整版ModelSerializer class BookSerializer(serializers.ModelSerializer): dis_chapter = serializers.SerializerMethodField(read_only=True) users = serializers.SerializerMethodField(read_only=True) publishers = serializers.SerializerMethodField(read_only=True) def get_users(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publishers(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} def get_dis_chapter(self, obj): return obj.get_chapter_display() class Meta: model = Book # fields = &quot;__all__&quot; # 字段是有序的 fields = [&quot;id&quot;, &quot;title&quot;,&quot;dis_chapter&quot;, &quot;pub_time&quot;, &quot;publishers&quot;, &quot;users&quot;,&quot;chapter&quot;, &quot;user&quot;, &quot;publisher&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;, &quot;dis_chapter&quot;, &quot;users&quot;, &quot;publishers&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}, &quot;user&quot;: {&quot;write_only&quot;: True}, &quot;publisher&quot;: {&quot;write_only&quot;: True}, &quot;chapter&quot;: {&quot;write_only&quot;: True}} 总结models.pyclass Book(models.Model): title = models.CharField(max_length=32) CHOICE = ((1, &quot;python&quot;), (2, &quot;Linux&quot;), (3, &apos;Go&apos;)) category = models.IntegerField(choices=CHOICE) pub_time = models.DateField() publisher = models.ForeignKey(to=&apos;Publisher&apos;) authors = models.ManyToManyField(to=&quot;Author&quot;) class Publisher(models.Model): title = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) 同一个views.pyfrom demo import models from rest_framework.views import APIView from rest_framework.response import Response from serdemo import serializers # 展示增加全部数据 class BookView(APIView): def get(self, request): book_queryset = models.Book.objects.all() # many=True代表可以序列化多个数据 ser_obj = serializers.BookSerializer(book_queryset, many=True) return Response(ser_obj.data) def post(self, request): # 确定数据类型已经数据结构 # 对妹子传来的数据进行校验 book_obj = request.data ser_obj = serializers.BookSerializer(data=book_obj) if ser_obj.is_valid(): ser_obj.save() # 校验通过的数据 return Response(ser_obj.validated_data) return Response(ser_obj.errors) # 展示和编辑某条数据 class BookEditView(APIView): def get(self, request, id): book_obj = models.Book.objects.filter(id=id).first() ser_obj = serializers.BookSerializer(book_obj) return Response(ser_obj.data) def put(self, request, id): book_obj = models.Book.objects.filter(id=id).first() # partial=True 代表的是可以改部分数据 ser_obj = serializers.BookSerializer(instance=book_obj, data=request.data, partial=True) if ser_obj.is_valid(): ser_obj.save() return Response(ser_obj.validated_data) return Response(ser_obj.errors) 普通版Serializerfrom rest_framework import serializers from demo import models class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32) # 自定义校验 def my_validate(value): if &quot;敏感词汇&quot; in value.lower(): raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.Serializer): # required=False 反序列化的时候可以没有,只序列化用不走校验 id = serializers.IntegerField(required=False) title = serializers.CharField(max_length=32, validators=[my_validate]) pub_time = serializers.DateField() # read_only=True 序列化用，反序列化的时候不要了 category = serializers.CharField(source=&quot;get_category_display&quot;, read_only=True) # write_only=True 反序列化 的时候用 post_category = serializers.IntegerField(write_only=True) publisher = PublisherSerializer(read_only=True) authors = AuthorSerializer(many=True, read_only=True) publisher_id = serializers.IntegerField(write_only=True) author_list = serializers.ListField(write_only=True) # 重写create方法 创建新数据的时候 validated_data就是传来的数据 def create(self, validated_data): # validated_data 校验通过的数据 就是book_obj # 同ORM操作给Book表新增数据 book_obj = models.Book.objects.create( title=validated_data[&apos;title&apos;], pub_time=validated_data[&apos;pub_time&apos;], category=validated_data[&apos;post_category&apos;], publisher_id=validated_data[&apos;publisher_id&apos;] ) book_obj.authors.add(*validated_data[&apos;author_list&apos;]) return book_obj # 重写update方法 更新数据的时候 def update(self, instance, validated_data): # instance 更新的book_obj对象 # validated_data 校验通过的数据 # ORM做更新操作 instance.title = validated_data.get(&apos;title&apos;, instance.title) instance.pub_time = validated_data.get(&apos;pub_time&apos;, instance.pub_time) instance.category = validated_data.get(&apos;post_category&apos;, instance.category) instance.publisher_id = validated_data.get(&apos;publisher_id&apos;, instance.publisher_id) if validated_data.get(&apos;author_list&apos;): instance.authors.set(validated_data[&apos;author_list&apos;]) instance.save() return instance # 局部钩子校验 单个字段 数据校验 def validate_title(self, value): # value 就是title 的值 对value处理 if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&apos;标题必须包含python&apos;) return value # 全局钩子校验 全部字段 数据校验 def validate(self, attrs): # attr 字典有你传过来的所有的字段 if &quot;python&quot; in attrs[&quot;title&quot;].lower(): return attrs else: raise serializers.ValidationError(&quot;分类或标题不合符要求&quot;) 升级版ModelSerializerfrom rest_framework import serializers from demo import models class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) class AuthorSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField(max_length=32) # 自定义校验 def my_validate(value): if &quot;敏感词汇&quot; in value.lower(): raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.ModelSerializer): # 重写正序 category_info = serializers.SerializerMethodField(read_only=True) publisher_info = serializers.SerializerMethodField(read_only=True) authors_info = serializers.SerializerMethodField(read_only=True) def get_category_info(self, obj): # obj 就是序列化的每一个Book对象 return obj.get_category_display() def get_publisher_info(self, obj): # obj 就是序列化的每一个Book对象 publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} def get_authors_info(self, obj): # obj 就是序列化的每一个Book对象 author_qureryset = obj.authors.all() return [{&quot;id&quot;: author_obj.pk, &quot;name&quot;: author_obj.name} for author_obj in author_qureryset] class Meta: model = models.Book fields = &quot;__all__&quot; # exclude=[&quot;id&quot;] # 会让所有的外键关系变成只读read_only=True # depth = 1 # 向下找几层 # 反序列化的时候不用自己定义的，而是还是用原来的字段 extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate]}, &quot;publisher&quot;: {&quot;write_only&quot;: True}, &quot;authors&quot;: {&quot;write_only&quot;: True}, &quot;category&quot;: {&quot;write_only&quot;: True}} # 验证 # 局部钩子校验 单个字段 def validate_title(self, value): # value 就是title 的值 对value处理 if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&apos;标题必须包含python&apos;) return value # 全局钩子校验 全部字段 def validate(self, attrs): # attr 字典有你传过来的所有的字段 if &quot;python&quot; in attrs[&quot;title&quot;].lower(): return attrs else: raise serializers.ValidationError(&quot;分类或标题不合符要求&quot;)]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RESTful规范]]></title>
    <url>%2F2017%2F11%2F14%2FRESTful%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[web服务交互 我们在浏览器中能看到的每个网站，都是一个web服务。那么我们在提供每个web服务的时候， 都需要前后端交互，前后端交互就一定有一些实现方案，我们通常叫web服务交互方案。 目前主流的三种web服务交互方案： -- REST （ Representational State Transfer）表述性状态转移 -- SOAP （Simple Object Access Protocol） 简单的对象访问协议 -- XML-RPC （XML Remote Procedure Call）基于XML的远程过程调用 XML-RPC是通过XML将调用函数封装，并使用HTTP协议作为传送机制。 后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协定。 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。 SOAP也是基于XML的，但是它不只限于HTTP协议的传输，包括TCP协议，UDP协议都可以传输。 REST是Roy Thomas Fielding博士于2000年在他的博士论文里提出来的。 REST相比SOAP更加简洁，性能和开发效率也有突出的优势。 我们今天主要说一下这个REST，现在越来越多的web服务开始采用REST风格设计和实现。 例如，amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 我们接下来要学的框架也是遵循REST风格的，那么我们来看下它到底是个什么样的风格， 了解了它是什么后，我们看下它的优点是什么，我们为什么用它。 REST风格表述性状态转移 资源 网页中能看到的都是资源 URL 统一资源定位符  URI 统一资源标识符 统一资源接口 对资源的操作根据HTTP请求方式的不同来进行不同的操作 遵循HTTP请求方式的语义 前后端传输的是资源的表述 展现的是资源的状态 通过超链接的指引来告诉用户接下来有哪些资源状态可以进入 凡是遵循TEST风格实现的前后端交互都叫RESTful架构核心思想面向资源去编程 url中尽量名词不要动词 根据HTTP请求方式的不同对资源进行不同的操作 在url中体现的体现版本 https://v3.bootcss.com/ https://.bootcss.com/v3 体现是否是API https://v3.bootcss.com/api 有过滤条件 https://v3.bootcss.com/course?page=1 尽量用https 在返回值中携带状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 返回值 get 返回查看的所有或者单条数据 post 返回新增的这条数据 put/patch 返回更新的这条数据 delete 返回值空 携带错误信息 携带超链接 在不分离的项目用的多 ret = { code: 1000, data:{ id:1, name:&apos;小强&apos;, depart_id:http://www.luffycity.com/api/v1/depart/8/ } }]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人简介]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[危机感 | 对失败的容忍度 海燕 在苍茫的大海上，狂风卷集着乌云。在乌云和大海之间，海燕像黑色的闪电，在高傲地飞翔。 一会儿翅膀碰着波浪，一会儿箭一般地直冲向乌云，它叫喊着，──就在这鸟儿勇敢的叫喊声里，乌云听出了欢乐。 在这叫喊声里──充满着对暴风雨的渴望！在这叫喊声里，乌云听出了愤怒的力量、热情的火焰和胜利的信心。 海鸥在暴风雨来临之前呻吟着，──呻吟着，它们在大海上飞窜，想把自己对暴风雨的恐惧，掩藏到大海深处。 海鸭也在呻吟着，──它们这些海鸭啊，享受不了生活的战斗的欢乐：轰隆隆的雷声就把它们吓坏了。 蠢笨的企鹅，胆怯地把肥胖的身体躲藏到悬崖底下……只有那高傲的海燕，勇敢地，自由自在地，在泛起白沫的大海上飞翔！ 乌云越来越暗，越来越低，向海面直压下来，而波浪一边歌唱，一边冲向高空，去迎接那雷声。 雷声轰响。波浪在愤怒的飞沫中呼叫，跟狂风争鸣。看吧，狂风紧紧抱起一层层巨浪，恶狠狠地把它们甩到悬崖上，把这些大块的翡翠摔成尘雾和碎末。 海燕叫喊着，飞翔着，像黑色的闪电，箭一般地穿过乌云，翅膀掠起波浪的飞沫。 看吧，它飞舞着，像个精灵，──高傲的、黑色的暴风雨的精灵，——它在大笑，它又在号叫……它笑那些乌云，它因为欢乐而号叫！ 这个敏感的精灵，——它从雷声的震怒里，早就听出了困乏，它深信，乌云遮不住太阳，──是的，遮不住的！ 狂风吼叫……雷声轰响…… 一堆堆乌云，像青色的火焰，在无底的大海上燃烧。大海抓住闪电的箭光，把它们熄灭在自己的深渊里。这些闪电的影子，活像一条条火蛇，在大海里蜿蜒游动，一晃就消失了。 ——暴风雨！暴风雨就要来啦！ 这是勇敢的海燕，在怒吼的大海上，在闪电中间，高傲地飞翔；这是胜利的预言家在叫喊： ——让暴风雨来得更猛烈些吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[留言板]]></title>
    <url>%2Fguestbook%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
