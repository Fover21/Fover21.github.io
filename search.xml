<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git下]]></title>
    <url>%2F2018%2F11%2F14%2Fgit%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[git下 分支管理策略1）master分支 非常稳定的，只用来发布新版本，平时不在上面干活 2）dev分支 不稳定的，主要在上面干活，每个人都有自己的分支，时不时的往dev分支上合并 通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 &gt; git log --graph --pretty=oneline --abbrev-commit Bug分支你目前在dev分支上工作，工作到一半，但突然有一个紧急的bug需要修复，可以先保存你的工作现场，修复完bug后，在切回来。 步骤： 当前在dev分支上： git stash # 把当前工作现场“储藏”起来 切换到要修复bug的分支（假定master）： git checkout master git checkout -b issue-101 .... 修复问题 git add filename git commit filename 把修改合并到修复的分支： git checkout master git merge --no-ff -m &quot;merge fix 101 modification&quot; issue-101 git branch -D issue-101 切换回工作现场： git checkout dev git stash list # 查看之前保存了哪些工作现场 git stash drop 两种恢复方式： 1）git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 git stash apply stash@{0} git stash drop stash@{0} 2）git stash pop，恢复的同时把stash内容也删了 Feature分支与bug分支类似 两条命令： 1）git branch -d dev_name # 已经合并完的分支可以使用此命令删除 2）git branch -d dev_name # 强制删除分支（未合并的也可以） 多人协作多个人在同一分支上工作，如何正确的合并文件？ 两种情况： **1）你和他人同时修改同一个文件，他人修改完成，提前推送到远程，如何提交你的修改** 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull拉取远程最新的版本； 3）如果合并有冲突，则解决冲突，并在本地提交； 4）没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 **2）你和他人操作的不是同一个文件 详细步骤： 1）试图用git push origin &lt;branch-name&gt;推送自己的修改； 2）如果推送失败，先用git pull拉取远程最新的版本； 3）git add . # 添加本地的全部修改到暂存区 4）git commit -m &quot;说明信息&quot; # 提交更改至本地 5）git push origin &lt;branch-name&gt;推送本地分支至远程 提交更改前，都要先git pull拉取远程最新版本 当从远程克隆时，Git自动把本地的master分支与远程的master分支对应起来，远程仓库的默认名称是origin。 查看远程库信息： git remote -v 推送分支： git push origin master 把本地的mater分支推送到远程对应的master分支上 git push origin dev 把本地的dev分支推送到远程对应的dev分支（远程没有dev分支会自动创建一个dev分支） 创建远程origin的dev分支到本地 git checkout -b dev origin/dev 指定本地dev分支与远程origin/dev分支的链接 git branch --set-upstream-to origin/dev dev 或 git branch --track origin/dev dev 标签tag是一个容易记住的有意义的名字，它跟某个commit绑定在一起。 打标签： git tag tag_name # 默认打在最新提交的commit上,当前HEAD的指向 git tag # 查看标签 git show tag_name # 查看标签详细信息 在指定的commit上打标签： git log --pretty=oneline # 查看commit id git log -a tag_name -m &quot;explain content&quot; commit_id 推送标签： git push origin tag_name # 推送一个指定的标签 git push origin --tags # 推送全部尚未推送到远程的本地标签 删除标签： 1) 标签尚未推送到远程 git tag -d tag_name 2）标签已推送到远程 git tag -d tag_name git push origin :refs/tags/tag_name Rebase解决查看log分支多，混乱的问题；遗留]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django-Rest-Framework的序列化]]></title>
    <url>%2F2018%2F11%2F14%2FDjango-Rest-Framework%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Django-Rest-Framework的序列化之serializers 序列化组件 正常的序列化from django.http import HttpResponse, JsonResponse from django.views import View from demo import models import json from django.core import serializers class BookView(View): def get(self, request): book_queryset = models.Book.objects.all().values(&quot;id&quot;, &apos;title&apos;) book_list = list(book_queryset) # 方式一 # ret = json.dumps(book_list, ensure_ascii=False) # return HttpResponse(ret) # 方式二 Django的序列化 # book_list_obj = models.Book.objects.all() # ret = serializers.serialize(&apos;json&apos;, book_list_obj, ensure_ascii=False) # return HttpResponse(ret) # 方式三 return JsonResponse(book_list, safe=False, json_dumps_params={&quot;ensure_ascii&quot;: False}) 为什么要用序列化组件当我们做前后端分离的项目~~我们前后端交互一般都选择JSON数据格式，JSON是一个轻量级的数据交互格式。 那么我们给前端数据的时候都要转成json格式，那就需要对我们从数据库拿到的数据进行序列化。 接下来我们看下django序列化和rest_framework序列化的对比~~ Django的序列化方法.values序列化结果 class BooksView(View): def get(self, request): book_list = Book.objects.values(&quot;id&quot;, &quot;title&quot;, &quot;chapter&quot;, &quot;pub_time&quot;, &quot;publisher&quot;) book_list = list(book_list) # 如果我们需要取外键关联的字段信息 需要循环获取外键 再去数据库查然后拼接成我们想要的 ret = [] for book in book_list: pub_dict = {} pub_obj = Publish.objects.filter(pk=book[&quot;publisher&quot;]).first() pub_dict[&quot;id&quot;] = pub_obj.pk pub_dict[&quot;title&quot;] = pub_obj.title book[&quot;publisher&quot;] = pub_dict ret.append(book) ret = json.dumps(book_list, ensure_ascii=False, cls=MyJson) return HttpResponse(ret) # json.JSONEncoder.default() # 解决json不能序列化时间字段的问题 class MyJson(json.JSONEncoder): def default(self, field): if isinstance(field, datetime.datetime): return field.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) elif isinstance(field, datetime.date): return field.strftime(&apos;%Y-%m-%d&apos;) else: return json.JSONEncoder.default(self, field) django serializers from django.core import serializers # 能够得到我们要的效果 结构有点复杂 class BooksView(View): def get(self, request): book_list = Book.objects.all() ret = serializers.serialize(&quot;json&quot;, book_list) return HttpResponse(ret) DRF序列化的方法首先，我们要用DRF的序列化，就要遵循人家框架的一些标准， – Django我们CBV继承类是View，现在DRF我们要用APIView – Django中返回的时候我们用HTTPResponse，JsonResponse，render ，DRF我们用Response 序列化第一步 声明序列化类class BookSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;) pub_time = serializers.DateField() 第二步 序列化对象from rest_framework.views import APIView from rest_framework.response import Response class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) 外键关系的序列化from rest_framework import serializers from .models import Book class PublisherSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) class UserSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) name = serializers.CharField(max_length=32) age = serializers.IntegerField() class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) 反序列化当前端给我们发post的请求的时候~前端给我们传过来的数据~我们要进行一些校验然后保存到数据库~ 这些校验以及保存工作，DRF的Serializer也给我们提供了一些方法了~~ 首先~我们要写反序列化用的一些字段~有些字段要跟序列化区分开~~ Serializer提供了.is_valid() 和.save()方法~~ .save()反序列化 serializer.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book 序列化 views.py class BookView(APIView): def get(self, request): book_list = Book.objects.all() ret = BookSerializer(book_list, many=True) return Response(ret.data) def post(self, request): # book_obj = request.data print(request.data) serializer = BookSerializer(data=request.data) if serializer.is_valid(): print(12341253) serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 当前端给我们发送patch请求的时候，前端传给我们用户要更新的数据，我们要对数据进行部分验证~~ .is_valid()PATCH请求serializers.py class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() publisher = PublisherSerializer(read_only=True) user = UserSerializer(many=True, read_only=True) users = serializers.ListField(write_only=True) publisher_id = serializers.IntegerField(write_only=True) def create(self, validated_data): book = Book.objects.create(title=validated_data[&quot;title&quot;], chapter=validated_data[&quot;w_chapter&quot;], pub_time=validated_data[&quot;pub_time&quot;], publisher_id=validated_data[&quot;publisher_id&quot;]) book.user.add(*validated_data[&quot;users&quot;]) return book def update(self, instance, validated_data): instance.title = validated_data.get(&quot;title&quot;, instance.title) instance.chapter = validated_data.get(&quot;w_chapter&quot;, instance.chapter) instance.pub_time = validated_data.get(&quot;pub_time&quot;, instance.pub_time) instance.publisher_id = validated_data.get(&quot;publisher_id&quot;, instance.publisher_id) if validated_data.get(&quot;users&quot;): instance.user.set(validated_data.get(&quot;users&quot;)) instance.save() return instance PATCH请求views.py class BookView(APIView): def patch(self, request): print(request.data) book_id = request.data[&quot;id&quot;] book_info = request.data[&quot;book_info&quot;] book_obj = Book.objects.filter(pk=book_id).first() serializer = BookSerializer(book_obj, data=book_info, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.validated_data) else: return Response(serializer.errors) 验证如果需要对一些字段进行自定义的验证—DRF也给我们提供了钩子方法 单个字段的验证class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) # 省略了一些字段 跟上面代码里一样的 # 。。。。。 def validate_title(self, value): if &quot;python&quot; not in value.lower(): raise serializers.ValidationError(&quot;标题必须含有Python&quot;) return value 多个字段的验证class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32) CHOICES = ((1, &quot;Linux&quot;), (2, &quot;Django&quot;), (3, &quot;Python&quot;)) chapter = serializers.ChoiceField(choices=CHOICES, source=&quot;get_chapter_display&quot;, read_only=True) w_chapter = serializers.IntegerField(write_only=True) pub_time = serializers.DateField() date_added = serializers.DateField(write_only=True) # 新增了一个上架时间字段 # 省略一些字段。。都是在原基础代码上增加的 # 。。。。。。 # 对多个字段进行验证 要求上架日期不能早于出版日期 上架日期要大 def validate(self, attrs): if attrs[&quot;pub_time&quot;] &gt; attrs[&quot;date_added&quot;]: raise serializers.ValidationError(&quot;上架日期不能早于出版日期&quot;) return attrs 验证器 validatorsdef my_validate(value): if &quot;敏感词汇&quot; in value.lower: raise serializers.ValidationError(&quot;包含敏感词汇，请重新提交&quot;) return value class BookSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(max_length=32, validators=[my_validate]) # 。。。。。。 ModelSerializer已经清楚了Serializer的用法，会发现我们所有的序列化跟我们的模型都紧密相关~ 那么，DRF也给我们提供了跟模型紧密相关的序列化器~~ModelSerializer~~ -- 它会根据模型自动生成一组字段 -- 它简单的默认实现了.update()以及.create()方法 定义一个ModelSerializer序列化器定义ModelSerializer class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 外键关系的序列化注意：当序列化类MATE中定义了depth时，这个序列化类中引用字段（外键）则自动变为只读 外键关系序列化 class BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 # depth 代表找嵌套关系的第几层 自定义字段我们可以声明一些字段来覆盖默认字段，来进行自定制~ 比如我们的选择字段，默认显示的是选择的key，我们要给用户展示的是value。 自定义字段 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 Meta中其它关键字参数Meta中参数 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 depth = 1 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} post以及patch请求由于depth会让我们外键变成只读，所以我们再定义一个序列化的类，其实只要去掉depth就可以了~~ post/patch请求序列化类 class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} SerializerMethodField外键关联的对象有很多字段我们是用不到的~都传给前端会有数据冗余~就需要我们自己去定制序列化外键对象的哪些字段~~ SerializerMethodField class BookSerializer(serializers.ModelSerializer): chapter = serializers.CharField(source=&quot;get_chapter_display&quot;, read_only=True) user = serializers.SerializerMethodField() publisher = serializers.SerializerMethodField() def get_user(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publisher(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} class Meta: model = Book fields = &quot;__all__&quot; # fields = [&quot;id&quot;, &quot;title&quot;, &quot;pub_time&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}} 用ModelSerializer改进上面Serializer的完整版ModelSerializer class BookSerializer(serializers.ModelSerializer): dis_chapter = serializers.SerializerMethodField(read_only=True) users = serializers.SerializerMethodField(read_only=True) publishers = serializers.SerializerMethodField(read_only=True) def get_users(self, obj): # obj是当前序列化的book对象 users_query_set = obj.user.all() return [{&quot;id&quot;: user_obj.pk, &quot;name&quot;: user_obj.name} for user_obj in users_query_set] def get_publishers(self, obj): publisher_obj = obj.publisher return {&quot;id&quot;: publisher_obj.pk, &quot;title&quot;: publisher_obj.title} def get_dis_chapter(self, obj): return obj.get_chapter_display() class Meta: model = Book # fields = &quot;__all__&quot; # 字段是有序的 fields = [&quot;id&quot;, &quot;title&quot;,&quot;dis_chapter&quot;, &quot;pub_time&quot;, &quot;publishers&quot;, &quot;users&quot;,&quot;chapter&quot;, &quot;user&quot;, &quot;publisher&quot;] # exclude = [&quot;user&quot;] # 分别是所有字段 包含某些字段 排除某些字段 read_only_fields = [&quot;id&quot;, &quot;dis_chapter&quot;, &quot;users&quot;, &quot;publishers&quot;] extra_kwargs = {&quot;title&quot;: {&quot;validators&quot;: [my_validate,]}, &quot;user&quot;: {&quot;write_only&quot;: True}, &quot;publisher&quot;: {&quot;write_only&quot;: True}, &quot;chapter&quot;: {&quot;write_only&quot;: True}}]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令]]></title>
    <url>%2F2018%2F11%2F14%2Fconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[conda常用命令 查看 conda 版本号conda -Vconda –version 环境管理 查看当前有哪些环境 conda env list 或conda info -e 实际执行命令示例:➜ ~ conda env list conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 ➜ ~ conda info -e conda environments:#base * /anaconda3flaskdev /anaconda3/envs/flaskdevpythonRoad /anaconda3/envs/pythonRoadtest_py2 /anaconda3/envs/test_py2 查看环境管理的命令帮助 conda env -h 创建环境 conda create –name your_env_name 创建指定 python 版本的环境 conda create –name your_env_name python=2.7conda create –name your_env_name python=3.6 创建包含某些包的环境 conda create –name your_env_name numpy scrapy 创建指定版本下包含某些包的环境 conda create –name your_env_name python=3.6 numpy scrapy 激活某个环境 source activate target_env_name 关闭激活的环境 source deactivate target_env_name 复制某个环境 conda create –name new_env_name –clone old_env_name 删除某个环境 conda remove –name target_env_name –all 包管理 列举当前活跃环境下的所有包 conda list 列举一个指定环境下的所有包 conda list -n your_env_name 为激活环境安装某个包 conda install package_name 为指定环境安装某个包 conda install –name target_env_name package_name 更新当前环境某个包 conda update package_name 更新指定环境某个包 conda update -n target_env_name package_name 删除当前环境某个包 conda remove package_name注意: 如果是通过pip安装的包,移除时也请使用 pip uninstall package_name 命令移除,如果使用 conda remove 可能会发生异常,导致conda不可用 删除指定环境某个包 conda remove -n target_env_name package_name 搜索某个包信息 conda search package_name 更新anaconda conda update anaconda 更新python至最新版本 conda update python 更新所有包 conda update –all 分享环境把自己的环境分享给别人,方便他人快速建立与你一模一样的环境(同一个版本的python及各种包). 一个分享环境快速的方法就是给他人一个你要分享环境的.yml文件步骤:1) 生成欲分享环境的yml文件 conda env export &gt; environment.yml 2) 他人在自己本地使用yml文件创建文件 conda env create -f environment.yml 参考博客: https://blog.csdn.net/menc15/article/details/71477949/]]></content>
      <categories>
        <category>conda</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RESTful规范]]></title>
    <url>%2F2018%2F11%2F14%2FRESTful%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[RESTful规范 web服务交互 我们在浏览器中能看到的每个网站，都是一个web服务。那么我们在提供每个web服务的时候， 都需要前后端交互，前后端交互就一定有一些实现方案，我们通常叫web服务交互方案。 目前主流的三种web服务交互方案： -- REST （ Representational State Transfer）表述性状态转移 -- SOAP （Simple Object Access Protocol） 简单的对象访问协议 -- XML-RPC （XML Remote Procedure Call）基于XML的远程过程调用 XML-RPC是通过XML将调用函数封装，并使用HTTP协议作为传送机制。 后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协定。 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。 SOAP也是基于XML的，但是它不只限于HTTP协议的传输，包括TCP协议，UDP协议都可以传输。 REST是Roy Thomas Fielding博士于2000年在他的博士论文里提出来的。 REST相比SOAP更加简洁，性能和开发效率也有突出的优势。 我们今天主要说一下这个REST，现在越来越多的web服务开始采用REST风格设计和实现。 例如，amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 我们接下来要学的框架也是遵循REST风格的，那么我们来看下它到底是个什么样的风格， 了解了它是什么后，我们看下它的优点是什么，我们为什么用它。 REST风格资源 网页中能看到的都是资源 URL 统一资源定位符  URI 统一资源标识符 统一资源接口 对资源的操作根据HTTP请求方式的不同来进行不同的操作 遵循HTTP请求方式的语义 前后端传输的是资源的表述 展现的是资源的转态 凡是遵循TEST风格实现的前后端交互都叫RESTful架构核心思想面向资源去编程 url中尽量名词不要动词 根据HTTP请求方式的不同对资源进行不同的 在url中体现的体现版本 https://v3.bootcss.com/ https://.bootcss.com/v3 体现是否是API https://v3.bootcss.com/api 有过滤条件 https://v3.bootcss.com/course?page=1 尽量用https 在返回值中携带状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 返回值 get 返回查看的所有或者单条数据 post 返回新增的这条数据 put/patch 返回更新的这条数据 delete 返回值空 携带错误信息 携带超链接 在不分离的项目用的多 ret = { code: 1000, data:{ id:1, name:&apos;小强&apos;, depart_id:http://www.luffycity.com/api/v1/depart/8/ } }]]></content>
      <categories>
        <category>restful framework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vuex+axios]]></title>
    <url>%2F2018%2F11%2F13%2FVuex-axios%2F</url>
    <content type="text"><![CDATA[Vuex+axios Vuex 简介vuex是一个专门为Vue.js设计的集中式状态管理架构。 状态？ 我们把它理解为在data中需要共享给其他组件使用的部分。 Vuex和单纯的全局对象有以下不同： 1、Vuex 的状态存储是响应式的。当vue组件从store中读取状态的时候， 若store中的状态发生变化，那么相应的组件也会相应的得到高效更新。 2、你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示的 提交(commit)mutation。这样使得我们可以方便的跟踪每一个状态的变化， 从而让我们能够实现一些工具来帮助我们更好的了解我们的应用。 安装使用vuex– npm install vuex vuex的使用一 // main.js import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import vuex from &apos;vuex&apos; Vue.use(vuex) Vue.config.productionTip = false const store = new vuex.Store({ state: { show: false, } }); new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); vuex的使用二 // 为了方便维护，我们通常把在src下面新建一个store文件夹， // 然后在里面新建一个index.js import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { show: false, }, }); // 那么main.js要改成 import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &quot;./store&quot; Vue.config.productionTip = false; new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }); State简而言之~~state是保存我们data中需要共享的数据。 由于Vuex的存储是响应式的，从store实例中读取状态的最简单的方式就是在计算属性中返回某个状态。 this.$store.state.count 组件中获取vuex中状态 // 创建一个组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count(){ return this.$store.state.count } } }; Getter有时候我们需要从store中的state中派生出一些状态，例如对数据进行简单的计算。 并且很多组件都需要用到此方法，我们要么复制这个函数，要么抽取到一个公共函数，多处导入。 我们vuex提供了更加方便的方法，getter ，它就像计算属性一样，getter的返回值会根据它的依赖被 缓存起来，只有它的依赖发生改变时，才会重新计算。 Getter会接收state作为其第一个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 } }, }); Getter也可以接收getters为第二个参数： import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 通过 this.$store.getters.my_func getters: { my_func: function (state) { return state.count * 2 }, // 通过 this.$store.getters.my_func_count my_func_count: function (state, getters) { return getters.my_func.length } }, }); Mutatiion更改Vuex中的store中的状态的唯一方法是提交mutation。 每个mutation都有一个字符串的事件类型(type)，和一个回调函数handler。 也就是说我们要触发mutation中定义的方法(type)，然后才会执行这个方法(handler)。 这个方法就是我们更改状态的地方，它会接收state为第一个参数，后面接收其他参数： Mutation基本使用 import Vue from &apos;vue&apos; import Vue_x from &quot;vuex&quot; Vue.use(Vue_x); export default new Vue_x.Store({ state: { count: 20, }, // 需要通过 this.$store.commit(&apos;increment&apos;, 10) mutations: { increment (state, n) { // 变更状态 state.count += n } } }); Mutation需要遵守Vue的响应规则 既然vuex中的store中的状态是响应式的，那么当我们状态变更时，监视状态的vue组件也会更新。 这就意味着vuex中的mutation也需要与使用vue一样遵守一些注意事项： – 1，最好提前在你的store中初始化好所有的所需要的属性 – 2，当对象需要添加属性时，你应该使用 – Vue.set(obj, ‘newProp’, 123) – 以新对象代替老对象 state.obj = { …state.obj, newProp: 123} axios的简单使用基于Promise的HTTP请求客户端，可以同时在浏览器和node.js使用。 ## 使用npm安装axios – npm install axios -D 基本的配置// main.js import axios from &quot;axios&quot; Vue.prototype.$axios = axios // 组件中 methods: { init () { this.$axios({ method: &quot;get&quot;, url: &quot;/user&quot; }) }, }; 基本的使用get请求 test(){ this.$axios.get(this.$store.state.apiList.course,{ params: { id: 123, } }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } post请求 test(){ this.$axios.post(this.$store.state.apiList.course,{ course_title: &quot;Python&quot;, course_price: &quot;19.88&quot; }).then(function (response) { // 请求成功回调函数 }).catch(function (response) { // 请求失败的回调函数 }) } 发送多个并发请求 function getCourse(){ return this.$axios.get(&apos;/course/12&apos;) } function getCourse_all() { return this.$axios.get(&apos;/course&apos;) } this.$axios.all([getCourse_all(),getCourse()]) .then().catch() axios.request methods: { init(){ var that = this this.$axios.request({ url: that.$store.state.apiList.course, method: &apos;get&apos; }).then(function (data) { if (data.status === 200){ that.courseList = data.data } }).catch(function (reason) { console.log(reason) }) } },]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm+webpack+vue-cli快速上手]]></title>
    <url>%2F2018%2F11%2F13%2Fnpm-webpack-vue-cli%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[npm+webpack+vue-cli快速上手 Node.js npm什么是Node.js 以及npm简单的来说 Node.js 就是运行在服务端的JavaScript，基于Chrome V8 引擎的。 npm 是Node.js 的包管理工具。 npm的安装和更新Node.js下载安装 Node.js 官网下载安装。npm自带的包管理工具。 查看安装版本信息： – node -v 查看Node.js 版本信息 – npm -v 查看npm版本信息 更新npm到指定版本： – npm install npm@5.3.0 -g – npm install npm@latest -g 更新最新的稳定版本 npm 常用操作之前我们用JQuery或者Bootstrap用cdn 或者直接手动下载并放入项目，而且要管理版本。 有了npm，我们管理自己的依赖包以及版本更加简单。 到自己项目目录下，进行以下命令： – npm init -y 输入-y使用默认配置项 生成package.json文件。 – npm i jquery@0.0.0 简写install 为 i 下载依赖 不写@ 默认最新版本 – npm uninstall jquery 卸载依赖包 – npm update jquery 更新依赖包 – npm list 列出已安装的依赖 – npm install webpack –D 保存为开发环境依赖 – 老版本需要 –save 参数 现在不需要了 我们的项目目录下会生成一个 node_modules 目录，我们用npm下的包会在这个目录下。 我们所有的依赖信息放在package.json文件中，包括我们所有的依赖以及版本。 如果我们删掉 node_modules目录，可以使用 npm i 来下载所有依赖。 npm 常用配置项当我们用npm init 的时候用了参数 -y，如果不用-y我们可以进行一些配置。 在我们的package.json文件中有很多配置项 – name 项目名字 中间不能有空格只能用小写 – version 项目版本 – description 项目描述信息 – main 项目的入口文件 – scripts 指定命令的快捷方式 npm run test test是scripts里的键名 值为具体命令 – author 作者 – license 许可证 – dependencies 生成环境依赖的包以及版本信息 – devDependencies 开发环境的依赖 webpack3webpack是什么webpack是一个模块打包器，它将根据模块的依赖关系进行静态分析， 然后将这些模块按照指定的规则生成静态资源。 那么，我们为什么要用这个东西呢~~因为前端的包袱太多，历史遗留问题太重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113##安装和配置 webpack是跑在Node.js环境下的，所以确定自己有node环境。安装方式： -- npm install webpack -g 全局安装 -- webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 全局这种方式进行打包 -- npm install webpack 在自己的项目下 npm init 后在下载webpack 这就是局部安装 -- node_modules/.bin/webpack &lt;要打包文件&gt; &lt;打包后文件&gt; 项目里要打包文件是入口文件 -- 路径太长 太烦 可以自定义命令 在package.json 文件的 scripts下面自定义## entry 和 output entry 入口文件 output 出口文件 上面我们自定义命令的时候 命令太长了~~而且我们命令太多的时候我们需要每次都自定义多条命令~~ 我们可以把命令写在webpack.config.js文件中~~&gt;webpack.config.jsmodule.export = &#123; // 所有的入口文件 entry: &#123; home: &apos;./main.js&apos;, login: &apos;./login.js&apos;, &#125;, // 出口文件 output: &#123; filename: &apos;[name].bundle.js&apos;, path: __dirname + &apos;/dist&apos;, &#125; &#125;// backage.json 下的scriptsscripts: &#123; &quot;pack&quot;: &quot;node_moudles/.bin/webpack --watch&quot;&#125;// 运行命令npm run pack# webpack4## webpack的新特性1, webpack不在单独使用，需要webpack-cli -- 全局安装 npm install webpack webpack-cli -g -D -- 局部安装 npm install webpack webpack-cli -D2, 增加了模式区分 （development, production） --webpack --mode development/production 进行模式切换 -- development 开发者模式 打包默认不压缩代码 -- production 生产者模式 上线时使用，压缩代码。 默认是这个模式3，固定入口目录为src，与入口默认文件index.js，打包后文件在新增的dist目录下 -- 当只有一个入口文件也就是src/index.js时，无需增加webpack.config.js4，多入口以及多出口&gt;webpack.config.js entry: &#123; // 多入口 a: &quot;./src/js/index.js&quot;, b: &quot;./src/js/index2.js&quot;,&#125;output: &#123; // 多出口 path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;./js/[name].bundle.js&apos;&#125;# vue-clivue-cli是官方提供的快速构建这个单页面应用的脚手架。## 根据官方文档中的构件流程： -- 前提是已经安装了node.js 否则npm都用不了 -- 1，使用npm全局安装vue-cli npm install -g vue-cli -- 2, 安装完成后在自己的工作空间里 vue init webpack vue-demo 输入命令后进入安装阶段，需要用户输入一些信息 这里省略了..... -- 3，切换到我们的项目目录下 cd vue-demo npm run dev## 目录结构： -- build 里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件 -- config 配置文件，执行文件需要的配置信息 -- src 资源文件 所有的组件以及所有的图片 都在这个文件夹下 -- node_modules 项目依赖包 -- static 静态资源 -- package.json 依赖包的json文件其实这里面命令很多~我们在后续项目中应用到再说 vue-cli配置JQuery、bootstrap第一步 下载安装 – npm install jquery – npm install bootstrap 第二步 修改build/webpack.base.conf.js const webpack = require(‘webpack’)// 在module.exports里添加插件plugins: [ new webpack.ProvidePlugin({ $: “jquery”, jQuery: “jquery”, “windows.jQuery”: “jquery”, // Popper: [‘popper.js’, ‘default’] })],// ***下面是如果手动下载bootstrap用的***resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘vue$’: ‘vue/dist/vue.esm.js’, ‘@’: resolve(‘src’), // 如果是手动下载的bootstrap需要添加这个配置 // ‘assets’: path.resolve(__dirname, ‘../src/assets’), // ‘jquery’: ‘jquery/src/jquery’ } }, 修改配置文件 第三步 修改主程序的js文件 main.js import $ from ‘jquery’import ‘bootstrap/dist/css/bootstrap.min.css’import ‘bootstrap/dist/js/bootstrap.min.js’ vue-cli 3.0第一步 下载vue-cli 3.0 – npm install -g @vue/cli – 报错 npm error 可以运行下面命令 – npm cache clean –force &amp;&amp; npm cache verify 第二步 创建项目 – vue create xxxx 之后会出现很多选项，我们可以根据自己的习惯去选择~~ 第三步 目录结构以及配置文件 – vue-cli3 目录更加简单 – 我们手动在项目根目录下创建 vue.config.js 里面写vue的配置信息 vue-cli3 配置jQuery、bootstrap – 跟vue-cli2一样的配置，手动创建一个webpack.base.conf.js]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git上]]></title>
    <url>%2F2018%2F11%2F13%2Fgit%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[git上目录： 建立本地版本库 本地版本库与远程关联 修改文件并提交 创建分支,修改文件合并至master git的由来linux系统是很多开发者贡献代码不断完善的,linux的创始人linus起初管理贡献者的代码,是通过手工的方式,但随着代码的增多,很难通过手工方式去管理,于是找了一个商业的版本控制系统BitKeeper管理代码. 开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ 集中式与分布式区别- 集中式： cvs, svn 版本库集中放在中央服务器上,所有人干活时,都要先从中央服务器获取最新版本到本地,然后在本地修改,干完活后,将修改推送到中央服务器. **必须联网**才能工作. - 分布式 每个人的电脑都是一个版本库,工作的时候 **不需要联网**,直接在本地修改,提交就可以.你和同事同时修改一个文件A,修改完成后互相将自己修改的文件推送给对方即可. **安全性高**, 每个人的本地都有一个完整的版本库,某个人的电脑突然崩溃,从其他人那直接copy一份就可以了. 但集中式版本控制系统,一旦中央服务器垮掉,版本库信息就都丢失了. 创建版本库,添加文件命令: - 创建版本库 mkdir studyGit git init - 添加文件 vim readme.txt git add readme.txt git commit -m &quot;注释说明,方便自己或他人查看&quot; 修改文件并提交命令: - vim 编辑修改文件内容 - git status 查看当前仓库状态 - git diff filename 查看文件具体改动内容 - 提交: git add filename git commit -m &quot;本次提交注释说明&quot; 版本回退Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向至你切换的版本. 命令: - 回退到上一个版本 git reset --hard HEAD^ - 回退到上上版本 git reset --hard HEAD^^ - 回退到指定版本 git log 查看你要切换版本的commit id 或 git log --pretty=oneline git reset --hard target_commit_id - 回退之后后悔了,想切换到回退前的版本 1) 通过git log是找不到回退前那次提交的日志的,没办法指定commit id回退切换 2) 通过git reflog查看, git reflog是记录我们的历史命令的,找到你那次提交历史命令前的commit id,即可切换回去 工作区和暂存区工作区: 电脑上直接看到的,你管理的文件夹(使用git init创建的),就是工作区 暂存区: 在工作区下,隐藏的.git文件夹,其中有很多文件,有几个重要的要理解: - 暂存区: stage - 版本信息(master分支) - HEAD指针,指向具体分支 提交工作区的文件修改或新增文件: 1) git add files -&gt; 实际将这些修改先推送到本地暂存区(暂存区中存放了所有待提交的文件) 2) git commit -m &quot;说明&quot; -&gt; 提交暂存区中的所有文件至master或分支版本 管理修改工作区中readme.txt文件 1) 第一次修改, 增加一行内容, git add readme.txt 2) 第二次修改, 又增加了一行内容, 但未执行 git add readme.txt 3) git commit -m &quot;注释&quot;; 那么此次提交的只是第一次修改的内容 git diff HEAD -- readme.txt 查看工作区中与版本库中的不同之处 撤销修改1) 工作区修改,改乱了,还没有提交至暂存区; 可以通过 git checkout -- filename 恢复至与版本库一致的状态 2) 工作区修改,改乱了,但之前已提交至暂存区,撤销修改: git reset HEAD filename 把暂存区的修改撤销掉(unstage) git checkout -- filename 恢复工作区与版本库一致 删除文件git rm filename git commit -m &quot;delete file filename&quot; 远程仓库关联1) 创建ssh key: ssh-keygen -t rsa -C &quot;youremail@example.com&quot; # 一路回车即可 在用户主目录里会生成一个.ssh文件夹,里面有id_rsa和id_rsa.pub, id_rsa是私钥, id_rsa.pub是公钥; 登录github,进入个人账户settings页面,选择ssh key -&gt; add new; 添加, 将id_rsa.pub复制到页面中,完成. 2) 添加远程仓库 - 在github网站新增仓库,与本地要关联的仓库同名 - 进入本地仓库所在的目录, git remote add origin &lt;新增的远程仓库地址&gt; - git push -u origin master # 将本地仓库的master分支推送到远程服务器上,后续提交可以省略参数-u(远程初始仓库为空,所以加-u) - 本地修改文件,提交; 推送至远程 克隆远程仓库进入你想保存仓库的路径,然后执行: git clone &lt;远程仓库地址&gt; 创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突1) 在分支上修改了文件,并commit 2) 在mster上修改了文件,并commit 3) git merge &lt;ranchname&gt;; 报错, 无法实现快速合并, 需先解决冲突, 把冲突文件改成自己想要的内容, 然后 git add filename, git commit -m &quot;注释&quot;.]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue总结]]></title>
    <url>%2F2018%2F11%2F13%2FVue%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue总结 vue总结 MVC Model View Controller MVVM Model View ViweMode ES6常用语法1.1 变量的提升 1.2 模板字符串 ``${} 1.3 数据的解构 1.4 类 class extends constructor super 1.5 函数 1.5.1 注意this和普通函数的区别 1.6 箭头函数 1.7 单体模式 1.8 import export export default Vue常用指令2.1 v-text innerText 2.2 v-html innerHtml 2.3 v-for :key 2.4 v-if v-else-if v-else appendChild 2.5 v-show display 2.6 v-on @xxxx=&quot;自己处理的方法&quot; 2.7 v-bind :属性名称=“属性的值” 2.8 v-model 2.8.1 input 2.8.2 textarea 2.8.3 select 2.9 指令修饰符 2.9.1 .lazy 2.9.2 .number 2.9.3 .trim 2.10 计算属性 2.10.1 放入缓存 2.10.2 只有数据改变的时候才会重新计算 2.11 数据监听 2.11.1 注意可变类型和不可变 2.11.2 深监听 deep=true 2.12 获取DOM 2.12.1 给便签绑定ref属性 ref=“属性值” 2.12.2 this.$refs.属性值 2.13 自定义指令 2.13.1 vue.directive(“指令名称”, function(el, binding){ el 绑定指令的便签元素 binding 指令的所有信息 }) 注意事项3.1 数据监听 3.1.1 改变数据 直接赋值 3.1.2 改变数组长度 能够被监听到，新值和旧值一样 3.1.3 改变数组内的值 app = new vue({}) app.$set(this.hobby, 0, &apos;抽烟&apos;) $set()修改数组中的值可以监听 $delete() Vue的组件组件的注册全局注册Vue.compontent(“组件名称”, {}) 局部注册const = app = new Vue({ el: &apos;#app&apos;, components: { 组件的名称: 组件的配置信息 } }) 子组件的注册在父组件中注册components ## 注意写组件标签 ## 每个组件的template只识别一个作用域块 通信父子的通信在父组件中给子组件绑定属性 子组件通过props=[&quot;属性名称&quot;] 子父的通信子组件先提交事件 this.$emit(&quot;事件名称&quot;, 值) 在父组件中给子组件绑定事件 &lt;child @事件名称=&quot;父亲处理的方法&quot;&gt;&lt;/child&gt; 非父子的通信其中一个组件向中间调度器提交事件 另一个组件监听中间调度器的事件 注意this的问题 中间调度器 let temp = new Vue(); temp.$emit(&quot;say&quot;, value) // 事件名称和值 mounted(){ that = this // 监听中间调度器中的方法 temp.$on(&quot;say&quot;, function(data){ // 这里的this是temp的this that.xxx = data // 这样改值 }) } 插槽&lt;slot&gt;&lt;/slot&gt; 命名的插槽 混合代码重用的 mixins = [base] Vue的生命周期vue生命周期之beforeCreate实例创建之前除标签外，所有的vue需要的数据，事件都不存在 vue生命周期之created实例创建之后，data和事件已经被解析到，el还没有找到 vue生命周期之beforeMount开始找标签，数据还没有被渲染，事件也没有被监听 vue生命周期之mounted开始渲染数据，开始监听事件 vue生命周期之beforeUpdata数据已经被修改在虚拟DOM，但没有被渲染到页面上 vue生命周期之updata开始使用Diff算法，将虚拟DOM中的修改应用大页面上，此时真实DOM中数据被修改 vue生命周期之beforeDestory所有的数据都存在 vue生命周期之destoryed所有的数据都有(虚拟DOM中找数据)展示的真实DOM已经是静态页面了 &lt;keep-alive&gt;&lt;/keep-alive&gt;vue提供的用来缓存被消除的标签 用activated和deactivated取代了beforeUpdate和destory的执行 最常用的钩子beforeMount mounted 路由注册let url = [ { path: &apos;/&apos;, name: &quot;home&quot;, component: { template: ``, } } ] let router = nwe VueRouter({ routes: url }) const app = new Vue({ el: &apos;app&apos;, router: router, }) &lt;router-link to=&apos;/&apos;&gt;首页&lt;/router-link&gt; &lt;router-link :to=&apos;{name: &quot;home&quot;}&apos;&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 子路由children: [ {} ] append 在父路由对应的组件的template里面写router-link router-view 路由的命名name 注意to加冒号动态绑定 路由的参数{ path: &quot;/course/:id&quot;, } this.$route.params.id this.$route.query.xxx $route 是一个对象 存放当前路由的所有信息 $router VueRouter实例化对象 手动路由this.$router.push(&apos;/&apos;) this.$router.push({name:&quot;home&quot;}) 重定向redirect: {name: &apos;xxx&apos;, params: {key: value}} 路由的钩子router.beforeEach(function(to, from next){ // to 你要去哪 // from 你要从哪里来 // next() 你要去做什么 参数可以给路径 必须有，没有就不走 }) router.afterEach(function(to, from){ // to 你要去哪 // from 你从哪里来 }) to和from都是$route对象 路由的所有信息  node.js + npm + webpack + vue-cli(自带webpack)node.js / npm - npm 管理工作目录 npm init -y - 下载包 npm i xxx@0.0.0 - 卸载 npm uninstall xxx - 更新 npm updata xxx webpack 4 - 下载 npm i webpack webpack-cli - 打包 webpack --mode development/production - 打包默认的入口文件 src目录下的index.js - 出口文件 dist目录的main.js wue-cli 2 - 帮助我们快速搭建项目的脚手架工具 - 下载 npm i vue-cli - 用vue-cli帮助我们创建项目 vue init webpack xxxx(项目名称) - 启动项目 cd xxxx(项目名称) npm run dev - 打吧包 npm run build Vuex和axiosVuex存放一些公共的东西,是一个仓库 安装 npm i vuex 配置 导入 import vuex from &quot;vuex&quot; vue使用vuex vue.use(vuex) 实例化仓库 new vuex.Store({ state: {}, getters: {}, mutations: {} }) new Vue({ el: &apos;#app&apos;, store, }) 获取残仓库数据 this.$store.state.xxx this.$store.getters.xxx 改变仓库中的数据 组件向仓库提交修改事件 this.$store.commit(&quot;事件名称&quot;, data) 在仓库中的mutations中 mutations: { &quot;事件名称&quot;: function(state, data){ 修改state中的数据 } } 注意计算属性 仓库中的数据建议都放在计算属性中 axios向后端服务器发送请求 实现ajax技术的工具 配置 下载 npm i axios 导入 import axios from “axios” 在vue的原型链中加入方法 Vue.prototype.#axios = axios 发送请求 this.$axios.request({ url: &apos;&apos;, method: &apos;&apos;, }).then(function(){ }).catch(function(){ }) 前后端的接通后端设计一个接口 前端通过axios发送请求拿到数据 跨域问题 element-ui按照文档安装，并研究如何使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
